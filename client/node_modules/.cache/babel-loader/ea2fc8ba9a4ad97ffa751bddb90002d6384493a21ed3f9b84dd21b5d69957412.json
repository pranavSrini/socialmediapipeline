{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nvar qs_1 = __importDefault(require(\"qs\"));\nvar style_serializer_1 = __importDefault(require(\"./style-serializer\"));\n// Certain styles don't support empty values.\nfunction shouldNotStyleEmptyValues(parameter) {\n  return ['simple', 'spaceDelimited', 'pipeDelimited', 'deepObject'].includes(parameter.style);\n}\nfunction shouldNotStyleReservedHeader(parameter) {\n  return ['accept', 'authorization', 'content-type'].includes(parameter.name.toLowerCase());\n}\n/**\n * Note: This isn't necessarily part of the spec. Behavior for the value 'undefined' is, well,\n * undefined. This code makes our system look better. If we wanted to be more accurate, we might\n * want to remove this, restore the un-fixed behavior for undefined and have our UI pass in empty\n * string instead of undefined.\n */\nfunction removeUndefinedForPath(value) {\n  var finalValue = value;\n  if (typeof finalValue === 'undefined') {\n    return '';\n  }\n  if (Array.isArray(finalValue)) {\n    finalValue = finalValue.filter(function (val) {\n      return val === undefined ? '' : val;\n    });\n    if (finalValue.length === 0) {\n      finalValue = '';\n    }\n  }\n  if (typeof finalValue === 'object') {\n    Object.keys(finalValue).forEach(function (key) {\n      finalValue[key] = finalValue[key] === undefined ? '' : finalValue[key];\n    });\n  }\n  return finalValue;\n}\nfunction stylizeValue(value, parameter) {\n  var finalValue = value;\n  // Some styles don't work with empty values. We catch those there\n  if (shouldNotStyleEmptyValues(parameter) && (typeof finalValue === 'undefined' || finalValue === '')) {\n    // Paths need return an unstyled empty string instead of undefined so it's ignored in the final\n    // path string.\n    if (parameter[\"in\"] === 'path') {\n      return '';\n    }\n    // Everything but path should return undefined when unstyled so it's ignored in the final\n    // parameter array.\n    return undefined;\n  }\n  // Every style that adds their style to empty values should use emptystring for path parameters\n  // instead of undefined to avoid the string `undefined`.\n  if (parameter[\"in\"] === 'path') {\n    finalValue = removeUndefinedForPath(finalValue);\n  }\n  /**\n   * Eventhough `accept`, `authorization`, and `content-type` headers can be defined as parameters,\n   * they should be completely ignored when it comes to serialization.\n   *\n   *  > If `in` is \"header\" and the `name` field is \"Accept\", \"Content-Type\" or \"Authorization\", the\n   *  > parameter definition SHALL be ignored.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#fixed-fields-10}\n   */\n  if (parameter[\"in\"] === 'header' && shouldNotStyleReservedHeader(parameter)) {\n    return value;\n  }\n  /**\n   * All parameter types have a default `style` format so if they don't have one prescribed we\n   * should still conform to what the spec defines.\n   *\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#user-content-parameterstyle}\n   * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-parameterstyle}\n   */\n  var style = parameter.style;\n  if (!style) {\n    if (parameter[\"in\"] === 'query') {\n      style = 'form';\n    } else if (parameter[\"in\"] === 'path') {\n      style = 'simple';\n    } else if (parameter[\"in\"] === 'header') {\n      style = 'simple';\n    } else if (parameter[\"in\"] === 'cookie') {\n      style = 'form';\n    }\n  }\n  var explode = parameter.explode;\n  if (explode === undefined && style === 'form') {\n    /**\n     * Per the spec if no `explode` is present but `style` is `form` then `explode` should default to `true`.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#user-content-parameterexplode}\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-parameterexplode}\n     */\n    explode = true;\n  }\n  return (0, style_serializer_1[\"default\"])(__assign({\n    location: parameter[\"in\"],\n    value: finalValue,\n    key: parameter.name,\n    style: style,\n    explode: explode,\n    /**\n     * @todo this parameter is optional to stylize. It defaults to false, and can accept falsy, truthy, or \"unsafe\".\n     *  I do not know if it is correct for query to use this. See style-serializer for more info\n     */\n    escape: true\n  }, parameter[\"in\"] === 'query' ? {\n    isAllowedReserved: parameter.allowReserved || false\n  } : {}));\n}\nfunction handleDeepObject(value, parameter) {\n  return qs_1[\"default\"].stringify(value, {\n    // eslint-disable-next-line consistent-return\n    encoder: function (str, defaultEncoder, charset, type) {\n      if (type === 'key') {\n        // `str` will be here as `dog[treats][0]` but because the `qs` library doesn't have any\n        // awareness of our OpenAPI parameters we need to rewrite it to slap the `parameter.name`\n        // to the top, like `pets[dog][treats][0]`.\n        var prefixedKey = str.split(/[[\\]]/g).filter(Boolean).map(function (k) {\n          return \"[\".concat(k, \"]\");\n        }).join('');\n        return \"\".concat(parameter.name).concat(prefixedKey);\n      } else if (type === 'value') {\n        return stylizeValue(str, parameter);\n      }\n    }\n  }).split('&').map(function (item) {\n    var split = item.split('=');\n    return {\n      label: split[0],\n      // `qs` will coerce null values into being `undefined` string but we want to preserve them.\n      value: split[1] === 'undefined' ? null : split[1]\n    };\n  });\n}\n// Explode is handled on its own, because style-serializer doesn't return what we expect for proper\n// HAR output.\nfunction handleExplode(value, parameter) {\n  var _a;\n  // This is to handle the case of arrays of objects in the querystring\n  // which is something that's not technically in the spec but since we're\n  // using the `qs` module already, it's fairly easy for us to add support\n  // for this use case.\n  //\n  // An example URL would be something like this:\n  // https://example.com/?line_items[0][a_string]=abc&line_items[0][quantity]=1&line_items[1][a_string]=def&line_items[1][quantity]=2\n  //\n  // Some open issues discussing this here:\n  // https://github.com/OAI/OpenAPI-Specification/issues/1706\n  // https://github.com/OAI/OpenAPI-Specification/issues/1006\n  //\n  // Link to the spec for this:\n  // https://github.com/OAI/OpenAPI-Specification/blob/36a3a67264cc1c4f1eff110cea3ebfe679435108/versions/3.1.0.md#style-examples\n  if (Array.isArray(value) && ((_a = parameter.schema) === null || _a === void 0 ? void 0 : _a.type) === 'array' && parameter.style === 'deepObject') {\n    var newObj_1 = {};\n    var deepObjs = handleDeepObject(value, parameter);\n    deepObjs.forEach(function (obj) {\n      newObj_1[obj.label] = obj.value;\n    });\n    return newObj_1;\n  }\n  if (Array.isArray(value)) {\n    return value.map(function (val) {\n      return stylizeValue(val, parameter);\n    });\n  }\n  if (typeof value === 'object' && value !== null) {\n    var newObj_2 = {};\n    Object.keys(value).forEach(function (key) {\n      if (parameter.style === 'deepObject') {\n        var deepObjs = handleDeepObject(value, parameter);\n        deepObjs.forEach(function (obj) {\n          newObj_2[obj.label] = obj.value;\n        });\n      } else {\n        newObj_2[key] = stylizeValue(value[key], parameter);\n      }\n    });\n    return newObj_2;\n  }\n  return stylizeValue(value, parameter);\n}\nfunction shouldExplode(parameter) {\n  return (parameter.explode || parameter.explode !== false && parameter.style === 'form') &&\n  // header and path doesn't explode into separate parameters like query and cookie do\n  parameter[\"in\"] !== 'header' && parameter[\"in\"] !== 'path';\n}\nfunction formatStyle(value, parameter) {\n  // Deep object style only works on objects and arrays, and only works with explode=true.\n  if (parameter.style === 'deepObject' && (!value || typeof value !== 'object' || parameter.explode === false)) {\n    return undefined;\n  }\n  // This custom explode logic allows us to bubble up arrays and objects to be handled differently\n  // by our HAR transformer. We need this because the `stylizeValue` function assumes we're building\n  // strings, not richer data types.\n  //\n  // The first part of this conditional checks if `explode` is enabled. Explode is disabled for\n  // everything by default except for forms.\n  //\n  // The second part of this conditional bypasses the custom explode logic for headers, because they\n  // work differently, and `stylizeValue` is accurate.\n  if (shouldExplode(parameter)) {\n    return handleExplode(value, parameter);\n  }\n  return stylizeValue(value, parameter);\n}\nexports[\"default\"] = formatStyle;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__importDefault","mod","__esModule","exports","qs_1","require","style_serializer_1","shouldNotStyleEmptyValues","parameter","includes","style","shouldNotStyleReservedHeader","name","toLowerCase","removeUndefinedForPath","value","finalValue","Array","isArray","filter","val","undefined","keys","forEach","key","stylizeValue","explode","location","escape","isAllowedReserved","allowReserved","handleDeepObject","stringify","encoder","str","defaultEncoder","charset","type","prefixedKey","split","Boolean","map","k","concat","join","item","label","handleExplode","_a","schema","newObj_1","deepObjs","obj","newObj_2","shouldExplode","formatStyle"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/oas-to-har/dist/lib/style-formatting/index.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nvar qs_1 = __importDefault(require(\"qs\"));\nvar style_serializer_1 = __importDefault(require(\"./style-serializer\"));\n// Certain styles don't support empty values.\nfunction shouldNotStyleEmptyValues(parameter) {\n    return ['simple', 'spaceDelimited', 'pipeDelimited', 'deepObject'].includes(parameter.style);\n}\nfunction shouldNotStyleReservedHeader(parameter) {\n    return ['accept', 'authorization', 'content-type'].includes(parameter.name.toLowerCase());\n}\n/**\n * Note: This isn't necessarily part of the spec. Behavior for the value 'undefined' is, well,\n * undefined. This code makes our system look better. If we wanted to be more accurate, we might\n * want to remove this, restore the un-fixed behavior for undefined and have our UI pass in empty\n * string instead of undefined.\n */\nfunction removeUndefinedForPath(value) {\n    var finalValue = value;\n    if (typeof finalValue === 'undefined') {\n        return '';\n    }\n    if (Array.isArray(finalValue)) {\n        finalValue = finalValue.filter(function (val) { return (val === undefined ? '' : val); });\n        if (finalValue.length === 0) {\n            finalValue = '';\n        }\n    }\n    if (typeof finalValue === 'object') {\n        Object.keys(finalValue).forEach(function (key) {\n            finalValue[key] = finalValue[key] === undefined ? '' : finalValue[key];\n        });\n    }\n    return finalValue;\n}\nfunction stylizeValue(value, parameter) {\n    var finalValue = value;\n    // Some styles don't work with empty values. We catch those there\n    if (shouldNotStyleEmptyValues(parameter) && (typeof finalValue === 'undefined' || finalValue === '')) {\n        // Paths need return an unstyled empty string instead of undefined so it's ignored in the final\n        // path string.\n        if (parameter[\"in\"] === 'path') {\n            return '';\n        }\n        // Everything but path should return undefined when unstyled so it's ignored in the final\n        // parameter array.\n        return undefined;\n    }\n    // Every style that adds their style to empty values should use emptystring for path parameters\n    // instead of undefined to avoid the string `undefined`.\n    if (parameter[\"in\"] === 'path') {\n        finalValue = removeUndefinedForPath(finalValue);\n    }\n    /**\n     * Eventhough `accept`, `authorization`, and `content-type` headers can be defined as parameters,\n     * they should be completely ignored when it comes to serialization.\n     *\n     *  > If `in` is \"header\" and the `name` field is \"Accept\", \"Content-Type\" or \"Authorization\", the\n     *  > parameter definition SHALL be ignored.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#fixed-fields-10}\n     */\n    if (parameter[\"in\"] === 'header' && shouldNotStyleReservedHeader(parameter)) {\n        return value;\n    }\n    /**\n     * All parameter types have a default `style` format so if they don't have one prescribed we\n     * should still conform to what the spec defines.\n     *\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#user-content-parameterstyle}\n     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-parameterstyle}\n     */\n    var style = parameter.style;\n    if (!style) {\n        if (parameter[\"in\"] === 'query') {\n            style = 'form';\n        }\n        else if (parameter[\"in\"] === 'path') {\n            style = 'simple';\n        }\n        else if (parameter[\"in\"] === 'header') {\n            style = 'simple';\n        }\n        else if (parameter[\"in\"] === 'cookie') {\n            style = 'form';\n        }\n    }\n    var explode = parameter.explode;\n    if (explode === undefined && style === 'form') {\n        /**\n         * Per the spec if no `explode` is present but `style` is `form` then `explode` should default to `true`.\n         *\n         * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#user-content-parameterexplode}\n         * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#user-content-parameterexplode}\n         */\n        explode = true;\n    }\n    return (0, style_serializer_1[\"default\"])(__assign({ location: parameter[\"in\"], value: finalValue, key: parameter.name, style: style, explode: explode, \n        /**\n         * @todo this parameter is optional to stylize. It defaults to false, and can accept falsy, truthy, or \"unsafe\".\n         *  I do not know if it is correct for query to use this. See style-serializer for more info\n         */\n        escape: true }, (parameter[\"in\"] === 'query' ? { isAllowedReserved: parameter.allowReserved || false } : {})));\n}\nfunction handleDeepObject(value, parameter) {\n    return qs_1[\"default\"]\n        .stringify(value, {\n        // eslint-disable-next-line consistent-return\n        encoder: function (str, defaultEncoder, charset, type) {\n            if (type === 'key') {\n                // `str` will be here as `dog[treats][0]` but because the `qs` library doesn't have any\n                // awareness of our OpenAPI parameters we need to rewrite it to slap the `parameter.name`\n                // to the top, like `pets[dog][treats][0]`.\n                var prefixedKey = str\n                    .split(/[[\\]]/g)\n                    .filter(Boolean)\n                    .map(function (k) { return \"[\".concat(k, \"]\"); })\n                    .join('');\n                return \"\".concat(parameter.name).concat(prefixedKey);\n            }\n            else if (type === 'value') {\n                return stylizeValue(str, parameter);\n            }\n        }\n    })\n        .split('&')\n        .map(function (item) {\n        var split = item.split('=');\n        return {\n            label: split[0],\n            // `qs` will coerce null values into being `undefined` string but we want to preserve them.\n            value: split[1] === 'undefined' ? null : split[1]\n        };\n    });\n}\n// Explode is handled on its own, because style-serializer doesn't return what we expect for proper\n// HAR output.\nfunction handleExplode(value, parameter) {\n    var _a;\n    // This is to handle the case of arrays of objects in the querystring\n    // which is something that's not technically in the spec but since we're\n    // using the `qs` module already, it's fairly easy for us to add support\n    // for this use case.\n    //\n    // An example URL would be something like this:\n    // https://example.com/?line_items[0][a_string]=abc&line_items[0][quantity]=1&line_items[1][a_string]=def&line_items[1][quantity]=2\n    //\n    // Some open issues discussing this here:\n    // https://github.com/OAI/OpenAPI-Specification/issues/1706\n    // https://github.com/OAI/OpenAPI-Specification/issues/1006\n    //\n    // Link to the spec for this:\n    // https://github.com/OAI/OpenAPI-Specification/blob/36a3a67264cc1c4f1eff110cea3ebfe679435108/versions/3.1.0.md#style-examples\n    if (Array.isArray(value) &&\n        ((_a = parameter.schema) === null || _a === void 0 ? void 0 : _a.type) === 'array' &&\n        parameter.style === 'deepObject') {\n        var newObj_1 = {};\n        var deepObjs = handleDeepObject(value, parameter);\n        deepObjs.forEach(function (obj) {\n            newObj_1[obj.label] = obj.value;\n        });\n        return newObj_1;\n    }\n    if (Array.isArray(value)) {\n        return value.map(function (val) {\n            return stylizeValue(val, parameter);\n        });\n    }\n    if (typeof value === 'object' && value !== null) {\n        var newObj_2 = {};\n        Object.keys(value).forEach(function (key) {\n            if (parameter.style === 'deepObject') {\n                var deepObjs = handleDeepObject(value, parameter);\n                deepObjs.forEach(function (obj) {\n                    newObj_2[obj.label] = obj.value;\n                });\n            }\n            else {\n                newObj_2[key] = stylizeValue(value[key], parameter);\n            }\n        });\n        return newObj_2;\n    }\n    return stylizeValue(value, parameter);\n}\nfunction shouldExplode(parameter) {\n    return ((parameter.explode || (parameter.explode !== false && parameter.style === 'form')) &&\n        // header and path doesn't explode into separate parameters like query and cookie do\n        parameter[\"in\"] !== 'header' &&\n        parameter[\"in\"] !== 'path');\n}\nfunction formatStyle(value, parameter) {\n    // Deep object style only works on objects and arrays, and only works with explode=true.\n    if (parameter.style === 'deepObject' && (!value || typeof value !== 'object' || parameter.explode === false)) {\n        return undefined;\n    }\n    // This custom explode logic allows us to bubble up arrays and objects to be handled differently\n    // by our HAR transformer. We need this because the `stylizeValue` function assumes we're building\n    // strings, not richer data types.\n    //\n    // The first part of this conditional checks if `explode` is enabled. Explode is disabled for\n    // everything by default except for forms.\n    //\n    // The second part of this conditional bypasses the custom explode logic for headers, because they\n    // work differently, and `stylizeValue` is accurate.\n    if (shouldExplode(parameter)) {\n        return handleExplode(value, parameter);\n    }\n    return stylizeValue(value, parameter);\n}\nexports[\"default\"] = formatStyle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}