{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n    i,\n    q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n  function awaitReturn(f) {\n    return function (v) {\n      return Promise.resolve(v).then(f, reject);\n    };\n  }\n  function verb(n, f) {\n    if (g[n]) {\n      i[n] = function (v) {\n        return new Promise(function (a, b) {\n          q.push([n, v, a, b]) > 1 || resume(n, v);\n        });\n      };\n      if (f) i[n] = f(i[n]);\n    }\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FalStream = void 0;\nexports.createStreamingClient = createStreamingClient;\nconst eventsource_parser_1 = require(\"eventsource-parser\");\nconst auth_1 = require(\"./auth\");\nconst request_1 = require(\"./request\");\nconst response_1 = require(\"./response\");\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n/**\n * The class representing a streaming response. With t\n */\nclass FalStream {\n  constructor(endpointId, config, options) {\n    var _a;\n    // support for event listeners\n    this.listeners = new Map();\n    this.buffer = [];\n    // local state\n    this.currentData = undefined;\n    this.lastEventTimestamp = 0;\n    this.streamClosed = false;\n    this.abortController = new AbortController();\n    this.start = () => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const {\n        endpointId,\n        options\n      } = this;\n      const {\n        input,\n        method = \"post\",\n        connectionMode = \"server\"\n      } = options;\n      try {\n        if (connectionMode === \"client\") {\n          // if we are in the browser, we need to get a temporary token\n          // to authenticate the request\n          const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId, this.config);\n          const {\n            fetch\n          } = this.config;\n          const parsedUrl = new URL(this.url);\n          parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n          const response = yield fetch(parsedUrl.toString(), {\n            method: method.toUpperCase(),\n            headers: {\n              accept: (_a = options.accept) !== null && _a !== void 0 ? _a : CONTENT_TYPE_EVENT_STREAM,\n              \"content-type\": \"application/json\"\n            },\n            body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n            signal: this.abortController.signal\n          });\n          return yield this.handleResponse(response);\n        }\n        return yield (0, request_1.dispatchRequest)({\n          method: method.toUpperCase(),\n          targetUrl: this.url,\n          input,\n          config: this.config,\n          options: {\n            headers: {\n              accept: (_b = options.accept) !== null && _b !== void 0 ? _b : CONTENT_TYPE_EVENT_STREAM\n            },\n            responseHandler: this.handleResponse,\n            signal: this.abortController.signal\n          }\n        });\n      } catch (error) {\n        this.handleError(error);\n      }\n    });\n    this.handleResponse = response => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      if (!response.ok) {\n        try {\n          // we know the response failed, call the response handler\n          // so the exception gets converted to ApiError correctly\n          yield (0, response_1.defaultResponseHandler)(response);\n        } catch (error) {\n          this.emit(\"error\", error);\n        }\n        return;\n      }\n      const body = response.body;\n      if (!body) {\n        this.emit(\"error\", new response_1.ApiError({\n          message: \"Response body is empty.\",\n          status: 400,\n          body: undefined\n        }));\n        return;\n      }\n      const isEventStream = ((_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\").startsWith(CONTENT_TYPE_EVENT_STREAM);\n      // any response that is not a text/event-stream will be handled as a binary stream\n      if (!isEventStream) {\n        const reader = body.getReader();\n        const emitRawChunk = () => {\n          reader.read().then(({\n            done,\n            value\n          }) => {\n            if (done) {\n              this.emit(\"done\", this.currentData);\n              return;\n            }\n            this.currentData = value;\n            this.emit(\"data\", value);\n            emitRawChunk();\n          });\n        };\n        emitRawChunk();\n        return;\n      }\n      const decoder = new TextDecoder(\"utf-8\");\n      const reader = response.body.getReader();\n      const parser = (0, eventsource_parser_1.createParser)(event => {\n        if (event.type === \"event\") {\n          const data = event.data;\n          try {\n            const parsedData = JSON.parse(data);\n            this.buffer.push(parsedData);\n            this.currentData = parsedData;\n            this.emit(\"data\", parsedData);\n            // also emit 'message'for backwards compatibility\n            this.emit(\"message\", parsedData);\n          } catch (e) {\n            this.emit(\"error\", e);\n          }\n        }\n      });\n      const timeout = (_b = this.options.timeout) !== null && _b !== void 0 ? _b : EVENT_STREAM_TIMEOUT;\n      const readPartialResponse = () => __awaiter(this, void 0, void 0, function* () {\n        const {\n          value,\n          done\n        } = yield reader.read();\n        this.lastEventTimestamp = Date.now();\n        parser.feed(decoder.decode(value));\n        if (Date.now() - this.lastEventTimestamp > timeout) {\n          this.emit(\"error\", new response_1.ApiError({\n            message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n            status: 408\n          }));\n        }\n        if (!done) {\n          readPartialResponse().catch(this.handleError);\n        } else {\n          this.emit(\"done\", this.currentData);\n        }\n      });\n      readPartialResponse().catch(this.handleError);\n      return;\n    });\n    this.handleError = error => {\n      var _a;\n      // In case AbortError is thrown but the signal is marked as aborted\n      // it means the user called abort() and we should not emit an error\n      // as it's expected behavior\n      // See note on: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\n      if (error.name === \"AbortError\" || this.signal.aborted) {\n        return;\n      }\n      const apiError = error instanceof response_1.ApiError ? error : new response_1.ApiError({\n        message: (_a = error.message) !== null && _a !== void 0 ? _a : \"An unknown error occurred\",\n        status: 500\n      });\n      this.emit(\"error\", apiError);\n      return;\n    };\n    this.on = (type, listener) => {\n      var _a;\n      if (!this.listeners.has(type)) {\n        this.listeners.set(type, []);\n      }\n      (_a = this.listeners.get(type)) === null || _a === void 0 ? void 0 : _a.push(listener);\n    };\n    this.emit = (type, event) => {\n      const listeners = this.listeners.get(type) || [];\n      for (const listener of listeners) {\n        listener(event);\n      }\n    };\n    /**\n     * Gets a reference to the `Promise` that indicates whether the streaming\n     * is done or not. Developers should always call this in their apps to ensure\n     * the request is over.\n     *\n     * An alternative to this, is to use `on('done')` in case your application\n     * architecture works best with event listeners.\n     *\n     * @returns the promise that resolves when the request is done.\n     */\n    this.done = () => __awaiter(this, void 0, void 0, function* () {\n      return this.donePromise;\n    });\n    /**\n     * Aborts the streaming request.\n     *\n     * **Note:** This method is noop in case the request is already done.\n     *\n     * @param reason optional cause for aborting the request.\n     */\n    this.abort = reason => {\n      if (!this.streamClosed) {\n        this.abortController.abort(reason);\n      }\n    };\n    this.endpointId = endpointId;\n    this.config = config;\n    this.url = (_a = options.url) !== null && _a !== void 0 ? _a : (0, request_1.buildUrl)(endpointId, {\n      path: \"/stream\",\n      query: options.queryParams\n    });\n    this.options = options;\n    this.donePromise = new Promise((resolve, reject) => {\n      if (this.streamClosed) {\n        reject(new response_1.ApiError({\n          message: \"Streaming connection is already closed.\",\n          status: 400,\n          body: undefined\n        }));\n      }\n      this.signal.addEventListener(\"abort\", () => {\n        var _a;\n        resolve((_a = this.currentData) !== null && _a !== void 0 ? _a : {});\n      });\n      this.on(\"done\", data => {\n        this.streamClosed = true;\n        resolve(data);\n      });\n      this.on(\"error\", error => {\n        this.streamClosed = true;\n        reject(error);\n      });\n    });\n    // if a abort signal was passed, sync it with the internal one\n    if (options.signal) {\n      options.signal.addEventListener(\"abort\", () => {\n        this.abortController.abort();\n      });\n    }\n    // start the streaming request\n    this.start().catch(this.handleError);\n  }\n  [Symbol.asyncIterator]() {\n    return __asyncGenerator(this, arguments, function* _a() {\n      let running = true;\n      const stopAsyncIterator = () => running = false;\n      this.on(\"error\", stopAsyncIterator);\n      this.on(\"done\", stopAsyncIterator);\n      while (running || this.buffer.length > 0) {\n        const data = this.buffer.shift();\n        if (data) {\n          yield yield __await(data);\n        }\n        // the short timeout ensures the while loop doesn't block other\n        // frames getting executed concurrently\n        yield __await(new Promise(resolve => setTimeout(resolve, 16)));\n      }\n    });\n  }\n  /**\n   * Gets the `AbortSignal` instance that can be used to listen for abort events.\n   *\n   * **Note:** this signal is internal to the `FalStream` instance. If you pass your\n   * own abort signal, the `FalStream` will listen to it and abort it appropriately.\n   *\n   * @returns the `AbortSignal` instance.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n   */\n  get signal() {\n    return this.abortController.signal;\n  }\n}\nexports.FalStream = FalStream;\nfunction createStreamingClient({\n  config,\n  storage\n}) {\n  return {\n    stream(endpointId, options) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const input = options.input ? yield storage.transformInput(options.input) : undefined;\n        return new FalStream(endpointId, config, Object.assign(Object.assign({}, options), {\n          input: input\n        }));\n      });\n    }\n  };\n}","map":{"version":3,"names":["exports","createStreamingClient","eventsource_parser_1","require","auth_1","request_1","response_1","CONTENT_TYPE_EVENT_STREAM","EVENT_STREAM_TIMEOUT","FalStream","constructor","endpointId","config","options","listeners","Map","buffer","currentData","undefined","lastEventTimestamp","streamClosed","abortController","AbortController","start","__awaiter","input","method","connectionMode","token","getTemporaryAuthToken","fetch","parsedUrl","URL","url","searchParams","set","response","toString","toUpperCase","headers","accept","_a","body","JSON","stringify","signal","handleResponse","dispatchRequest","targetUrl","_b","responseHandler","error","handleError","ok","defaultResponseHandler","emit","ApiError","message","status","isEventStream","get","startsWith","reader","getReader","emitRawChunk","read","then","done","value","decoder","TextDecoder","parser","createParser","event","type","data","parsedData","parse","push","e","timeout","readPartialResponse","Date","now","feed","decode","toFixed","catch","name","aborted","apiError","on","listener","has","donePromise","abort","reason","buildUrl","path","query","queryParams","Promise","resolve","reject","addEventListener","Symbol","asyncIterator","running","stopAsyncIterator","length","shift","__await","setTimeout","storage","stream","transformInput","Object","assign"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/libs/client/src/streaming.ts"],"sourcesContent":["import { createParser } from \"eventsource-parser\";\nimport { getTemporaryAuthToken } from \"./auth\";\nimport { RequiredConfig } from \"./config\";\nimport { buildUrl, dispatchRequest } from \"./request\";\nimport { ApiError, defaultResponseHandler } from \"./response\";\nimport { type StorageClient } from \"./storage\";\nimport { EndpointType, InputType, OutputType } from \"./types/client\";\n\nexport type StreamingConnectionMode = \"client\" | \"server\";\n\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\n\n/**\n * The stream API options. It requires the API input and also\n * offers configuration options.\n */\nexport type StreamOptions<Input> = {\n  /**\n   * The endpoint URL. If not provided, it will be generated from the\n   * `endpointId` and the `queryParams`.\n   */\n  readonly url?: string;\n\n  /**\n   * The API input payload.\n   */\n  readonly input?: Input;\n\n  /**\n   * The query parameters to be sent with the request.\n   */\n  readonly queryParams?: Record<string, string>;\n\n  /**\n   * The maximum time interval in milliseconds between stream chunks. Defaults to 15s.\n   */\n  readonly timeout?: number;\n\n  /**\n   * Whether it should auto-upload File-like types to fal's storage\n   * or not.\n   */\n  readonly autoUpload?: boolean;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: \"get\" | \"post\" | \"put\" | \"delete\" | string;\n\n  /**\n   * The content type the client accepts as response.\n   * By default this is set to `text/event-stream`.\n   */\n  readonly accept?: string;\n\n  /**\n   * The streaming connection mode. This is used to determine\n   * whether the streaming will be done from the browser itself (client)\n   * or through your own server, either when running on NodeJS or when\n   * using a proxy that supports streaming.\n   *\n   * It defaults to `server`. Set to `client` if your server proxy doesn't\n   * support streaming.\n   */\n  readonly connectionMode?: StreamingConnectionMode;\n\n  /**\n   * The signal to abort the request.\n   */\n  readonly signal?: AbortSignal;\n};\n\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n\ntype FalStreamEventType = \"data\" | \"error\" | \"done\";\n\ntype EventHandler<T = any> = (event: T) => void;\n\n/**\n * The class representing a streaming response. With t\n */\nexport class FalStream<Input, Output> {\n  // properties\n  config: RequiredConfig;\n  endpointId: string;\n  url: string;\n  options: StreamOptions<Input>;\n\n  // support for event listeners\n  private listeners: Map<FalStreamEventType, EventHandler[]> = new Map();\n  private buffer: Output[] = [];\n\n  // local state\n  private currentData: Output | undefined = undefined;\n  private lastEventTimestamp = 0;\n  private streamClosed = false;\n  private donePromise: Promise<Output>;\n\n  private abortController = new AbortController();\n\n  constructor(\n    endpointId: string,\n    config: RequiredConfig,\n    options: StreamOptions<Input>,\n  ) {\n    this.endpointId = endpointId;\n    this.config = config;\n    this.url =\n      options.url ??\n      buildUrl(endpointId, {\n        path: \"/stream\",\n        query: options.queryParams,\n      });\n    this.options = options;\n    this.donePromise = new Promise<Output>((resolve, reject) => {\n      if (this.streamClosed) {\n        reject(\n          new ApiError({\n            message: \"Streaming connection is already closed.\",\n            status: 400,\n            body: undefined,\n          }),\n        );\n      }\n      this.signal.addEventListener(\"abort\", () => {\n        resolve(this.currentData ?? ({} as Output));\n      });\n      this.on(\"done\", (data) => {\n        this.streamClosed = true;\n        resolve(data);\n      });\n      this.on(\"error\", (error) => {\n        this.streamClosed = true;\n        reject(error);\n      });\n    });\n    // if a abort signal was passed, sync it with the internal one\n    if (options.signal) {\n      options.signal.addEventListener(\"abort\", () => {\n        this.abortController.abort();\n      });\n    }\n\n    // start the streaming request\n    this.start().catch(this.handleError);\n  }\n\n  private start = async () => {\n    const { endpointId, options } = this;\n    const { input, method = \"post\", connectionMode = \"server\" } = options;\n    try {\n      if (connectionMode === \"client\") {\n        // if we are in the browser, we need to get a temporary token\n        // to authenticate the request\n        const token = await getTemporaryAuthToken(endpointId, this.config);\n        const { fetch } = this.config;\n        const parsedUrl = new URL(this.url);\n        parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n        const response = await fetch(parsedUrl.toString(), {\n          method: method.toUpperCase(),\n          headers: {\n            accept: options.accept ?? CONTENT_TYPE_EVENT_STREAM,\n            \"content-type\": \"application/json\",\n          },\n          body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n          signal: this.abortController.signal,\n        });\n        return await this.handleResponse(response);\n      }\n      return await dispatchRequest({\n        method: method.toUpperCase(),\n        targetUrl: this.url,\n        input,\n        config: this.config,\n        options: {\n          headers: {\n            accept: options.accept ?? CONTENT_TYPE_EVENT_STREAM,\n          },\n          responseHandler: this.handleResponse,\n          signal: this.abortController.signal,\n        },\n      });\n    } catch (error) {\n      this.handleError(error);\n    }\n  };\n\n  private handleResponse = async (response: Response) => {\n    if (!response.ok) {\n      try {\n        // we know the response failed, call the response handler\n        // so the exception gets converted to ApiError correctly\n        await defaultResponseHandler(response);\n      } catch (error) {\n        this.emit(\"error\", error);\n      }\n      return;\n    }\n\n    const body = response.body;\n    if (!body) {\n      this.emit(\n        \"error\",\n        new ApiError({\n          message: \"Response body is empty.\",\n          status: 400,\n          body: undefined,\n        }),\n      );\n      return;\n    }\n\n    const isEventStream = (\n      response.headers.get(\"content-type\") ?? \"\"\n    ).startsWith(CONTENT_TYPE_EVENT_STREAM);\n    // any response that is not a text/event-stream will be handled as a binary stream\n    if (!isEventStream) {\n      const reader = body.getReader();\n      const emitRawChunk = () => {\n        reader.read().then(({ done, value }) => {\n          if (done) {\n            this.emit(\"done\", this.currentData);\n            return;\n          }\n          this.currentData = value as Output;\n          this.emit(\"data\", value);\n          emitRawChunk();\n        });\n      };\n      emitRawChunk();\n      return;\n    }\n\n    const decoder = new TextDecoder(\"utf-8\");\n    const reader = response.body.getReader();\n\n    const parser = createParser((event) => {\n      if (event.type === \"event\") {\n        const data = event.data;\n\n        try {\n          const parsedData = JSON.parse(data);\n          this.buffer.push(parsedData);\n          this.currentData = parsedData;\n          this.emit(\"data\", parsedData);\n\n          // also emit 'message'for backwards compatibility\n          this.emit(\"message\" as any, parsedData);\n        } catch (e) {\n          this.emit(\"error\", e);\n        }\n      }\n    });\n\n    const timeout = this.options.timeout ?? EVENT_STREAM_TIMEOUT;\n\n    const readPartialResponse = async () => {\n      const { value, done } = await reader.read();\n      this.lastEventTimestamp = Date.now();\n\n      parser.feed(decoder.decode(value));\n\n      if (Date.now() - this.lastEventTimestamp > timeout) {\n        this.emit(\n          \"error\",\n          new ApiError({\n            message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n            status: 408,\n          }),\n        );\n      }\n\n      if (!done) {\n        readPartialResponse().catch(this.handleError);\n      } else {\n        this.emit(\"done\", this.currentData);\n      }\n    };\n\n    readPartialResponse().catch(this.handleError);\n    return;\n  };\n\n  private handleError = (error: any) => {\n    // In case AbortError is thrown but the signal is marked as aborted\n    // it means the user called abort() and we should not emit an error\n    // as it's expected behavior\n    // See note on: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\n    if (error.name === \"AbortError\" || this.signal.aborted) {\n      return;\n    }\n    const apiError =\n      error instanceof ApiError\n        ? error\n        : new ApiError({\n            message: error.message ?? \"An unknown error occurred\",\n            status: 500,\n          });\n    this.emit(\"error\", apiError);\n    return;\n  };\n\n  public on = (type: FalStreamEventType, listener: EventHandler) => {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, []);\n    }\n    this.listeners.get(type)?.push(listener);\n  };\n\n  private emit = (type: FalStreamEventType, event: any) => {\n    const listeners = this.listeners.get(type) || [];\n    for (const listener of listeners) {\n      listener(event);\n    }\n  };\n\n  async *[Symbol.asyncIterator]() {\n    let running = true;\n    const stopAsyncIterator = () => (running = false);\n    this.on(\"error\", stopAsyncIterator);\n    this.on(\"done\", stopAsyncIterator);\n    while (running || this.buffer.length > 0) {\n      const data = this.buffer.shift();\n      if (data) {\n        yield data;\n      }\n\n      // the short timeout ensures the while loop doesn't block other\n      // frames getting executed concurrently\n      await new Promise((resolve) => setTimeout(resolve, 16));\n    }\n  }\n\n  /**\n   * Gets a reference to the `Promise` that indicates whether the streaming\n   * is done or not. Developers should always call this in their apps to ensure\n   * the request is over.\n   *\n   * An alternative to this, is to use `on('done')` in case your application\n   * architecture works best with event listeners.\n   *\n   * @returns the promise that resolves when the request is done.\n   */\n  public done = async () => this.donePromise;\n\n  /**\n   * Aborts the streaming request.\n   *\n   * **Note:** This method is noop in case the request is already done.\n   *\n   * @param reason optional cause for aborting the request.\n   */\n  public abort = (reason?: string | Error) => {\n    if (!this.streamClosed) {\n      this.abortController.abort(reason);\n    }\n  };\n\n  /**\n   * Gets the `AbortSignal` instance that can be used to listen for abort events.\n   *\n   * **Note:** this signal is internal to the `FalStream` instance. If you pass your\n   * own abort signal, the `FalStream` will listen to it and abort it appropriately.\n   *\n   * @returns the `AbortSignal` instance.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n   */\n  public get signal() {\n    return this.abortController.signal;\n  }\n}\n\n/**\n * The streaming client interface.\n */\nexport interface StreamingClient {\n  /**\n   * Calls a fal app that supports streaming and provides a streaming-capable\n   * object as a result, that can be used to get partial results through either\n   * `AsyncIterator` or through an event listener.\n   *\n   * @param endpointId the endpoint id, e.g. `fal-ai/llavav15-13b`.\n   * @param options the request options, including the input payload.\n   * @returns the `FalStream` instance.\n   */\n  stream<Id extends EndpointType>(\n    endpointId: Id,\n    options: StreamOptions<InputType<Id>>,\n  ): Promise<FalStream<InputType<Id>, OutputType<Id>>>;\n}\n\ntype StreamingClientDependencies = {\n  config: RequiredConfig;\n  storage: StorageClient;\n};\n\nexport function createStreamingClient({\n  config,\n  storage,\n}: StreamingClientDependencies): StreamingClient {\n  return {\n    async stream<Id extends EndpointType>(\n      endpointId: Id,\n      options: StreamOptions<InputType<Id>>,\n    ) {\n      const input = options.input\n        ? await storage.transformInput(options.input)\n        : undefined;\n      return new FalStream<InputType<Id>, OutputType<Id>>(endpointId, config, {\n        ...options,\n        input: input as InputType<Id>,\n      });\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}