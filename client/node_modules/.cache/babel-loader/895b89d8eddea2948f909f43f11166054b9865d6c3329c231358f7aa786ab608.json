{"ast":null,"code":"/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\nexports.all = function (plugins) {\n  return Object.keys(plugins).filter(key => {\n    return typeof plugins[key] === 'object';\n  }).map(key => {\n    // eslint-disable-next-line no-param-reassign\n    plugins[key].name = key;\n    return plugins[key];\n  });\n};\n\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\nexports.filter = function (plugins, method, file) {\n  return plugins.filter(plugin => {\n    return !!getResult(plugin, method, file);\n  });\n};\n\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\nexports.sort = function (plugins) {\n  for (const plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n  return plugins.sort((a, b) => {\n    return a.order - b.order;\n  });\n};\n\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\nexports.run = function (plugins, method, file, $refs) {\n  let plugin;\n  let lastError;\n  let index = 0;\n  return new Promise((resolve, reject) => {\n    runNextPlugin();\n    function runNextPlugin() {\n      plugin = plugins[index++];\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n      try {\n        // console.log('  %s', plugin.name);\n        const result = getResult(plugin, method, file, callback, $refs);\n        if (result && typeof result.then === 'function') {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        } else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        } else if (index === plugins.length) {\n          throw new Error('No promise has been returned or callback has been called.');\n        }\n      } catch (e) {\n        onError(e);\n      }\n    }\n    function callback(err, result) {\n      if (err) {\n        onError(err);\n      } else {\n        onSuccess(result);\n      }\n    }\n    function onSuccess(result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result\n      });\n    }\n    function onError(error) {\n      // console.log('    %s', err.message || err);\n      lastError = {\n        plugin,\n        error\n      };\n      runNextPlugin();\n    }\n  });\n};\n\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\nfunction getResult(obj, prop, file, callback, $refs) {\n  const value = obj[prop];\n  if (typeof value === 'function') {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    } else if (typeof value === 'string') {\n      return value === file.extension;\n    } else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n  return value;\n}","map":{"version":3,"names":["exports","all","plugins","Object","keys","filter","key","map","name","method","file","plugin","getResult","sort","order","Number","MAX_SAFE_INTEGER","a","b","run","$refs","lastError","index","Promise","resolve","reject","runNextPlugin","result","callback","then","onSuccess","onError","undefined","length","Error","e","err","error","obj","prop","value","apply","RegExp","test","url","extension","Array","isArray","indexOf"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/util/plugins.js"],"sourcesContent":["/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @param  {object} plugins - A map of plugin objects\n * @return {object[]}\n */\nexports.all = function (plugins) {\n  return Object.keys(plugins)\n    .filter(key => {\n      return typeof plugins[key] === 'object';\n    })\n    .map(key => {\n      // eslint-disable-next-line no-param-reassign\n      plugins[key].name = key;\n      return plugins[key];\n    });\n};\n\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n *\n * @param  {object[]} plugins - An array of plugin objects\n * @param  {string}   method  - The name of the filter method to invoke for each plugin\n * @param  {object}   file    - A file info object, which will be passed to each method\n * @return {object[]}\n */\nexports.filter = function (plugins, method, file) {\n  return plugins.filter(plugin => {\n    return !!getResult(plugin, method, file);\n  });\n};\n\n/**\n * Sorts the given plugins, in place, by their `order` property.\n *\n * @param {object[]} plugins - An array of plugin objects\n * @returns {object[]}\n */\nexports.sort = function (plugins) {\n  for (const plugin of plugins) {\n    plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a, b) => {\n    return a.order - b.order;\n  });\n};\n\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n *\n * @param {object[]}  plugins - An array of plugin objects\n * @param {string}    method  - The name of the method to invoke for each plugin\n * @param {object}    file    - A file info object, which will be passed to each method\n * @returns {Promise}\n */\nexports.run = function (plugins, method, file, $refs) {\n  let plugin;\n  let lastError;\n  let index = 0;\n\n  return new Promise((resolve, reject) => {\n    runNextPlugin();\n\n    function runNextPlugin() {\n      plugin = plugins[index++];\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log('  %s', plugin.name);\n        const result = getResult(plugin, method, file, callback, $refs);\n        if (result && typeof result.then === 'function') {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        } else if (result !== undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        } else if (index === plugins.length) {\n          throw new Error('No promise has been returned or callback has been called.');\n        }\n      } catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback(err, result) {\n      if (err) {\n        onError(err);\n      } else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess(result) {\n      // console.log('    success');\n      resolve({\n        plugin,\n        result,\n      });\n    }\n\n    function onError(error) {\n      // console.log('    %s', err.message || err);\n      lastError = {\n        plugin,\n        error,\n      };\n      runNextPlugin();\n    }\n  });\n};\n\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an aray, then it will be compared against the file extension.\n *\n * @param   {object}   obj        - The object whose property/method is called\n * @param   {string}   prop       - The name of the property/method to invoke\n * @param   {object}   file       - A file info object, which will be passed to the method\n * @param   {function} [callback] - A callback function, which will be passed to the method\n * @returns {*}\n */\nfunction getResult(obj, prop, file, callback, $refs) {\n  const value = obj[prop];\n\n  if (typeof value === 'function') {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    } else if (typeof value === 'string') {\n      return value === file.extension;\n    } else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !== -1;\n    }\n  }\n\n  return value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}