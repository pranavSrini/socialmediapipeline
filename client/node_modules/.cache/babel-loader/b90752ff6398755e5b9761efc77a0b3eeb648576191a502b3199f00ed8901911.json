{"ast":null,"code":"import { utf8Count, utf8Encode } from \"./utils/utf8.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { setInt64, setUint64 } from \"./utils/int.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nexport class Encoder {\n  constructor(options) {\n    this.entered = false;\n    this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;\n    this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n  clone() {\n    // Because of slightly special argument `context`,\n    // type assertion is needed.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Encoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      maxDepth: this.maxDepth,\n      initialBufferSize: this.initialBufferSize,\n      sortKeys: this.sortKeys,\n      forceFloat32: this.forceFloat32,\n      ignoreUndefined: this.ignoreUndefined,\n      forceIntegerToFloat: this.forceIntegerToFloat\n    });\n  }\n  reinitializeState() {\n    this.pos = 0;\n  }\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  encodeSharedRef(object) {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encodeSharedRef(object);\n    }\n    try {\n      this.entered = true;\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.subarray(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  encode(object) {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encode(object);\n    }\n    try {\n      this.entered = true;\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.slice(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n  doEncode(object, depth) {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      if (!this.forceIntegerToFloat) {\n        this.encodeNumber(object);\n      } else {\n        this.encodeNumberAsFloat(object);\n      }\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\n      this.encodeBigInt64(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n  ensureBufferSizeToWrite(sizeToWrite) {\n    const requiredSize = this.pos + sizeToWrite;\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n  resizeBuffer(newSize) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n    newBytes.set(this.bytes);\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n  encodeNil() {\n    this.writeU8(0xc0);\n  }\n  encodeBoolean(object) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n  encodeNumber(object) {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else if (!this.useBigInt64) {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | object + 0x20);\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else if (!this.useBigInt64) {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n  encodeNumberAsFloat(object) {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n  encodeBigInt64(object) {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n  writeStringHeader(byteLength) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n  encodeString(object) {\n    const maxHeaderSize = 1 + 4;\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n  encodeObject(object, depth) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n  encodeBinary(object) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n  encodeArray(object, depth) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n  countWithoutUndefined(object, keys) {\n    let count = 0;\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n    return count;\n  }\n  encodeMap(object, depth) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n    for (const key of keys) {\n      const value = object[key];\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n  encodeExtension(ext) {\n    if (typeof ext.data === \"function\") {\n      const data = ext.data(this.pos + 6);\n      const size = data.length;\n      if (size >= 0x100000000) {\n        throw new Error(`Too large extension object: ${size}`);\n      }\n      this.writeU8(0xc9);\n      this.writeU32(size);\n      this.writeI8(ext.type);\n      this.writeU8a(data);\n      return;\n    }\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n  writeU8(value) {\n    this.ensureBufferSizeToWrite(1);\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n  writeU8a(values) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n  writeI8(value) {\n    this.ensureBufferSizeToWrite(1);\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n  writeU16(value) {\n    this.ensureBufferSizeToWrite(2);\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n  writeI16(value) {\n    this.ensureBufferSizeToWrite(2);\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n  writeU32(value) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n  writeI32(value) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n  writeF32(value) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n  writeF64(value) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n  writeU64(value) {\n    this.ensureBufferSizeToWrite(8);\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n  writeI64(value) {\n    this.ensureBufferSizeToWrite(8);\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n  writeBigUint64(value) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n  writeBigInt64(value) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}","map":{"version":3,"names":["utf8Count","utf8Encode","ExtensionCodec","setInt64","setUint64","ensureUint8Array","DEFAULT_MAX_DEPTH","DEFAULT_INITIAL_BUFFER_SIZE","Encoder","constructor","options","entered","extensionCodec","defaultCodec","context","useBigInt64","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","pos","view","DataView","ArrayBuffer","bytes","Uint8Array","buffer","clone","reinitializeState","encodeSharedRef","object","instance","doEncode","subarray","encode","slice","depth","Error","encodeNil","encodeBoolean","encodeNumber","encodeNumberAsFloat","encodeString","encodeBigInt64","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","byteLength","resizeBuffer","newSize","newBuffer","newBytes","newView","set","writeU8","Number","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","BigInt","writeBigUint64","writeBigInt64","writeStringHeader","maxHeaderSize","ext","tryToEncode","encodeExtension","Array","isArray","encodeArray","isView","encodeBinary","encodeMap","Object","prototype","toString","apply","size","writeU8a","length","item","countWithoutUndefined","keys","count","key","undefined","sort","value","data","type","setUint8","values","setInt8","setUint16","setInt16","setUint32","setInt32","setFloat32","setFloat64","setBigUint64","setBigInt64"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/node_modules/@msgpack/msgpack/src/Encoder.ts"],"sourcesContent":["import { utf8Count, utf8Encode } from \"./utils/utf8.ts\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec.ts\";\nimport { setInt64, setUint64 } from \"./utils/int.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport type { ExtData } from \"./ExtData.ts\";\nimport type { ContextOf } from \"./context.ts\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport type EncoderOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Encodes bigint as Int64 or Uint64 if it's set to true.\n     * {@link forceIntegerToFloat} does not affect bigint.\n     * Depends on ES2020's {@link DataView#setBigInt64} and\n     * {@link DataView#setBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport class Encoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly maxDepth: number;\n  private readonly initialBufferSize: number;\n  private readonly sortKeys: boolean;\n  private readonly forceFloat32: boolean;\n  private readonly ignoreUndefined: boolean;\n  private readonly forceIntegerToFloat: boolean;\n\n  private pos: number;\n  private view: DataView;\n  private bytes: Uint8Array;\n\n  private entered = false;\n\n  public constructor(options?: EncoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n\n  private clone() {\n    // Because of slightly special argument `context`,\n    // type assertion is needed.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Encoder<ContextType>({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      maxDepth: this.maxDepth,\n      initialBufferSize: this.initialBufferSize,\n      sortKeys: this.sortKeys,\n      forceFloat32: this.forceFloat32,\n      ignoreUndefined: this.ignoreUndefined,\n      forceIntegerToFloat: this.forceIntegerToFloat,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encodeSharedRef(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.subarray(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encode(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.slice(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      if (!this.forceIntegerToFloat) {\n        this.encodeNumber(object);\n      } else {\n        this.encodeNumberAsFloat(object);\n      }\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\n      this.encodeBigInt64(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number): void {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else if (!this.useBigInt64) {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else if (!this.useBigInt64) {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n\n  private encodeNumberAsFloat(object: number): void {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n\n  private encodeBigInt64(object: bigint): void {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    if (typeof ext.data === \"function\") {\n      const data = ext.data(this.pos + 6);\n      const size = data.length;\n\n      if (size >= 0x100000000) {\n        throw new Error(`Too large extension object: ${size}`);\n      }\n\n      this.writeU8(0xc9);\n      this.writeU32(size);\n      this.writeI8(ext.type);\n      this.writeU8a(data);\n      return;\n    }\n\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigUint64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigInt64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}