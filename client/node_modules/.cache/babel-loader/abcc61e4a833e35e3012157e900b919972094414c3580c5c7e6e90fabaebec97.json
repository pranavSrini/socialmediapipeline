{"ast":null,"code":"/* eslint-disable prefer-spread */\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst maybe = require('call-me-maybe');\nconst _bundle = require('./bundle');\nconst _dereference = require('./dereference');\nconst normalizeArgs = require('./normalize-args');\nconst _parse = require('./parse');\nconst $Refs = require('./refs');\nconst resolveExternal = require('./resolve-external');\nconst {\n  JSONParserError,\n  InvalidPointerError,\n  MissingPointerError,\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError,\n  JSONParserErrorGroup\n} = require('./util/errors');\nconst url = require('./util/url');\nmodule.exports = $RefParser;\nmodule.exports.default = $RefParser;\nmodule.exports.JSONParserError = JSONParserError;\nmodule.exports.InvalidPointerError = InvalidPointerError;\nmodule.exports.MissingPointerError = MissingPointerError;\nmodule.exports.ResolverError = ResolverError;\nmodule.exports.ParserError = ParserError;\nmodule.exports.UnmatchedParserError = UnmatchedParserError;\nmodule.exports.UnmatchedResolverError = UnmatchedResolverError;\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\nfunction $RefParser() {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  this.$refs = new $Refs();\n}\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.parse = function parse(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.prototype.parse = async function parse(path, schema, options, callback) {\n  const args = normalizeArgs(arguments);\n  let promise;\n  if (!args.path && !args.schema) {\n    const err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  }\n\n  // Reset everything\n  this.schema = null;\n  this.$refs = new $Refs();\n\n  // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n  let pathType = 'http';\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = 'file';\n  }\n\n  // Resolve the absolute path of the schema\n  args.path = url.resolve(url.cwd(), args.path);\n  if (args.schema && typeof args.schema === 'object') {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    const $ref = this.$refs._add(args.path);\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  } else {\n    // Parse the schema file/url\n    promise = _parse(args.path, this.$refs, args.options);\n  }\n  const me = this;\n  try {\n    const result = await promise;\n    if (result !== null && typeof result === 'object' && !Buffer.isBuffer(result)) {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    } else if (args.options.continueOnError) {\n      me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n    throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n  } catch (err) {\n    if (!args.options.continueOnError || !isHandledError(err)) {\n      return maybe(args.callback, Promise.reject(err));\n    }\n    if (this.$refs._$refs[url.stripHash(args.path)]) {\n      this.$refs._$refs[url.stripHash(args.path)].addError(err);\n    }\n    return maybe(args.callback, Promise.resolve(null));\n  }\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.resolve = function resolve(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.bundle = function bundle(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    _bundle(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.dereference = function dereference(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    _dereference(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\nfunction finalize(parser) {\n  const errors = JSONParserErrorGroup.getParserErrors(parser);\n  if (errors.length > 0) {\n    throw new JSONParserErrorGroup(parser);\n  }\n}","map":{"version":3,"names":["ono","require","maybe","_bundle","_dereference","normalizeArgs","_parse","$Refs","resolveExternal","JSONParserError","InvalidPointerError","MissingPointerError","ResolverError","ParserError","UnmatchedParserError","UnmatchedResolverError","isHandledError","JSONParserErrorGroup","url","module","exports","$RefParser","default","schema","$refs","parse","path","options","callback","Class","instance","apply","arguments","prototype","args","promise","err","Promise","reject","pathType","isFileSystemPath","fromFileSystemPath","resolve","cwd","$ref","_add","value","me","result","Buffer","isBuffer","continueOnError","syntax","_root$Ref","_$refs","stripHash","addError","finalize","bundle","dereference","parser","errors","getParserErrors","length"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/index.js"],"sourcesContent":["/* eslint-disable prefer-spread */\nconst { ono } = require('@jsdevtools/ono');\nconst maybe = require('call-me-maybe');\n\nconst _bundle = require('./bundle');\nconst _dereference = require('./dereference');\nconst normalizeArgs = require('./normalize-args');\nconst _parse = require('./parse');\nconst $Refs = require('./refs');\nconst resolveExternal = require('./resolve-external');\nconst {\n  JSONParserError,\n  InvalidPointerError,\n  MissingPointerError,\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError,\n  JSONParserErrorGroup,\n} = require('./util/errors');\nconst url = require('./util/url');\n\nmodule.exports = $RefParser;\nmodule.exports.default = $RefParser;\nmodule.exports.JSONParserError = JSONParserError;\nmodule.exports.InvalidPointerError = InvalidPointerError;\nmodule.exports.MissingPointerError = MissingPointerError;\nmodule.exports.ResolverError = ResolverError;\nmodule.exports.ParserError = ParserError;\nmodule.exports.UnmatchedParserError = UnmatchedParserError;\nmodule.exports.UnmatchedResolverError = UnmatchedResolverError;\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\nfunction $RefParser() {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  this.$refs = new $Refs();\n}\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.parse = function parse(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.prototype.parse = async function parse(path, schema, options, callback) {\n  const args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    const err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  }\n\n  // Reset everything\n  this.schema = null;\n  this.$refs = new $Refs();\n\n  // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n  let pathType = 'http';\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = 'file';\n  }\n\n  // Resolve the absolute path of the schema\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === 'object') {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    const $ref = this.$refs._add(args.path);\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  } else {\n    // Parse the schema file/url\n    promise = _parse(args.path, this.$refs, args.options);\n  }\n\n  const me = this;\n  try {\n    const result = await promise;\n\n    if (result !== null && typeof result === 'object' && !Buffer.isBuffer(result)) {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    } else if (args.options.continueOnError) {\n      me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n\n    throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n  } catch (err) {\n    if (!args.options.continueOnError || !isHandledError(err)) {\n      return maybe(args.callback, Promise.reject(err));\n    }\n\n    if (this.$refs._$refs[url.stripHash(args.path)]) {\n      this.$refs._$refs[url.stripHash(args.path)].addError(err);\n    }\n\n    return maybe(args.callback, Promise.resolve(null));\n  }\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.resolve = function resolve(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.bundle = function bundle(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    _bundle(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.dereference = function dereference(path, schema, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    _dereference(me, args.options);\n    finalize(me);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\nfunction finalize(parser) {\n  const errors = JSONParserErrorGroup.getParserErrors(parser);\n  if (errors.length > 0) {\n    throw new JSONParserErrorGroup(parser);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}