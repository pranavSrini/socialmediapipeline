{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createQueueClient = void 0;\nconst request_1 = require(\"./request\");\nconst response_1 = require(\"./response\");\nconst streaming_1 = require(\"./streaming\");\nconst utils_1 = require(\"./utils\");\nconst DEFAULT_POLL_INTERVAL = 500;\nconst createQueueClient = ({\n  config,\n  storage\n}) => {\n  const ref = {\n    submit(endpointId, options) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n            webhookUrl,\n            priority\n          } = options,\n          runOptions = __rest(options, [\"webhookUrl\", \"priority\"]);\n        const input = options.input ? yield storage.transformInput(options.input) : undefined;\n        return (0, request_1.dispatchRequest)({\n          method: options.method,\n          targetUrl: (0, request_1.buildUrl)(endpointId, Object.assign(Object.assign({}, runOptions), {\n            subdomain: \"queue\",\n            query: webhookUrl ? {\n              fal_webhook: webhookUrl\n            } : undefined\n          })),\n          headers: {\n            \"x-fal-queue-priority\": priority !== null && priority !== void 0 ? priority : \"normal\"\n          },\n          input: input,\n          config,\n          options: {\n            signal: options.abortSignal\n          }\n        });\n      });\n    },\n    status(endpointId_1, _a) {\n      return __awaiter(this, arguments, void 0, function* (endpointId, {\n        requestId,\n        logs = false,\n        abortSignal\n      }) {\n        const appId = (0, utils_1.parseEndpointId)(endpointId);\n        const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n        return (0, request_1.dispatchRequest)({\n          method: \"get\",\n          targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n            subdomain: \"queue\",\n            query: {\n              logs: logs ? \"1\" : \"0\"\n            },\n            path: `/requests/${requestId}/status`\n          }),\n          config,\n          options: {\n            signal: abortSignal\n          }\n        });\n      });\n    },\n    streamStatus(endpointId_1, _a) {\n      return __awaiter(this, arguments, void 0, function* (endpointId, {\n        requestId,\n        logs = false,\n        connectionMode\n      }) {\n        const appId = (0, utils_1.parseEndpointId)(endpointId);\n        const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n        const queryParams = {\n          logs: logs ? \"1\" : \"0\"\n        };\n        const url = (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          path: `/requests/${requestId}/status/stream`,\n          query: queryParams\n        });\n        return new streaming_1.FalStream(endpointId, config, {\n          url,\n          method: \"get\",\n          connectionMode,\n          queryParams\n        });\n      });\n    },\n    subscribeToStatus(endpointId, options) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const requestId = options.requestId;\n        const timeout = options.timeout;\n        let timeoutId = undefined;\n        const handleCancelError = () => {\n          // Ignore errors as the client will follow through with the timeout\n          // regardless of the server response. In case cancelation fails, we\n          // still want to reject the promise and consider the client call canceled.\n        };\n        if (options.mode === \"streaming\") {\n          const status = yield ref.streamStatus(endpointId, {\n            requestId,\n            logs: options.logs,\n            connectionMode: \"connectionMode\" in options ? options.connectionMode : undefined\n          });\n          const logs = [];\n          if (timeout) {\n            timeoutId = setTimeout(() => {\n              status.abort();\n              ref.cancel(endpointId, {\n                requestId\n              }).catch(handleCancelError);\n              // TODO this error cannot bubble up to the user since it's thrown in\n              // a closure in the global scope due to setTimeout behavior.\n              // User will get a platform error instead. We should find a way to\n              // make this behavior aligned with polling.\n              throw new Error(`Client timed out waiting for the request to complete after ${timeout}ms`);\n            }, timeout);\n          }\n          status.on(\"data\", data => {\n            if (options.onQueueUpdate) {\n              // accumulate logs to match previous polling behavior\n              if (\"logs\" in data && Array.isArray(data.logs) && data.logs.length > 0) {\n                logs.push(...data.logs);\n              }\n              options.onQueueUpdate(\"logs\" in data ? Object.assign(Object.assign({}, data), {\n                logs\n              }) : data);\n            }\n          });\n          const doneStatus = yield status.done();\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          return doneStatus;\n        }\n        // default to polling until status streaming is stable and faster\n        return new Promise((resolve, reject) => {\n          var _a;\n          let pollingTimeoutId;\n          // type resolution isn't great in this case, so check for its presence\n          // and and type so the typechecker behaves as expected\n          const pollInterval = \"pollInterval\" in options && typeof options.pollInterval === \"number\" ? (_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL : DEFAULT_POLL_INTERVAL;\n          const clearScheduledTasks = () => {\n            if (timeoutId) {\n              clearTimeout(timeoutId);\n            }\n            if (pollingTimeoutId) {\n              clearTimeout(pollingTimeoutId);\n            }\n          };\n          if (timeout) {\n            timeoutId = setTimeout(() => {\n              clearScheduledTasks();\n              ref.cancel(endpointId, {\n                requestId\n              }).catch(handleCancelError);\n              reject(new Error(`Client timed out waiting for the request to complete after ${timeout}ms`));\n            }, timeout);\n          }\n          const poll = () => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            try {\n              const requestStatus = yield ref.status(endpointId, {\n                requestId,\n                logs: (_a = options.logs) !== null && _a !== void 0 ? _a : false,\n                abortSignal: options.abortSignal\n              });\n              if (options.onQueueUpdate) {\n                options.onQueueUpdate(requestStatus);\n              }\n              if (requestStatus.status === \"COMPLETED\") {\n                clearScheduledTasks();\n                resolve(requestStatus);\n                return;\n              }\n              pollingTimeoutId = setTimeout(poll, pollInterval);\n            } catch (error) {\n              clearScheduledTasks();\n              reject(error);\n            }\n          });\n          poll().catch(reject);\n        });\n      });\n    },\n    result(endpointId_1, _a) {\n      return __awaiter(this, arguments, void 0, function* (endpointId, {\n        requestId,\n        abortSignal\n      }) {\n        const appId = (0, utils_1.parseEndpointId)(endpointId);\n        const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n        return (0, request_1.dispatchRequest)({\n          method: \"get\",\n          targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n            subdomain: \"queue\",\n            path: `/requests/${requestId}`\n          }),\n          config: Object.assign(Object.assign({}, config), {\n            responseHandler: response_1.resultResponseHandler\n          }),\n          options: {\n            signal: abortSignal\n          }\n        });\n      });\n    },\n    cancel(endpointId_1, _a) {\n      return __awaiter(this, arguments, void 0, function* (endpointId, {\n        requestId,\n        abortSignal\n      }) {\n        const appId = (0, utils_1.parseEndpointId)(endpointId);\n        const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n        yield (0, request_1.dispatchRequest)({\n          method: \"put\",\n          targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n            subdomain: \"queue\",\n            path: `/requests/${requestId}/cancel`\n          }),\n          config,\n          options: {\n            signal: abortSignal\n          }\n        });\n      });\n    }\n  };\n  return ref;\n};\nexports.createQueueClient = createQueueClient;","map":{"version":3,"names":["request_1","require","response_1","streaming_1","utils_1","DEFAULT_POLL_INTERVAL","createQueueClient","config","storage","ref","submit","endpointId","options","webhookUrl","priority","runOptions","__rest","input","transformInput","undefined","dispatchRequest","method","targetUrl","buildUrl","Object","assign","subdomain","query","fal_webhook","headers","signal","abortSignal","status","endpointId_1","_a","requestId","logs","appId","parseEndpointId","prefix","namespace","owner","alias","path","streamStatus","connectionMode","queryParams","url","FalStream","subscribeToStatus","timeout","timeoutId","handleCancelError","mode","setTimeout","abort","cancel","catch","Error","on","data","onQueueUpdate","Array","isArray","length","push","doneStatus","done","clearTimeout","Promise","resolve","reject","pollingTimeoutId","pollInterval","clearScheduledTasks","poll","__awaiter","requestStatus","error","result","responseHandler","resultResponseHandler","exports"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/libs/client/src/queue.ts"],"sourcesContent":["import { RequiredConfig } from \"./config\";\nimport { buildUrl, dispatchRequest } from \"./request\";\nimport { resultResponseHandler } from \"./response\";\nimport { StorageClient } from \"./storage\";\nimport { FalStream, StreamingConnectionMode } from \"./streaming\";\nimport { EndpointType, InputType, OutputType } from \"./types/client\";\nimport {\n  CompletedQueueStatus,\n  InQueueQueueStatus,\n  QueueStatus,\n  RequestLog,\n  Result,\n  RunOptions,\n} from \"./types/common\";\nimport { parseEndpointId } from \"./utils\";\n\nexport type QueuePriority = \"low\" | \"normal\";\nexport type QueueStatusSubscriptionOptions = QueueStatusOptions &\n  Omit<QueueSubscribeOptions, \"onEnqueue\" | \"webhookUrl\">;\n\ntype TimeoutId = ReturnType<typeof setTimeout> | undefined;\n\nconst DEFAULT_POLL_INTERVAL = 500;\n\n/**\n * Options for subscribing to the request queue.\n */\nexport type QueueSubscribeOptions = {\n  /**\n   * The mode to use for subscribing to updates. It defaults to `polling`.\n   * You can also use client-side streaming by setting it to `streaming`.\n   *\n   * **Note:** Streaming is currently experimental and once stable, it will\n   * be the default mode.\n   *\n   * @see pollInterval\n   */\n  mode?: \"polling\" | \"streaming\";\n\n  /**\n   * Callback function that is called when a request is enqueued.\n   * @param requestId - The unique identifier for the enqueued request.\n   */\n  onEnqueue?: (requestId: string) => void;\n\n  /**\n   * Callback function that is called when the status of the queue changes.\n   * @param status - The current status of the queue.\n   */\n  onQueueUpdate?: (status: QueueStatus) => void;\n\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n\n  /**\n   * The timeout (in milliseconds) for the request. If the request is not\n   * completed within this time, the subscription will be cancelled.\n   *\n   * Keep in mind that although the client resolves the function on a timeout,\n   * and will try to cancel the request on the server, the server might not be\n   * able to cancel the request if it's already running.\n   *\n   * Note: currently, the timeout is not enforced and the default is `undefined`.\n   * This behavior might change in the future.\n   */\n  timeout?: number;\n\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n\n  /**\n   * The priority of the request. It defaults to `normal`.\n   * @see QueuePriority\n   */\n  priority?: QueuePriority;\n} & (\n  | {\n      mode?: \"polling\";\n      /**\n       * The interval (in milliseconds) at which to poll for updates.\n       * If not provided, a default value of `500` will be used.\n       *\n       * This value is ignored if `mode` is set to `streaming`.\n       */\n      pollInterval?: number;\n    }\n  | {\n      mode: \"streaming\";\n\n      /**\n       * The connection mode to use for streaming updates. It defaults to `server`.\n       * Set to `client` if your server proxy doesn't support streaming.\n       */\n      connectionMode?: StreamingConnectionMode;\n    }\n);\n\n/**\n * Options for submitting a request to the queue.\n */\nexport type SubmitOptions<Input> = RunOptions<Input> & {\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n\n  /**\n   * The priority of the request. It defaults to `normal`.\n   * @see QueuePriority\n   */\n  priority?: QueuePriority;\n};\n\ntype BaseQueueOptions = {\n  /**\n   * The unique identifier for the enqueued request.\n   */\n  requestId: string;\n\n  /**\n   * The signal to abort the request.\n   */\n  abortSignal?: AbortSignal;\n};\n\nexport type QueueStatusOptions = BaseQueueOptions & {\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n};\n\nexport type QueueStatusStreamOptions = QueueStatusOptions & {\n  /**\n   * The connection mode to use for streaming updates. It defaults to `server`.\n   * Set to `client` if your server proxy doesn't support streaming.\n   */\n  connectionMode?: StreamingConnectionMode;\n};\n\n/**\n * Represents a request queue with methods for submitting requests,\n * checking their status, retrieving results, and subscribing to updates.\n */\nexport interface QueueClient {\n  /**\n   * Submits a request to the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of enqueuing the request.\n   */\n  submit<Id extends EndpointType>(\n    endpointId: Id,\n    options: SubmitOptions<InputType<Id>>,\n  ): Promise<InQueueQueueStatus>;\n\n  /**\n   * Retrieves the status of a specific request in the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the status of the request.\n   */\n  status(endpointId: string, options: QueueStatusOptions): Promise<QueueStatus>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue using HTTP streaming events.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns The streaming object that can be used to listen for updates.\n   */\n  streamStatus(\n    endpointId: string,\n    options: QueueStatusStreamOptions,\n  ): Promise<FalStream<unknown, QueueStatus>>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue using polling or streaming.\n   * See `options.mode` for more details.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns A promise that resolves to the final status of the request.\n   */\n  subscribeToStatus(\n    endpointId: string,\n    options: QueueStatusSubscriptionOptions,\n  ): Promise<CompletedQueueStatus>;\n\n  /**\n   * Retrieves the result of a specific request from the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of the request.\n   */\n  result<Id extends EndpointType>(\n    endpointId: Id,\n    options: BaseQueueOptions,\n  ): Promise<Result<OutputType<Id>>>;\n\n  /**\n   * Cancels a request in the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request\n   * is run and how updates are received.\n   * @returns A promise that resolves once the request is cancelled.\n   * @throws {Error} If the request cannot be cancelled.\n   */\n  cancel(endpointId: string, options: BaseQueueOptions): Promise<void>;\n}\n\ntype QueueClientDependencies = {\n  config: RequiredConfig;\n  storage: StorageClient;\n};\n\nexport const createQueueClient = ({\n  config,\n  storage,\n}: QueueClientDependencies): QueueClient => {\n  const ref: QueueClient = {\n    async submit<Input>(\n      endpointId: string,\n      options: SubmitOptions<Input>,\n    ): Promise<InQueueQueueStatus> {\n      const { webhookUrl, priority, ...runOptions } = options;\n      const input = options.input\n        ? await storage.transformInput(options.input)\n        : undefined;\n      return dispatchRequest<Input, InQueueQueueStatus>({\n        method: options.method,\n        targetUrl: buildUrl(endpointId, {\n          ...runOptions,\n          subdomain: \"queue\",\n          query: webhookUrl ? { fal_webhook: webhookUrl } : undefined,\n        }),\n        headers: {\n          \"x-fal-queue-priority\": priority ?? \"normal\",\n        },\n        input: input as Input,\n        config,\n        options: {\n          signal: options.abortSignal,\n        },\n      });\n    },\n    async status(\n      endpointId: string,\n      { requestId, logs = false, abortSignal }: QueueStatusOptions,\n    ): Promise<QueueStatus> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n      return dispatchRequest<unknown, QueueStatus>({\n        method: \"get\",\n        targetUrl: buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          query: { logs: logs ? \"1\" : \"0\" },\n          path: `/requests/${requestId}/status`,\n        }),\n        config,\n        options: {\n          signal: abortSignal,\n        },\n      });\n    },\n\n    async streamStatus(\n      endpointId: string,\n      { requestId, logs = false, connectionMode }: QueueStatusStreamOptions,\n    ): Promise<FalStream<unknown, QueueStatus>> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n\n      const queryParams = {\n        logs: logs ? \"1\" : \"0\",\n      };\n\n      const url = buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n        subdomain: \"queue\",\n        path: `/requests/${requestId}/status/stream`,\n        query: queryParams,\n      });\n\n      return new FalStream<unknown, QueueStatus>(endpointId, config, {\n        url,\n        method: \"get\",\n        connectionMode,\n        queryParams,\n      });\n    },\n\n    async subscribeToStatus(\n      endpointId,\n      options,\n    ): Promise<CompletedQueueStatus> {\n      const requestId = options.requestId;\n      const timeout = options.timeout;\n      let timeoutId: TimeoutId = undefined;\n\n      const handleCancelError = () => {\n        // Ignore errors as the client will follow through with the timeout\n        // regardless of the server response. In case cancelation fails, we\n        // still want to reject the promise and consider the client call canceled.\n      };\n      if (options.mode === \"streaming\") {\n        const status = await ref.streamStatus(endpointId, {\n          requestId,\n          logs: options.logs,\n          connectionMode:\n            \"connectionMode\" in options\n              ? (options.connectionMode as StreamingConnectionMode)\n              : undefined,\n        });\n        const logs: RequestLog[] = [];\n        if (timeout) {\n          timeoutId = setTimeout(() => {\n            status.abort();\n            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n            // TODO this error cannot bubble up to the user since it's thrown in\n            // a closure in the global scope due to setTimeout behavior.\n            // User will get a platform error instead. We should find a way to\n            // make this behavior aligned with polling.\n            throw new Error(\n              `Client timed out waiting for the request to complete after ${timeout}ms`,\n            );\n          }, timeout);\n        }\n        status.on(\"data\", (data: QueueStatus) => {\n          if (options.onQueueUpdate) {\n            // accumulate logs to match previous polling behavior\n            if (\n              \"logs\" in data &&\n              Array.isArray(data.logs) &&\n              data.logs.length > 0\n            ) {\n              logs.push(...data.logs);\n            }\n            options.onQueueUpdate(\"logs\" in data ? { ...data, logs } : data);\n          }\n        });\n        const doneStatus = await status.done();\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        return doneStatus as CompletedQueueStatus;\n      }\n      // default to polling until status streaming is stable and faster\n      return new Promise<CompletedQueueStatus>((resolve, reject) => {\n        let pollingTimeoutId: TimeoutId;\n        // type resolution isn't great in this case, so check for its presence\n        // and and type so the typechecker behaves as expected\n        const pollInterval =\n          \"pollInterval\" in options && typeof options.pollInterval === \"number\"\n            ? (options.pollInterval ?? DEFAULT_POLL_INTERVAL)\n            : DEFAULT_POLL_INTERVAL;\n\n        const clearScheduledTasks = () => {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          if (pollingTimeoutId) {\n            clearTimeout(pollingTimeoutId);\n          }\n        };\n        if (timeout) {\n          timeoutId = setTimeout(() => {\n            clearScheduledTasks();\n            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n            reject(\n              new Error(\n                `Client timed out waiting for the request to complete after ${timeout}ms`,\n              ),\n            );\n          }, timeout);\n        }\n        const poll = async () => {\n          try {\n            const requestStatus = await ref.status(endpointId, {\n              requestId,\n              logs: options.logs ?? false,\n              abortSignal: options.abortSignal,\n            });\n            if (options.onQueueUpdate) {\n              options.onQueueUpdate(requestStatus);\n            }\n            if (requestStatus.status === \"COMPLETED\") {\n              clearScheduledTasks();\n              resolve(requestStatus);\n              return;\n            }\n            pollingTimeoutId = setTimeout(poll, pollInterval);\n          } catch (error) {\n            clearScheduledTasks();\n            reject(error);\n          }\n        };\n        poll().catch(reject);\n      });\n    },\n\n    async result<Output>(\n      endpointId: string,\n      { requestId, abortSignal }: BaseQueueOptions,\n    ): Promise<Result<Output>> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n      return dispatchRequest<unknown, Result<Output>>({\n        method: \"get\",\n        targetUrl: buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          path: `/requests/${requestId}`,\n        }),\n        config: {\n          ...config,\n          responseHandler: resultResponseHandler,\n        },\n        options: {\n          signal: abortSignal,\n        },\n      });\n    },\n\n    async cancel(\n      endpointId: string,\n      { requestId, abortSignal }: BaseQueueOptions,\n    ): Promise<void> {\n      const appId = parseEndpointId(endpointId);\n      const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n      await dispatchRequest<unknown, void>({\n        method: \"put\",\n        targetUrl: buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n          subdomain: \"queue\",\n          path: `/requests/${requestId}/cancel`,\n        }),\n        config,\n        options: {\n          signal: abortSignal,\n        },\n      });\n    },\n  };\n  return ref;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}