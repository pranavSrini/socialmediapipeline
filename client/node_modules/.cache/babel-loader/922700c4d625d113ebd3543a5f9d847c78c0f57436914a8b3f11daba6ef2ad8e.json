{"ast":null,"code":"/* eslint-disable no-param-reassign */\nconst $Ref = require('./ref');\nconst {\n  JSONParserError,\n  InvalidPointerError,\n  MissingPointerError,\n  isHandledError\n} = require('./util/errors');\nconst url = require('./util/url');\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\nmodule.exports = Pointer;\n\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param {$Ref} $ref\n * @param {string} path\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @constructor\n */\nfunction Pointer($ref, path, friendlyPath) {\n  /**\n   * The {@link $Ref} object that contains this {@link Pointer} object.\n   * @type {$Ref}\n   */\n  this.$ref = $ref;\n\n  /**\n   * The file path or URL, containing the JSON pointer in the hash.\n   * This path is relative to the path of the main JSON schema file.\n   * @type {string}\n   */\n  this.path = path;\n\n  /**\n   * The original path or URL, used for error messages.\n   * @type {string}\n   */\n  this.originalPath = friendlyPath || path;\n\n  /**\n   * The value of the JSON pointer.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * Indicates whether the pointer references itself.\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * The number of indirect references that were traversed to resolve the value.\n   * Resolving a single pointer may require resolving multiple $Refs.\n   * @type {number}\n   */\n  this.indirections = 0;\n}\n\n/**\n * Resolves the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {$RefParserOptions} options\n * @param {string} pathFromRoot - the path of place that initiated resolving\n *\n * @returns {Pointer}\n * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n * If resolving this value required resolving other JSON references, then\n * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n * of the resolved value.\n */\nPointer.prototype.resolve = function (obj, options, pathFromRoot) {\n  const tokens = Pointer.parse(this.path, this.originalPath);\n\n  // Crawl the object, one token at a time\n  this.value = unwrapOrThrow(obj);\n  for (let i = 0; i < tokens.length; i++) {\n    if (resolveIf$Ref(this, options)) {\n      // The $ref path has changed, so append the remaining tokens to the path\n      this.path = Pointer.join(this.path, tokens.slice(i));\n    }\n    if (typeof this.value === 'object' && this.value !== null && '$ref' in this.value) {\n      return this;\n    }\n    const token = tokens[i];\n    if (this.value[token] === undefined || this.value[token] === null) {\n      this.value = null;\n      throw new MissingPointerError(token, this.originalPath);\n    } else {\n      this.value = this.value[token];\n    }\n  }\n\n  // Resolve the final value\n  if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {\n    resolveIf$Ref(this, options);\n  }\n  return this;\n};\n\n/**\n * Sets the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {*} value - the value to assign\n * @param {$RefParserOptions} options\n *\n * @returns {*}\n * Returns the modified object, or an entirely new object if the entire object is overwritten.\n */\nPointer.prototype.set = function (obj, value, options) {\n  const tokens = Pointer.parse(this.path);\n  let token;\n  if (tokens.length === 0) {\n    // There are no tokens, replace the entire object with the new value\n    this.value = value;\n    return value;\n  }\n\n  // Crawl the object, one token at a time\n  this.value = unwrapOrThrow(obj);\n  for (let i = 0; i < tokens.length - 1; i++) {\n    resolveIf$Ref(this, options);\n    token = tokens[i];\n    if (this.value && this.value[token] !== undefined) {\n      // The token exists\n      this.value = this.value[token];\n    } else {\n      // The token doesn't exist, so create it\n      this.value = setValue(this, token, {});\n    }\n  }\n\n  // Set the value of the final token\n  resolveIf$Ref(this, options);\n  token = tokens[tokens.length - 1];\n  setValue(this, token, value);\n\n  // Return the updated object\n  return obj;\n};\n\n/**\n * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n * and returns an array of the pointer's tokens.\n * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n *\n * The pointer is parsed according to RFC 6901\n * {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @param {string} path\n * @param {string} [originalPath]\n * @returns {string[]}\n */\nPointer.parse = function (path, originalPath) {\n  // Get the JSON pointer from the path's hash\n  let pointer = url.getHash(path).substr(1);\n\n  // If there's no pointer, then there are no tokens,\n  // so return an empty array\n  if (!pointer) {\n    return [];\n  }\n\n  // Split into an array\n  pointer = pointer.split('/');\n\n  // Decode each part, according to RFC 6901\n  for (let i = 0; i < pointer.length; i++) {\n    pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, '/').replace(escapedTilde, '~'));\n  }\n  if (pointer[0] !== '') {\n    throw new InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);\n  }\n  return pointer.slice(1);\n};\n\n/**\n * Creates a JSON pointer path, by joining one or more tokens to a base path.\n *\n * @param {string} base - The base path (e.g. \"schema.json#/definitions/person\")\n * @param {string|string[]} tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n * @returns {string}\n */\nPointer.join = function (base, tokens) {\n  // Ensure that the base path contains a hash\n  if (base.indexOf('#') === -1) {\n    base += '#';\n  }\n\n  // Append each token to the base path\n  tokens = Array.isArray(tokens) ? tokens : [tokens];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    // Encode the token, according to RFC 6901\n    base += `/${encodeURIComponent(token.replace(tildes, '~0').replace(slashes, '~1'))}`;\n  }\n  return base;\n};\n\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param {Pointer} pointer\n * @param {$RefParserOptions} options\n * @returns {boolean} - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref(pointer, options) {\n  // Is the value a JSON reference? (and allowed?)\n\n  if ($Ref.isAllowed$Ref(pointer.value, options)) {\n    const $refPath = url.resolve(pointer.path, pointer.value.$ref);\n    if ($refPath === pointer.path) {\n      // The value is a reference to itself, so there's nothing to do.\n      pointer.circular = true;\n    } else {\n      const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n      if (resolved === null) {\n        return false;\n      }\n      pointer.indirections += resolved.indirections + 1;\n      if ($Ref.isExtended$Ref(pointer.value)) {\n        // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n        // So the resolved path does NOT change.  Just the value does.\n        pointer.value = $Ref.dereference(pointer.value, resolved.value);\n        return false;\n      }\n\n      // Resolve the reference\n      pointer.$ref = resolved.$ref;\n      pointer.path = resolved.path;\n      pointer.value = resolved.value;\n      return true;\n    }\n  }\n}\n\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param {Pointer} pointer - The JSON Pointer whose value will be modified\n * @param {string} token - A JSON Pointer token that indicates how to modify `obj`\n * @param {*} value - The value to assign\n * @returns {*} - Returns the assigned value\n */\nfunction setValue(pointer, token, value) {\n  if (pointer.value && typeof pointer.value === 'object') {\n    if (token === '-' && Array.isArray(pointer.value)) {\n      pointer.value.push(value);\n    } else {\n      pointer.value[token] = value;\n    }\n  } else {\n    throw new JSONParserError(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n  }\n  return value;\n}\nfunction unwrapOrThrow(value) {\n  if (isHandledError(value)) {\n    throw value;\n  }\n  return value;\n}","map":{"version":3,"names":["$Ref","require","JSONParserError","InvalidPointerError","MissingPointerError","isHandledError","url","slashes","tildes","escapedSlash","escapedTilde","module","exports","Pointer","$ref","path","friendlyPath","originalPath","value","undefined","circular","indirections","prototype","resolve","obj","options","pathFromRoot","tokens","parse","unwrapOrThrow","i","length","resolveIf$Ref","join","slice","token","set","setValue","pointer","getHash","substr","split","decodeURIComponent","replace","base","indexOf","Array","isArray","encodeURIComponent","isAllowed$Ref","$refPath","resolved","$refs","_resolve","isExtended$Ref","dereference","push"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/pointer.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\nconst $Ref = require('./ref');\nconst { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } = require('./util/errors');\nconst url = require('./util/url');\n\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\n\nmodule.exports = Pointer;\n\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param {$Ref} $ref\n * @param {string} path\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @constructor\n */\nfunction Pointer($ref, path, friendlyPath) {\n  /**\n   * The {@link $Ref} object that contains this {@link Pointer} object.\n   * @type {$Ref}\n   */\n  this.$ref = $ref;\n\n  /**\n   * The file path or URL, containing the JSON pointer in the hash.\n   * This path is relative to the path of the main JSON schema file.\n   * @type {string}\n   */\n  this.path = path;\n\n  /**\n   * The original path or URL, used for error messages.\n   * @type {string}\n   */\n  this.originalPath = friendlyPath || path;\n\n  /**\n   * The value of the JSON pointer.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * Indicates whether the pointer references itself.\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * The number of indirect references that were traversed to resolve the value.\n   * Resolving a single pointer may require resolving multiple $Refs.\n   * @type {number}\n   */\n  this.indirections = 0;\n}\n\n/**\n * Resolves the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {$RefParserOptions} options\n * @param {string} pathFromRoot - the path of place that initiated resolving\n *\n * @returns {Pointer}\n * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n * If resolving this value required resolving other JSON references, then\n * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n * of the resolved value.\n */\nPointer.prototype.resolve = function (obj, options, pathFromRoot) {\n  const tokens = Pointer.parse(this.path, this.originalPath);\n\n  // Crawl the object, one token at a time\n  this.value = unwrapOrThrow(obj);\n\n  for (let i = 0; i < tokens.length; i++) {\n    if (resolveIf$Ref(this, options)) {\n      // The $ref path has changed, so append the remaining tokens to the path\n      this.path = Pointer.join(this.path, tokens.slice(i));\n    }\n\n    if (typeof this.value === 'object' && this.value !== null && '$ref' in this.value) {\n      return this;\n    }\n\n    const token = tokens[i];\n    if (this.value[token] === undefined || this.value[token] === null) {\n      this.value = null;\n      throw new MissingPointerError(token, this.originalPath);\n    } else {\n      this.value = this.value[token];\n    }\n  }\n\n  // Resolve the final value\n  if (!this.value || (this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot)) {\n    resolveIf$Ref(this, options);\n  }\n\n  return this;\n};\n\n/**\n * Sets the value of a nested property within the given object.\n *\n * @param {*} obj - The object that will be crawled\n * @param {*} value - the value to assign\n * @param {$RefParserOptions} options\n *\n * @returns {*}\n * Returns the modified object, or an entirely new object if the entire object is overwritten.\n */\nPointer.prototype.set = function (obj, value, options) {\n  const tokens = Pointer.parse(this.path);\n  let token;\n\n  if (tokens.length === 0) {\n    // There are no tokens, replace the entire object with the new value\n    this.value = value;\n    return value;\n  }\n\n  // Crawl the object, one token at a time\n  this.value = unwrapOrThrow(obj);\n\n  for (let i = 0; i < tokens.length - 1; i++) {\n    resolveIf$Ref(this, options);\n\n    token = tokens[i];\n    if (this.value && this.value[token] !== undefined) {\n      // The token exists\n      this.value = this.value[token];\n    } else {\n      // The token doesn't exist, so create it\n      this.value = setValue(this, token, {});\n    }\n  }\n\n  // Set the value of the final token\n  resolveIf$Ref(this, options);\n  token = tokens[tokens.length - 1];\n  setValue(this, token, value);\n\n  // Return the updated object\n  return obj;\n};\n\n/**\n * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n * and returns an array of the pointer's tokens.\n * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n *\n * The pointer is parsed according to RFC 6901\n * {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @param {string} path\n * @param {string} [originalPath]\n * @returns {string[]}\n */\nPointer.parse = function (path, originalPath) {\n  // Get the JSON pointer from the path's hash\n  let pointer = url.getHash(path).substr(1);\n\n  // If there's no pointer, then there are no tokens,\n  // so return an empty array\n  if (!pointer) {\n    return [];\n  }\n\n  // Split into an array\n  pointer = pointer.split('/');\n\n  // Decode each part, according to RFC 6901\n  for (let i = 0; i < pointer.length; i++) {\n    pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, '/').replace(escapedTilde, '~'));\n  }\n\n  if (pointer[0] !== '') {\n    throw new InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);\n  }\n\n  return pointer.slice(1);\n};\n\n/**\n * Creates a JSON pointer path, by joining one or more tokens to a base path.\n *\n * @param {string} base - The base path (e.g. \"schema.json#/definitions/person\")\n * @param {string|string[]} tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n * @returns {string}\n */\nPointer.join = function (base, tokens) {\n  // Ensure that the base path contains a hash\n  if (base.indexOf('#') === -1) {\n    base += '#';\n  }\n\n  // Append each token to the base path\n  tokens = Array.isArray(tokens) ? tokens : [tokens];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    // Encode the token, according to RFC 6901\n    base += `/${encodeURIComponent(token.replace(tildes, '~0').replace(slashes, '~1'))}`;\n  }\n\n  return base;\n};\n\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param {Pointer} pointer\n * @param {$RefParserOptions} options\n * @returns {boolean} - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref(pointer, options) {\n  // Is the value a JSON reference? (and allowed?)\n\n  if ($Ref.isAllowed$Ref(pointer.value, options)) {\n    const $refPath = url.resolve(pointer.path, pointer.value.$ref);\n\n    if ($refPath === pointer.path) {\n      // The value is a reference to itself, so there's nothing to do.\n      pointer.circular = true;\n    } else {\n      const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n      if (resolved === null) {\n        return false;\n      }\n\n      pointer.indirections += resolved.indirections + 1;\n\n      if ($Ref.isExtended$Ref(pointer.value)) {\n        // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n        // So the resolved path does NOT change.  Just the value does.\n        pointer.value = $Ref.dereference(pointer.value, resolved.value);\n        return false;\n      }\n\n      // Resolve the reference\n      pointer.$ref = resolved.$ref;\n      pointer.path = resolved.path;\n      pointer.value = resolved.value;\n      return true;\n    }\n  }\n}\n\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param {Pointer} pointer - The JSON Pointer whose value will be modified\n * @param {string} token - A JSON Pointer token that indicates how to modify `obj`\n * @param {*} value - The value to assign\n * @returns {*} - Returns the assigned value\n */\nfunction setValue(pointer, token, value) {\n  if (pointer.value && typeof pointer.value === 'object') {\n    if (token === '-' && Array.isArray(pointer.value)) {\n      pointer.value.push(value);\n    } else {\n      pointer.value[token] = value;\n    }\n  } else {\n    throw new JSONParserError(\n      `Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`\n    );\n  }\n  return value;\n}\n\nfunction unwrapOrThrow(value) {\n  if (isHandledError(value)) {\n    throw value;\n  }\n\n  return value;\n}\n"],"mappings":"AAAA;AACA,MAAMA,IAAI,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC7B,MAAM;EAAEC,eAAe;EAAEC,mBAAmB;EAAEC,mBAAmB;EAAEC;AAAe,CAAC,GAAGJ,OAAO,CAAC,eAAe,CAAC;AAC9G,MAAMK,GAAG,GAAGL,OAAO,CAAC,YAAY,CAAC;AAEjC,MAAMM,OAAO,GAAG,KAAK;AACrB,MAAMC,MAAM,GAAG,IAAI;AACnB,MAAMC,YAAY,GAAG,KAAK;AAC1B,MAAMC,YAAY,GAAG,KAAK;AAE1BC,MAAM,CAACC,OAAO,GAAGC,OAAO;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAOA,CAACC,IAAI,EAAEC,IAAI,EAAEC,YAAY,EAAE;EACzC;AACF;AACA;AACA;EACE,IAAI,CAACF,IAAI,GAAGA,IAAI;;EAEhB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAGA,IAAI;;EAEhB;AACF;AACA;AACA;EACE,IAAI,CAACE,YAAY,GAAGD,YAAY,IAAID,IAAI;;EAExC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACG,KAAK,GAAGC,SAAS;;EAEtB;AACF;AACA;AACA;EACE,IAAI,CAACC,QAAQ,GAAG,KAAK;;EAErB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAG,CAAC;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,OAAO,CAACS,SAAS,CAACC,OAAO,GAAG,UAAUC,GAAG,EAAEC,OAAO,EAAEC,YAAY,EAAE;EAChE,MAAMC,MAAM,GAAGd,OAAO,CAACe,KAAK,CAAC,IAAI,CAACb,IAAI,EAAE,IAAI,CAACE,YAAY,CAAC;;EAE1D;EACA,IAAI,CAACC,KAAK,GAAGW,aAAa,CAACL,GAAG,CAAC;EAE/B,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,IAAIE,aAAa,CAAC,IAAI,EAAEP,OAAO,CAAC,EAAE;MAChC;MACA,IAAI,CAACV,IAAI,GAAGF,OAAO,CAACoB,IAAI,CAAC,IAAI,CAAClB,IAAI,EAAEY,MAAM,CAACO,KAAK,CAACJ,CAAC,CAAC,CAAC;IACtD;IAEA,IAAI,OAAO,IAAI,CAACZ,KAAK,KAAK,QAAQ,IAAI,IAAI,CAACA,KAAK,KAAK,IAAI,IAAI,MAAM,IAAI,IAAI,CAACA,KAAK,EAAE;MACjF,OAAO,IAAI;IACb;IAEA,MAAMiB,KAAK,GAAGR,MAAM,CAACG,CAAC,CAAC;IACvB,IAAI,IAAI,CAACZ,KAAK,CAACiB,KAAK,CAAC,KAAKhB,SAAS,IAAI,IAAI,CAACD,KAAK,CAACiB,KAAK,CAAC,KAAK,IAAI,EAAE;MACjE,IAAI,CAACjB,KAAK,GAAG,IAAI;MACjB,MAAM,IAAId,mBAAmB,CAAC+B,KAAK,EAAE,IAAI,CAAClB,YAAY,CAAC;IACzD,CAAC,MAAM;MACL,IAAI,CAACC,KAAK,GAAG,IAAI,CAACA,KAAK,CAACiB,KAAK,CAAC;IAChC;EACF;;EAEA;EACA,IAAI,CAAC,IAAI,CAACjB,KAAK,IAAK,IAAI,CAACA,KAAK,CAACJ,IAAI,IAAIR,GAAG,CAACiB,OAAO,CAAC,IAAI,CAACR,IAAI,EAAE,IAAI,CAACG,KAAK,CAACJ,IAAI,CAAC,KAAKY,YAAa,EAAE;IAChGM,aAAa,CAAC,IAAI,EAAEP,OAAO,CAAC;EAC9B;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAZ,OAAO,CAACS,SAAS,CAACc,GAAG,GAAG,UAAUZ,GAAG,EAAEN,KAAK,EAAEO,OAAO,EAAE;EACrD,MAAME,MAAM,GAAGd,OAAO,CAACe,KAAK,CAAC,IAAI,CAACb,IAAI,CAAC;EACvC,IAAIoB,KAAK;EAET,IAAIR,MAAM,CAACI,MAAM,KAAK,CAAC,EAAE;IACvB;IACA,IAAI,CAACb,KAAK,GAAGA,KAAK;IAClB,OAAOA,KAAK;EACd;;EAEA;EACA,IAAI,CAACA,KAAK,GAAGW,aAAa,CAACL,GAAG,CAAC;EAE/B,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;IAC1CE,aAAa,CAAC,IAAI,EAAEP,OAAO,CAAC;IAE5BU,KAAK,GAAGR,MAAM,CAACG,CAAC,CAAC;IACjB,IAAI,IAAI,CAACZ,KAAK,IAAI,IAAI,CAACA,KAAK,CAACiB,KAAK,CAAC,KAAKhB,SAAS,EAAE;MACjD;MACA,IAAI,CAACD,KAAK,GAAG,IAAI,CAACA,KAAK,CAACiB,KAAK,CAAC;IAChC,CAAC,MAAM;MACL;MACA,IAAI,CAACjB,KAAK,GAAGmB,QAAQ,CAAC,IAAI,EAAEF,KAAK,EAAE,CAAC,CAAC,CAAC;IACxC;EACF;;EAEA;EACAH,aAAa,CAAC,IAAI,EAAEP,OAAO,CAAC;EAC5BU,KAAK,GAAGR,MAAM,CAACA,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;EACjCM,QAAQ,CAAC,IAAI,EAAEF,KAAK,EAAEjB,KAAK,CAAC;;EAE5B;EACA,OAAOM,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,OAAO,CAACe,KAAK,GAAG,UAAUb,IAAI,EAAEE,YAAY,EAAE;EAC5C;EACA,IAAIqB,OAAO,GAAGhC,GAAG,CAACiC,OAAO,CAACxB,IAAI,CAAC,CAACyB,MAAM,CAAC,CAAC,CAAC;;EAEzC;EACA;EACA,IAAI,CAACF,OAAO,EAAE;IACZ,OAAO,EAAE;EACX;;EAEA;EACAA,OAAO,GAAGA,OAAO,CAACG,KAAK,CAAC,GAAG,CAAC;;EAE5B;EACA,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,OAAO,CAACP,MAAM,EAAED,CAAC,EAAE,EAAE;IACvCQ,OAAO,CAACR,CAAC,CAAC,GAAGY,kBAAkB,CAACJ,OAAO,CAACR,CAAC,CAAC,CAACa,OAAO,CAAClC,YAAY,EAAE,GAAG,CAAC,CAACkC,OAAO,CAACjC,YAAY,EAAE,GAAG,CAAC,CAAC;EACnG;EAEA,IAAI4B,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;IACrB,MAAM,IAAInC,mBAAmB,CAACmC,OAAO,EAAErB,YAAY,KAAKE,SAAS,GAAGJ,IAAI,GAAGE,YAAY,CAAC;EAC1F;EAEA,OAAOqB,OAAO,CAACJ,KAAK,CAAC,CAAC,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,OAAO,CAACoB,IAAI,GAAG,UAAUW,IAAI,EAAEjB,MAAM,EAAE;EACrC;EACA,IAAIiB,IAAI,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IAC5BD,IAAI,IAAI,GAAG;EACb;;EAEA;EACAjB,MAAM,GAAGmB,KAAK,CAACC,OAAO,CAACpB,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;EAClD,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,MAAMK,KAAK,GAAGR,MAAM,CAACG,CAAC,CAAC;IACvB;IACAc,IAAI,IAAI,IAAII,kBAAkB,CAACb,KAAK,CAACQ,OAAO,CAACnC,MAAM,EAAE,IAAI,CAAC,CAACmC,OAAO,CAACpC,OAAO,EAAE,IAAI,CAAC,CAAC,EAAE;EACtF;EAEA,OAAOqC,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASZ,aAAaA,CAACM,OAAO,EAAEb,OAAO,EAAE;EACvC;;EAEA,IAAIzB,IAAI,CAACiD,aAAa,CAACX,OAAO,CAACpB,KAAK,EAAEO,OAAO,CAAC,EAAE;IAC9C,MAAMyB,QAAQ,GAAG5C,GAAG,CAACiB,OAAO,CAACe,OAAO,CAACvB,IAAI,EAAEuB,OAAO,CAACpB,KAAK,CAACJ,IAAI,CAAC;IAE9D,IAAIoC,QAAQ,KAAKZ,OAAO,CAACvB,IAAI,EAAE;MAC7B;MACAuB,OAAO,CAAClB,QAAQ,GAAG,IAAI;IACzB,CAAC,MAAM;MACL,MAAM+B,QAAQ,GAAGb,OAAO,CAACxB,IAAI,CAACsC,KAAK,CAACC,QAAQ,CAACH,QAAQ,EAAEZ,OAAO,CAACvB,IAAI,EAAEU,OAAO,CAAC;MAC7E,IAAI0B,QAAQ,KAAK,IAAI,EAAE;QACrB,OAAO,KAAK;MACd;MAEAb,OAAO,CAACjB,YAAY,IAAI8B,QAAQ,CAAC9B,YAAY,GAAG,CAAC;MAEjD,IAAIrB,IAAI,CAACsD,cAAc,CAAChB,OAAO,CAACpB,KAAK,CAAC,EAAE;QACtC;QACA;QACAoB,OAAO,CAACpB,KAAK,GAAGlB,IAAI,CAACuD,WAAW,CAACjB,OAAO,CAACpB,KAAK,EAAEiC,QAAQ,CAACjC,KAAK,CAAC;QAC/D,OAAO,KAAK;MACd;;MAEA;MACAoB,OAAO,CAACxB,IAAI,GAAGqC,QAAQ,CAACrC,IAAI;MAC5BwB,OAAO,CAACvB,IAAI,GAAGoC,QAAQ,CAACpC,IAAI;MAC5BuB,OAAO,CAACpB,KAAK,GAAGiC,QAAQ,CAACjC,KAAK;MAC9B,OAAO,IAAI;IACb;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,QAAQA,CAACC,OAAO,EAAEH,KAAK,EAAEjB,KAAK,EAAE;EACvC,IAAIoB,OAAO,CAACpB,KAAK,IAAI,OAAOoB,OAAO,CAACpB,KAAK,KAAK,QAAQ,EAAE;IACtD,IAAIiB,KAAK,KAAK,GAAG,IAAIW,KAAK,CAACC,OAAO,CAACT,OAAO,CAACpB,KAAK,CAAC,EAAE;MACjDoB,OAAO,CAACpB,KAAK,CAACsC,IAAI,CAACtC,KAAK,CAAC;IAC3B,CAAC,MAAM;MACLoB,OAAO,CAACpB,KAAK,CAACiB,KAAK,CAAC,GAAGjB,KAAK;IAC9B;EACF,CAAC,MAAM;IACL,MAAM,IAAIhB,eAAe,CACvB,iCAAiCoC,OAAO,CAACvB,IAAI,oBAAoBoB,KAAK,oBACxE,CAAC;EACH;EACA,OAAOjB,KAAK;AACd;AAEA,SAASW,aAAaA,CAACX,KAAK,EAAE;EAC5B,IAAIb,cAAc,CAACa,KAAK,CAAC,EAAE;IACzB,MAAMA,KAAK;EACb;EAEA,OAAOA,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}