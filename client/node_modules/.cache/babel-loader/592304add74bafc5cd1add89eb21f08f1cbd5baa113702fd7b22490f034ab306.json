{"ast":null,"code":"const {\n  ono\n} = require('@jsdevtools/ono');\nconst $Ref = require('./ref');\nconst url = require('./util/url');\nmodule.exports = $Refs;\n\n/**\n * This class is a map of JSON references and their resolved values.\n */\nfunction $Refs() {\n  /**\n   * Indicates whether the schema contains any circular references.\n   *\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * Contains any circular references that may be present within the schema.\n   *\n   * @type {array}\n   */\n  this.circularRefs = [];\n\n  /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */\n  this._$refs = {};\n\n  /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */\n  this._root$Ref = null;\n}\n\n/**\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n * including the schema itself.\n *\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {string[]}\n */\n$Refs.prototype.paths = function (types) {\n  const paths = getPaths(this._$refs, arguments);\n  return paths.map(path => {\n    return path.decoded;\n  });\n};\n\n/**\n * Returns the map of JSON references and their resolved values.\n *\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\n * @returns {object}\n */\n$Refs.prototype.values = function (types) {\n  const $refs = this._$refs;\n  const paths = getPaths($refs, arguments);\n  return paths.reduce((obj, path) => {\n    // eslint-disable-next-line no-param-reassign\n    obj[path.decoded] = $refs[path.encoded].value;\n    return obj;\n  }, {});\n};\n\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */\n$Refs.prototype.toJSON = $Refs.prototype.values;\n\n/**\n * Determines whether the given JSON reference exists.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {boolean}\n */\n$Refs.prototype.exists = function (path, options) {\n  try {\n    this._resolve(path, '', options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference and returns the resolved value.\n *\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {*} - Returns the resolved value\n */\n$Refs.prototype.get = function (path, options) {\n  return this._resolve(path, '', options).value;\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Refs.prototype.set = function (path, value) {\n  const absPath = url.resolve(this._root$Ref.path, path);\n  const withoutHash = url.stripHash(absPath);\n  const $ref = this._$refs[withoutHash];\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n  $ref.set(absPath, value);\n};\n\n/**\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n *\n * @param {string} path  - The file path or URL of the referenced file\n */\n$Refs.prototype._add = function (path) {\n  const withoutHash = url.stripHash(path);\n  const $ref = new $Ref();\n  $ref.path = withoutHash;\n  $ref.$refs = this;\n  this._$refs[withoutHash] = $ref;\n  this._root$Ref = this._root$Ref || $ref;\n  return $ref;\n};\n\n/**\n * Resolves the given JSON reference.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {$RefParserOptions} [options]\n * @returns {Pointer}\n * @protected\n */\n$Refs.prototype._resolve = function (path, pathFromRoot, options) {\n  const absPath = url.resolve(this._root$Ref.path, path);\n  const withoutHash = url.stripHash(absPath);\n  const $ref = this._$refs[withoutHash];\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n  return $ref.resolve(absPath, options, path, pathFromRoot);\n};\n\n/**\n * Returns the specified {@link $Ref} object, or undefined.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @returns {$Ref|undefined}\n * @protected\n */\n$Refs.prototype._get$Ref = function (path) {\n  // eslint-disable-next-line no-param-reassign\n  path = url.resolve(this._root$Ref.path, path);\n  const withoutHash = url.stripHash(path);\n  return this._$refs[withoutHash];\n};\n\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param {object} $refs - The object whose keys are URL-encoded paths\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {object[]}\n */\nfunction getPaths($refs, types) {\n  let paths = Object.keys($refs);\n\n  // Filter the paths by type\n  // eslint-disable-next-line no-param-reassign\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n  if (types.length > 0 && types[0]) {\n    paths = paths.filter(key => {\n      return types.indexOf($refs[key].pathType) !== -1;\n    });\n  }\n\n  // Decode local filesystem paths\n  return paths.map(path => {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType === 'file' ? url.toFileSystemPath(path, true) : path\n    };\n  });\n}","map":{"version":3,"names":["ono","require","$Ref","url","module","exports","$Refs","circular","circularRefs","_$refs","_root$Ref","prototype","paths","types","getPaths","arguments","map","path","decoded","values","$refs","reduce","obj","encoded","value","toJSON","exists","options","_resolve","e","get","set","absPath","resolve","withoutHash","stripHash","$ref","_add","pathFromRoot","_get$Ref","Object","keys","Array","isArray","slice","call","length","filter","key","indexOf","pathType","toFileSystemPath"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/refs.js"],"sourcesContent":["const { ono } = require('@jsdevtools/ono');\n\nconst $Ref = require('./ref');\nconst url = require('./util/url');\n\nmodule.exports = $Refs;\n\n/**\n * This class is a map of JSON references and their resolved values.\n */\nfunction $Refs() {\n  /**\n   * Indicates whether the schema contains any circular references.\n   *\n   * @type {boolean}\n   */\n  this.circular = false;\n\n  /**\n   * Contains any circular references that may be present within the schema.\n   *\n   * @type {array}\n   */\n  this.circularRefs = [];\n\n  /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */\n  this._$refs = {};\n\n  /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */\n  this._root$Ref = null;\n}\n\n/**\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n * including the schema itself.\n *\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {string[]}\n */\n$Refs.prototype.paths = function (types) {\n  const paths = getPaths(this._$refs, arguments);\n  return paths.map(path => {\n    return path.decoded;\n  });\n};\n\n/**\n * Returns the map of JSON references and their resolved values.\n *\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\n * @returns {object}\n */\n$Refs.prototype.values = function (types) {\n  const $refs = this._$refs;\n  const paths = getPaths($refs, arguments);\n  return paths.reduce((obj, path) => {\n    // eslint-disable-next-line no-param-reassign\n    obj[path.decoded] = $refs[path.encoded].value;\n    return obj;\n  }, {});\n};\n\n/**\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n *\n * @returns {object}\n */\n$Refs.prototype.toJSON = $Refs.prototype.values;\n\n/**\n * Determines whether the given JSON reference exists.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {boolean}\n */\n$Refs.prototype.exists = function (path, options) {\n  try {\n    this._resolve(path, '', options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference and returns the resolved value.\n *\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\n * @param {$RefParserOptions} [options]\n * @returns {*} - Returns the resolved value\n */\n$Refs.prototype.get = function (path, options) {\n  return this._resolve(path, '', options).value;\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Refs.prototype.set = function (path, value) {\n  const absPath = url.resolve(this._root$Ref.path, path);\n  const withoutHash = url.stripHash(absPath);\n  const $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  $ref.set(absPath, value);\n};\n\n/**\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n *\n * @param {string} path  - The file path or URL of the referenced file\n */\n$Refs.prototype._add = function (path) {\n  const withoutHash = url.stripHash(path);\n\n  const $ref = new $Ref();\n  $ref.path = withoutHash;\n  $ref.$refs = this;\n\n  this._$refs[withoutHash] = $ref;\n  this._root$Ref = this._root$Ref || $ref;\n\n  return $ref;\n};\n\n/**\n * Resolves the given JSON reference.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {$RefParserOptions} [options]\n * @returns {Pointer}\n * @protected\n */\n$Refs.prototype._resolve = function (path, pathFromRoot, options) {\n  const absPath = url.resolve(this._root$Ref.path, path);\n  const withoutHash = url.stripHash(absPath);\n  const $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  return $ref.resolve(absPath, options, path, pathFromRoot);\n};\n\n/**\n * Returns the specified {@link $Ref} object, or undefined.\n *\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\n * @returns {$Ref|undefined}\n * @protected\n */\n$Refs.prototype._get$Ref = function (path) {\n  // eslint-disable-next-line no-param-reassign\n  path = url.resolve(this._root$Ref.path, path);\n  const withoutHash = url.stripHash(path);\n  return this._$refs[withoutHash];\n};\n\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param {object} $refs - The object whose keys are URL-encoded paths\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns {object[]}\n */\nfunction getPaths($refs, types) {\n  let paths = Object.keys($refs);\n\n  // Filter the paths by type\n  // eslint-disable-next-line no-param-reassign\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n  if (types.length > 0 && types[0]) {\n    paths = paths.filter(key => {\n      return types.indexOf($refs[key].pathType) !== -1;\n    });\n  }\n\n  // Decode local filesystem paths\n  return paths.map(path => {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType === 'file' ? url.toFileSystemPath(path, true) : path,\n    };\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}