{"ast":null,"code":"const {\n  ono\n} = require('@jsdevtools/ono');\nconst {\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError\n} = require('./util/errors');\nconst plugins = require('./util/plugins');\nconst url = require('./util/url');\n\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\nmodule.exports = async function parse(path, $refs, options) {\n  // Remove the URL fragment, if any\n  // eslint-disable-next-line no-param-reassign\n  path = url.stripHash(path);\n\n  // Add a new $Ref for this file, even though we don't have the value yet.\n  // This ensures that we don't simultaneously read & parse the same file multiple times\n  const $ref = $refs._add(path);\n\n  // This \"file object\" will be passed to all resolvers and parsers.\n  const file = {\n    url: path,\n    extension: url.getExtension(path)\n  };\n\n  // Read the file and then parse the data\n  try {\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n    return parser.result;\n  } catch (err) {\n    if (isHandledError(err)) {\n      $ref.value = err;\n    }\n    throw err;\n  }\n};\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nfunction readFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, 'canRead', file);\n\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    plugins.run(resolvers, 'read', file, $refs).then(resolve, onError);\n    function onError(err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedResolverError(file.url));\n      } else if (!err || !('error' in err)) {\n        // Throw a generic, friendly error.\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      } else if (err.error instanceof ResolverError) {\n        // Throw the original error, if it's one of our own (user-friendly) errors.\n        reject(err.error);\n      } else {\n        reject(new ResolverError(err, file.url));\n      }\n    }\n  });\n}\n\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nfunction parseFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    const allParsers = plugins.all(options.parse);\n    const filteredParsers = plugins.filter(allParsers, 'canParse', file);\n    const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    plugins.run(parsers, 'parse', file, $refs).then(onParsed, onError);\n    function onParsed(parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      } else {\n        resolve(parser);\n      }\n    }\n    function onError(err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedParserError(file.url));\n      } else if (!err || !('error' in err)) {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      } else if (err.error instanceof ParserError) {\n        reject(err.error);\n      } else {\n        reject(new ParserError(err.error.message, file.url));\n      }\n    }\n  });\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isEmpty(value) {\n  return value === undefined || typeof value === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}","map":{"version":3,"names":["ono","require","ResolverError","ParserError","UnmatchedParserError","UnmatchedResolverError","isHandledError","plugins","url","module","exports","parse","path","$refs","options","stripHash","$ref","_add","file","extension","getExtension","resolver","readFile","pathType","plugin","name","data","result","parser","parseFile","value","err","Promise","resolve","reject","resolvers","all","filter","sort","run","then","onError","continueOnError","syntax","error","allParsers","filteredParsers","parsers","length","onParsed","allowEmpty","isEmpty","message","undefined","Object","keys","trim","Buffer","isBuffer"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/parse.js"],"sourcesContent":["const { ono } = require('@jsdevtools/ono');\n\nconst {\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError,\n} = require('./util/errors');\nconst plugins = require('./util/plugins');\nconst url = require('./util/url');\n\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\nmodule.exports = async function parse(path, $refs, options) {\n  // Remove the URL fragment, if any\n  // eslint-disable-next-line no-param-reassign\n  path = url.stripHash(path);\n\n  // Add a new $Ref for this file, even though we don't have the value yet.\n  // This ensures that we don't simultaneously read & parse the same file multiple times\n  const $ref = $refs._add(path);\n\n  // This \"file object\" will be passed to all resolvers and parsers.\n  const file = {\n    url: path,\n    extension: url.getExtension(path),\n  };\n\n  // Read the file and then parse the data\n  try {\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n\n    return parser.result;\n  } catch (err) {\n    if (isHandledError(err)) {\n      $ref.value = err;\n    }\n\n    throw err;\n  }\n};\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nfunction readFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, 'canRead', file);\n\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    plugins.run(resolvers, 'read', file, $refs).then(resolve, onError);\n\n    function onError(err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedResolverError(file.url));\n      } else if (!err || !('error' in err)) {\n        // Throw a generic, friendly error.\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      } else if (err.error instanceof ResolverError) {\n        // Throw the original error, if it's one of our own (user-friendly) errors.\n        reject(err.error);\n      } else {\n        reject(new ResolverError(err, file.url));\n      }\n    }\n  });\n}\n\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nfunction parseFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    const allParsers = plugins.all(options.parse);\n    const filteredParsers = plugins.filter(allParsers, 'canParse', file);\n    const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    plugins.run(parsers, 'parse', file, $refs).then(onParsed, onError);\n\n    function onParsed(parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      } else {\n        resolve(parser);\n      }\n    }\n\n    function onError(err) {\n      if (!err && options.continueOnError) {\n        // No resolver could be matched\n        reject(new UnmatchedParserError(file.url));\n      } else if (!err || !('error' in err)) {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      } else if (err.error instanceof ParserError) {\n        reject(err.error);\n      } else {\n        reject(new ParserError(err.error.message, file.url));\n      }\n    }\n  });\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isEmpty(value) {\n  return (\n    value === undefined ||\n    (typeof value === 'object' && Object.keys(value).length === 0) ||\n    (typeof value === 'string' && value.trim().length === 0) ||\n    (Buffer.isBuffer(value) && value.length === 0)\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}