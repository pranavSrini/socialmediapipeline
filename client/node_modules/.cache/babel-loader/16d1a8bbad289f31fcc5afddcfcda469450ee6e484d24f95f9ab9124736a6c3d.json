{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TARGET_URL_HEADER = void 0;\nexports.withMiddleware = withMiddleware;\nexports.withProxy = withProxy;\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nfunction withMiddleware(...middlewares) {\n  const isDefined = middleware => typeof middleware === \"function\";\n  return config => __awaiter(this, void 0, void 0, function* () {\n    let currentConfig = Object.assign({}, config);\n    for (const middleware of middlewares.filter(isDefined)) {\n      currentConfig = yield middleware(currentConfig);\n    }\n    return currentConfig;\n  });\n}\nexports.TARGET_URL_HEADER = \"x-fal-target-url\";\nfunction withProxy(config) {\n  const passthrough = requestConfig => Promise.resolve(requestConfig);\n  // when running on the server, we don't need to proxy the request\n  if (typeof window === \"undefined\") {\n    return passthrough;\n  }\n  // if x-fal-target-url is already set, we skip it\n  return requestConfig => requestConfig.headers && exports.TARGET_URL_HEADER in requestConfig ? passthrough(requestConfig) : Promise.resolve(Object.assign(Object.assign({}, requestConfig), {\n    url: config.targetUrl,\n    headers: Object.assign(Object.assign({}, requestConfig.headers || {}), {\n      [exports.TARGET_URL_HEADER]: requestConfig.url\n    })\n  }));\n}","map":{"version":3,"names":["exports","withMiddleware","withProxy","middlewares","isDefined","middleware","config","__awaiter","currentConfig","Object","assign","filter","TARGET_URL_HEADER","passthrough","requestConfig","Promise","resolve","window","headers","url","targetUrl"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/libs/client/src/middleware.ts"],"sourcesContent":["/**\n * A request configuration object.\n *\n * **Note:** This is a simplified version of the `RequestConfig` type from the\n * `fetch` API. It contains only the properties that are relevant for the\n * fal client. It also works around the fact that the `fetch` API `Request`\n * does not support mutability, its clone method has critical limitations\n * to our use case.\n */\nexport type RequestConfig = {\n  url: string;\n  method: string;\n  headers?: Record<string, string | string[]>;\n};\n\nexport type RequestMiddleware = (\n  request: RequestConfig,\n) => Promise<RequestConfig>;\n\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nexport function withMiddleware(\n  ...middlewares: RequestMiddleware[]\n): RequestMiddleware {\n  const isDefined = (middleware: RequestMiddleware): boolean =>\n    typeof middleware === \"function\";\n\n  return async (config: RequestConfig) => {\n    let currentConfig = { ...config };\n    for (const middleware of middlewares.filter(isDefined)) {\n      currentConfig = await middleware(currentConfig);\n    }\n    return currentConfig;\n  };\n}\n\nexport type RequestProxyConfig = {\n  targetUrl: string;\n};\n\nexport const TARGET_URL_HEADER = \"x-fal-target-url\";\n\nexport function withProxy(config: RequestProxyConfig): RequestMiddleware {\n  const passthrough = (requestConfig: RequestConfig) =>\n    Promise.resolve(requestConfig);\n  // when running on the server, we don't need to proxy the request\n  if (typeof window === \"undefined\") {\n    return passthrough;\n  }\n  // if x-fal-target-url is already set, we skip it\n  return (requestConfig) =>\n    requestConfig.headers && TARGET_URL_HEADER in requestConfig\n      ? passthrough(requestConfig)\n      : Promise.resolve({\n          ...requestConfig,\n          url: config.targetUrl,\n          headers: {\n            ...(requestConfig.headers || {}),\n            [TARGET_URL_HEADER]: requestConfig.url,\n          },\n        });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBAA,OAAA,CAAAC,cAAA,GAAAA,cAAA;AAqBAD,OAAA,CAAAE,SAAA,GAAAA,SAAA;AA3BA;;;;;;AAMA,SAAgBD,cAAcA,CAC5B,GAAGE,WAAgC;EAEnC,MAAMC,SAAS,GAAIC,UAA6B,IAC9C,OAAOA,UAAU,KAAK,UAAU;EAElC,OAAcC,MAAqB,IAAIC,SAAA;IACrC,IAAIC,aAAa,GAAAC,MAAA,CAAAC,MAAA,KAAQJ,MAAM,CAAE;IACjC,KAAK,MAAMD,UAAU,IAAIF,WAAW,CAACQ,MAAM,CAACP,SAAS,CAAC,EAAE;MACtDI,aAAa,GAAG,MAAMH,UAAU,CAACG,aAAa,CAAC;IACjD;IACA,OAAOA,aAAa;EACtB,CAAC;AACH;AAMaR,OAAA,CAAAY,iBAAiB,GAAG,kBAAkB;AAEnD,SAAgBV,SAASA,CAACI,MAA0B;EAClD,MAAMO,WAAW,GAAIC,aAA4B,IAC/CC,OAAO,CAACC,OAAO,CAACF,aAAa,CAAC;EAChC;EACA,IAAI,OAAOG,MAAM,KAAK,WAAW,EAAE;IACjC,OAAOJ,WAAW;EACpB;EACA;EACA,OAAQC,aAAa,IACnBA,aAAa,CAACI,OAAO,IAAIlB,OAAA,CAAAY,iBAAiB,IAAIE,aAAa,GACvDD,WAAW,CAACC,aAAa,CAAC,GAC1BC,OAAO,CAACC,OAAO,CAAAP,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACVI,aAAa;IAChBK,GAAG,EAAEb,MAAM,CAACc,SAAS;IACrBF,OAAO,EAAAT,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACDI,aAAa,CAACI,OAAO,IAAI,EAAG;MAChC,CAAClB,OAAA,CAAAY,iBAAiB,GAAGE,aAAa,CAACK;IAAG;EAAA,GAExC;AACV","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}