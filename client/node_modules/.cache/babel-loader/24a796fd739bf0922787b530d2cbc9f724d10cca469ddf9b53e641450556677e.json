{"ast":null,"code":"const BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 400,\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse(file) {\n    // Use this parser if the file is a Buffer, and has a known binary extension\n    return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n  },\n  /**\n   * Parses the given data as a Buffer (byte array).\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Buffer}\n   */\n  parse(file) {\n    if (Buffer.isBuffer(file.data)) {\n      return file.data;\n    }\n\n    // This will reject if data is anything other than a string or typed array\n    return Buffer.from(file.data);\n  }\n};","map":{"version":3,"names":["BINARY_REGEXP","module","exports","order","allowEmpty","canParse","file","Buffer","isBuffer","data","test","url","parse","from"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/parsers/binary.js"],"sourcesContent":["const BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 400,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse(file) {\n    // Use this parser if the file is a Buffer, and has a known binary extension\n    return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given data as a Buffer (byte array).\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Buffer}\n   */\n  parse(file) {\n    if (Buffer.isBuffer(file.data)) {\n      return file.data;\n    }\n\n    // This will reject if data is anything other than a string or typed array\n    return Buffer.from(file.data);\n  },\n};\n"],"mappings":"AAAA,MAAMA,aAAa,GAAG,gCAAgC;AAEtDC,MAAM,CAACC,OAAO,GAAG;EACf;AACF;AACA;AACA;AACA;EACEC,KAAK,EAAE,GAAG;EAEV;AACF;AACA;AACA;AACA;EACEC,UAAU,EAAE,IAAI;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,QAAQA,CAACC,IAAI,EAAE;IACb;IACA,OAAOC,MAAM,CAACC,QAAQ,CAACF,IAAI,CAACG,IAAI,CAAC,IAAIT,aAAa,CAACU,IAAI,CAACJ,IAAI,CAACK,GAAG,CAAC;EACnE,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAKA,CAACN,IAAI,EAAE;IACV,IAAIC,MAAM,CAACC,QAAQ,CAACF,IAAI,CAACG,IAAI,CAAC,EAAE;MAC9B,OAAOH,IAAI,CAACG,IAAI;IAClB;;IAEA;IACA,OAAOF,MAAM,CAACM,IAAI,CAACP,IAAI,CAACG,IAAI,CAAC;EAC/B;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}