{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nvar data_urls_1 = require(\"@readme/data-urls\");\nvar readable_stream_1 = require(\"readable-stream\");\nif (!globalThis.Blob) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies\n    globalThis.Blob = require('formdata-node').Blob;\n  } catch (e) {\n    throw new Error('Since you do not have the Blob API available in this environment you must install the optional `formdata-node` dependency.');\n  }\n}\nif (!globalThis.File) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies\n    globalThis.File = require('formdata-node').File;\n  } catch (e) {\n    throw new Error('Since you do not have the File API available in this environment you must install the optional `formdata-node` dependency.');\n  }\n}\nif (!globalThis.FormData) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies\n    globalThis.FormData = require('formdata-node').FormData;\n  } catch (e) {\n    throw new Error('Since you do not have the FormData API available in this environment you must install the optional `formdata-node` dependency.');\n  }\n}\nfunction isBrowser() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction isBuffer(value) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n}\nfunction isFile(value) {\n  if (value instanceof File) {\n    /**\n     * The `Blob` polyfill on Node comes back as being an instanceof `File`. Because passing a Blob\n     * into a File will end up with a corrupted file we want to prevent this.\n     *\n     * This object identity crisis does not happen in the browser.\n     */\n    return value.constructor.name === 'File';\n  }\n  return false;\n}\n/**\n * @license MIT\n * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFunction.ts}\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * We're using this library in here instead of loading it from `form-data-encoder` because that\n * uses lookbehind regex in its main encoder that Safari doesn't support so it throws a fatal page\n * exception.\n *\n * @license MIT\n * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFormData.ts}\n */\nfunction isFormData(value) {\n  return value && isFunction(value.constructor) && value[Symbol.toStringTag] === 'FormData' && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator]);\n}\nfunction getFileFromSuppliedFiles(filename, files) {\n  if (filename in files) {\n    return files[filename];\n  } else if (decodeURIComponent(filename) in files) {\n    return files[decodeURIComponent(filename)];\n  }\n  return false;\n}\nfunction fetchHAR(har, opts) {\n  var _a;\n  if (opts === void 0) {\n    opts = {};\n  }\n  if (!har) throw new Error('Missing HAR definition');\n  if (!har.log || !har.log.entries || !har.log.entries.length) throw new Error('Missing log.entries array');\n  var request = har.log.entries[0].request;\n  var url = request.url;\n  var querystring = '';\n  var shouldSetDuplex = false;\n  var options = __assign(__assign({}, opts.init ? opts.init : {}), {\n    method: request.method\n  });\n  if (!options.headers) {\n    options.headers = new Headers();\n  } else if (typeof options.headers === 'object' && !(options.headers instanceof Headers) && options.headers !== null) {\n    options.headers = new Headers(options.headers);\n  }\n  var headers = options.headers;\n  if ('headers' in request && request.headers.length) {\n    // eslint-disable-next-line consistent-return\n    request.headers.forEach(function (header) {\n      try {\n        return headers.append(header.name, header.value);\n      } catch (err) {\n        /**\n         * `Headers.append()` will throw errors if the header name is not a legal HTTP header name,\n         * like `X-API-KEY (Header)`. If that happens instead of tossing the error back out, we\n         * should silently just ignore\n         * it.\n         */\n      }\n    });\n  }\n  if ('cookies' in request && request.cookies.length) {\n    /**\n     * As the browser fetch API can't set custom cookies for requests, they instead need to be\n     * defined on the document and passed into the request via `credentials: include`. Since this\n     * is a browser-specific quirk, that should only\n     * happen in browsers!\n     */\n    if (isBrowser()) {\n      request.cookies.forEach(function (cookie) {\n        document.cookie = \"\".concat(encodeURIComponent(cookie.name), \"=\").concat(encodeURIComponent(cookie.value));\n      });\n      options.credentials = 'include';\n    } else {\n      headers.append('cookie', request.cookies.map(function (cookie) {\n        return \"\".concat(encodeURIComponent(cookie.name), \"=\").concat(encodeURIComponent(cookie.value));\n      }).join('; '));\n    }\n  }\n  if ('postData' in request) {\n    if ('params' in request.postData) {\n      if (!('mimeType' in request.postData)) {\n        // @ts-expect-error HAR spec requires that `mimeType` is always present but it might not be.\n        request.postData.mimeType = 'application/octet-stream';\n      }\n      switch (request.postData.mimeType) {\n        case 'application/x-www-form-urlencoded':\n          /**\n           * Since the content we're handling here is to be encoded as\n           * `application/x-www-form-urlencoded`, this should override any other `Content-Type`\n           * headers that are present in the HAR. This is how Postman handles this case when\n           * building code snippets!\n           *\n           * @see {@link https://github.com/github/fetch/issues/263#issuecomment-209530977}\n           */\n          headers.set('Content-Type', request.postData.mimeType);\n          var encodedParams_1 = new URLSearchParams();\n          request.postData.params.forEach(function (param) {\n            return encodedParams_1.set(param.name, param.value);\n          });\n          options.body = encodedParams_1.toString();\n          break;\n        case 'multipart/alternative':\n        case 'multipart/form-data':\n        case 'multipart/mixed':\n        case 'multipart/related':\n          /**\n           * If there's a `Content-Type` header set we need to remove it. We're doing this because\n           * when we pass the form data object into `fetch` that'll set a proper `Content-Type`\n           * header for this request that also includes the boundary used on the content.\n           *\n           * If we don't do this, then consumers won't be able to parse out the payload because\n           * they won't know what the boundary to split on it.\n           */\n          if (headers.has('Content-Type')) {\n            headers[\"delete\"]('Content-Type');\n          }\n          var form_1 = new FormData();\n          if (!isFormData(form_1)) {\n            /**\n             * The `form-data` NPM module returns one of two things: a native `FormData` API or its\n             * own polyfill. Unfortunately this polyfill does not support the full API of the native\n             * FormData object so when you load `form-data` within a browser environment you'll\n             * have two major differences in API:\n             *\n             *  - The `.append()` API in `form-data` requires that the third argument is an object\n             *    containing various, undocumented, options. In the browser, `.append()`'s third\n             *    argument should only be present when the second is a `Blob` or `USVString`, and\n             *    when it is present, it should be a filename string.\n             *  - `form-data` does not expose an `.entries()` API, so the only way to retrieve data\n             *    out of it for construction of boundary-separated payload content is to use its\n             *    `.pipe()` API. Since the browser doesn't have this API, you'll be unable to\n             * retrieve data out of it.\n             *\n             * Now since the native `FormData` API is iterable, and has the `.entries()` iterator,\n             * we can easily detect if we have a native copy of the FormData API. It's for all of\n             * these reasons that we're opting to hard crash here because supporting this\n             * non-compliant API is more trouble than its worth.\n             *\n             * @see {@link https://github.com/form-data/form-data/issues/124}\n             */\n            throw new Error(\"We've detected you're using a non-spec compliant FormData library. We recommend polyfilling FormData with https://npm.im/formdata-node\");\n          }\n          request.postData.params.forEach(function (param) {\n            if ('fileName' in param) {\n              if (opts.files) {\n                var fileContents = getFileFromSuppliedFiles(param.fileName, opts.files);\n                if (fileContents) {\n                  // If the file we've got available to us is a Buffer then we need to convert it so\n                  // that the FormData API can use it.\n                  if (isBuffer(fileContents)) {\n                    form_1.append(param.name, new File([fileContents], param.fileName, {\n                      type: param.contentType || null\n                    }), param.fileName);\n                    return;\n                  } else if (isFile(fileContents)) {\n                    form_1.append(param.name, fileContents, param.fileName);\n                    return;\n                  }\n                  throw new TypeError('An unknown object has been supplied into the `files` config for use. We only support instances of the File API and Node Buffer objects.');\n                }\n              }\n              if ('value' in param) {\n                var paramBlob = void 0;\n                var parsed = (0, data_urls_1.parse)(param.value);\n                if (parsed) {\n                  // If we were able to parse out this data URL we don't need to transform its data\n                  // into a buffer for `Blob` because that supports data URLs already.\n                  paramBlob = new Blob([param.value], {\n                    type: parsed.contentType || param.contentType || null\n                  });\n                } else {\n                  paramBlob = new Blob([param.value], {\n                    type: param.contentType || null\n                  });\n                }\n                form_1.append(param.name, paramBlob, param.fileName);\n                return;\n              }\n              throw new Error(\"The supplied HAR has a postData parameter with `fileName`, but neither `value` content within the HAR or any file buffers were supplied with the `files` option. Since this library doesn't have access to the filesystem, it can't fetch that file.\");\n            }\n            form_1.append(param.name, param.value);\n          });\n          /**\n           * If a the `fetch` polyfill that's being used here doesn't have spec-compliant handling\n           * for the `FormData` API (like `node-fetch@2`), then you should pass in a handler (like\n           * the `form-data-encoder` library) to transform its contents into something that can be\n           * used with the `Request` object.\n           *\n           * @see {@link https://www.npmjs.com/package/formdata-node}\n           */\n          if (opts.multipartEncoder) {\n            // eslint-disable-next-line new-cap\n            var encoder_1 = new opts.multipartEncoder(form_1);\n            Object.keys(encoder_1.headers).forEach(function (header) {\n              headers.set(header, encoder_1.headers[header]);\n            });\n            // @ts-expect-error \"Property 'from' does not exist on type 'typeof Readable'.\" but it does!\n            options.body = readable_stream_1.Readable.from(encoder_1);\n            shouldSetDuplex = true;\n          } else {\n            options.body = form_1;\n          }\n          break;\n        default:\n          var formBody_1 = {};\n          request.postData.params.map(function (param) {\n            try {\n              formBody_1[param.name] = JSON.parse(param.value);\n            } catch (e) {\n              formBody_1[param.name] = param.value;\n            }\n            return true;\n          });\n          options.body = JSON.stringify(formBody_1);\n      }\n    } else if ((_a = request.postData.text) === null || _a === void 0 ? void 0 : _a.length) {\n      // If we've got `files` map content present, and this post data content contains a valid data\n      // URL then we can substitute the payload with that file instead of the using data URL.\n      if (opts.files) {\n        var parsed = (0, data_urls_1.parse)(request.postData.text);\n        if (parsed) {\n          if ((parsed === null || parsed === void 0 ? void 0 : parsed.name) && parsed.name in opts.files) {\n            var fileContents = getFileFromSuppliedFiles(parsed.name, opts.files);\n            if (fileContents) {\n              if (isBuffer(fileContents)) {\n                options.body = fileContents;\n              } else if (isFile(fileContents)) {\n                // `Readable.from` isn't available in browsers but the browser `Request` object can\n                // handle `File` objects just fine without us having to mold it into shape.\n                if (isBrowser()) {\n                  options.body = fileContents;\n                } else {\n                  // @ts-expect-error \"Property 'from' does not exist on type 'typeof Readable'.\" but it does!\n                  options.body = readable_stream_1.Readable.from(fileContents.stream());\n                  shouldSetDuplex = true;\n                  // Supplying a polyfilled `File` stream into `Request.body` doesn't automatically\n                  // add `Content-Length`.\n                  if (!headers.has('content-length')) {\n                    headers.set('content-length', String(fileContents.size));\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (typeof options.body === 'undefined') {\n        options.body = request.postData.text;\n      }\n    }\n    /**\n     * The fetch spec, which Node 18+ strictly abides by, now requires that `duplex` be sent with\n     * requests that have payloads.\n     *\n     * As `RequestInit#duplex` isn't supported by any browsers, or even mentioned on MDN, we aren't\n     * sending it in browser environments. This work is purely to support Node 18+ and `undici`\n     * environments.\n     *\n     * @see {@link https://github.com/nodejs/node/issues/46221}\n     * @see {@link https://github.com/whatwg/fetch/pull/1457}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request/Request}\n     */\n    if (shouldSetDuplex && !isBrowser()) {\n      options.duplex = 'half';\n    }\n  }\n  // We automaticaly assume that the HAR that we have already has query parameters encoded within\n  // it so we do **not** use the `URLSearchParams` API here for composing the query string.\n  var requestURL = url;\n  if ('queryString' in request && request.queryString.length) {\n    var urlObj = new URL(requestURL);\n    var queryParams_1 = Array.from(urlObj.searchParams).map(function (_a) {\n      var k = _a[0],\n        v = _a[1];\n      return \"\".concat(k, \"=\").concat(v);\n    });\n    request.queryString.forEach(function (q) {\n      queryParams_1.push(\"\".concat(q.name, \"=\").concat(q.value));\n    });\n    querystring = queryParams_1.join('&');\n    // Because anchor hashes before query strings will prevent query strings from being delivered\n    // we need to pop them off and re-add them after.\n    if (urlObj.hash) {\n      var urlWithoutHashes = requestURL.replace(urlObj.hash, '');\n      requestURL = \"\".concat(urlWithoutHashes.split('?')[0]).concat(querystring ? \"?\".concat(querystring) : '');\n      requestURL += urlObj.hash;\n    } else {\n      requestURL = \"\".concat(requestURL.split('?')[0]).concat(querystring ? \"?\".concat(querystring) : '');\n    }\n  }\n  if (opts.userAgent) {\n    headers.append('User-Agent', opts.userAgent);\n  }\n  options.headers = headers;\n  return fetch(requestURL, options);\n}\nexports[\"default\"] = fetchHAR;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","exports","__esModule","data_urls_1","require","readable_stream_1","globalThis","Blob","e","Error","File","FormData","isBrowser","window","document","isBuffer","value","Buffer","isFile","constructor","name","isFunction","isFormData","Symbol","toStringTag","append","getAll","entries","iterator","getFileFromSuppliedFiles","filename","files","decodeURIComponent","fetchHAR","har","opts","_a","log","request","url","querystring","shouldSetDuplex","options","init","method","headers","Headers","forEach","header","err","cookies","cookie","concat","encodeURIComponent","credentials","map","join","postData","mimeType","set","encodedParams_1","URLSearchParams","params","param","body","toString","has","form_1","fileContents","fileName","type","contentType","TypeError","paramBlob","parsed","parse","multipartEncoder","encoder_1","keys","Readable","from","formBody_1","JSON","stringify","text","stream","String","size","duplex","requestURL","queryString","urlObj","URL","queryParams_1","Array","searchParams","k","v","q","push","hash","urlWithoutHashes","replace","split","userAgent","fetch"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/fetch-har/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexports.__esModule = true;\nvar data_urls_1 = require(\"@readme/data-urls\");\nvar readable_stream_1 = require(\"readable-stream\");\nif (!globalThis.Blob) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies\n        globalThis.Blob = require('formdata-node').Blob;\n    }\n    catch (e) {\n        throw new Error('Since you do not have the Blob API available in this environment you must install the optional `formdata-node` dependency.');\n    }\n}\nif (!globalThis.File) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies\n        globalThis.File = require('formdata-node').File;\n    }\n    catch (e) {\n        throw new Error('Since you do not have the File API available in this environment you must install the optional `formdata-node` dependency.');\n    }\n}\nif (!globalThis.FormData) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies\n        globalThis.FormData = require('formdata-node').FormData;\n    }\n    catch (e) {\n        throw new Error('Since you do not have the FormData API available in this environment you must install the optional `formdata-node` dependency.');\n    }\n}\nfunction isBrowser() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction isBuffer(value) {\n    return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n}\nfunction isFile(value) {\n    if (value instanceof File) {\n        /**\n         * The `Blob` polyfill on Node comes back as being an instanceof `File`. Because passing a Blob\n         * into a File will end up with a corrupted file we want to prevent this.\n         *\n         * This object identity crisis does not happen in the browser.\n         */\n        return value.constructor.name === 'File';\n    }\n    return false;\n}\n/**\n * @license MIT\n * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFunction.ts}\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * We're using this library in here instead of loading it from `form-data-encoder` because that\n * uses lookbehind regex in its main encoder that Safari doesn't support so it throws a fatal page\n * exception.\n *\n * @license MIT\n * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFormData.ts}\n */\nfunction isFormData(value) {\n    return (value &&\n        isFunction(value.constructor) &&\n        value[Symbol.toStringTag] === 'FormData' &&\n        isFunction(value.append) &&\n        isFunction(value.getAll) &&\n        isFunction(value.entries) &&\n        isFunction(value[Symbol.iterator]));\n}\nfunction getFileFromSuppliedFiles(filename, files) {\n    if (filename in files) {\n        return files[filename];\n    }\n    else if (decodeURIComponent(filename) in files) {\n        return files[decodeURIComponent(filename)];\n    }\n    return false;\n}\nfunction fetchHAR(har, opts) {\n    var _a;\n    if (opts === void 0) { opts = {}; }\n    if (!har)\n        throw new Error('Missing HAR definition');\n    if (!har.log || !har.log.entries || !har.log.entries.length)\n        throw new Error('Missing log.entries array');\n    var request = har.log.entries[0].request;\n    var url = request.url;\n    var querystring = '';\n    var shouldSetDuplex = false;\n    var options = __assign(__assign({}, (opts.init ? opts.init : {})), { method: request.method });\n    if (!options.headers) {\n        options.headers = new Headers();\n    }\n    else if (typeof options.headers === 'object' && !(options.headers instanceof Headers) && options.headers !== null) {\n        options.headers = new Headers(options.headers);\n    }\n    var headers = options.headers;\n    if ('headers' in request && request.headers.length) {\n        // eslint-disable-next-line consistent-return\n        request.headers.forEach(function (header) {\n            try {\n                return headers.append(header.name, header.value);\n            }\n            catch (err) {\n                /**\n                 * `Headers.append()` will throw errors if the header name is not a legal HTTP header name,\n                 * like `X-API-KEY (Header)`. If that happens instead of tossing the error back out, we\n                 * should silently just ignore\n                 * it.\n                 */\n            }\n        });\n    }\n    if ('cookies' in request && request.cookies.length) {\n        /**\n         * As the browser fetch API can't set custom cookies for requests, they instead need to be\n         * defined on the document and passed into the request via `credentials: include`. Since this\n         * is a browser-specific quirk, that should only\n         * happen in browsers!\n         */\n        if (isBrowser()) {\n            request.cookies.forEach(function (cookie) {\n                document.cookie = \"\".concat(encodeURIComponent(cookie.name), \"=\").concat(encodeURIComponent(cookie.value));\n            });\n            options.credentials = 'include';\n        }\n        else {\n            headers.append('cookie', request.cookies\n                .map(function (cookie) { return \"\".concat(encodeURIComponent(cookie.name), \"=\").concat(encodeURIComponent(cookie.value)); })\n                .join('; '));\n        }\n    }\n    if ('postData' in request) {\n        if ('params' in request.postData) {\n            if (!('mimeType' in request.postData)) {\n                // @ts-expect-error HAR spec requires that `mimeType` is always present but it might not be.\n                request.postData.mimeType = 'application/octet-stream';\n            }\n            switch (request.postData.mimeType) {\n                case 'application/x-www-form-urlencoded':\n                    /**\n                     * Since the content we're handling here is to be encoded as\n                     * `application/x-www-form-urlencoded`, this should override any other `Content-Type`\n                     * headers that are present in the HAR. This is how Postman handles this case when\n                     * building code snippets!\n                     *\n                     * @see {@link https://github.com/github/fetch/issues/263#issuecomment-209530977}\n                     */\n                    headers.set('Content-Type', request.postData.mimeType);\n                    var encodedParams_1 = new URLSearchParams();\n                    request.postData.params.forEach(function (param) { return encodedParams_1.set(param.name, param.value); });\n                    options.body = encodedParams_1.toString();\n                    break;\n                case 'multipart/alternative':\n                case 'multipart/form-data':\n                case 'multipart/mixed':\n                case 'multipart/related':\n                    /**\n                     * If there's a `Content-Type` header set we need to remove it. We're doing this because\n                     * when we pass the form data object into `fetch` that'll set a proper `Content-Type`\n                     * header for this request that also includes the boundary used on the content.\n                     *\n                     * If we don't do this, then consumers won't be able to parse out the payload because\n                     * they won't know what the boundary to split on it.\n                     */\n                    if (headers.has('Content-Type')) {\n                        headers[\"delete\"]('Content-Type');\n                    }\n                    var form_1 = new FormData();\n                    if (!isFormData(form_1)) {\n                        /**\n                         * The `form-data` NPM module returns one of two things: a native `FormData` API or its\n                         * own polyfill. Unfortunately this polyfill does not support the full API of the native\n                         * FormData object so when you load `form-data` within a browser environment you'll\n                         * have two major differences in API:\n                         *\n                         *  - The `.append()` API in `form-data` requires that the third argument is an object\n                         *    containing various, undocumented, options. In the browser, `.append()`'s third\n                         *    argument should only be present when the second is a `Blob` or `USVString`, and\n                         *    when it is present, it should be a filename string.\n                         *  - `form-data` does not expose an `.entries()` API, so the only way to retrieve data\n                         *    out of it for construction of boundary-separated payload content is to use its\n                         *    `.pipe()` API. Since the browser doesn't have this API, you'll be unable to\n                         * retrieve data out of it.\n                         *\n                         * Now since the native `FormData` API is iterable, and has the `.entries()` iterator,\n                         * we can easily detect if we have a native copy of the FormData API. It's for all of\n                         * these reasons that we're opting to hard crash here because supporting this\n                         * non-compliant API is more trouble than its worth.\n                         *\n                         * @see {@link https://github.com/form-data/form-data/issues/124}\n                         */\n                        throw new Error(\"We've detected you're using a non-spec compliant FormData library. We recommend polyfilling FormData with https://npm.im/formdata-node\");\n                    }\n                    request.postData.params.forEach(function (param) {\n                        if ('fileName' in param) {\n                            if (opts.files) {\n                                var fileContents = getFileFromSuppliedFiles(param.fileName, opts.files);\n                                if (fileContents) {\n                                    // If the file we've got available to us is a Buffer then we need to convert it so\n                                    // that the FormData API can use it.\n                                    if (isBuffer(fileContents)) {\n                                        form_1.append(param.name, new File([fileContents], param.fileName, {\n                                            type: param.contentType || null\n                                        }), param.fileName);\n                                        return;\n                                    }\n                                    else if (isFile(fileContents)) {\n                                        form_1.append(param.name, fileContents, param.fileName);\n                                        return;\n                                    }\n                                    throw new TypeError('An unknown object has been supplied into the `files` config for use. We only support instances of the File API and Node Buffer objects.');\n                                }\n                            }\n                            if ('value' in param) {\n                                var paramBlob = void 0;\n                                var parsed = (0, data_urls_1.parse)(param.value);\n                                if (parsed) {\n                                    // If we were able to parse out this data URL we don't need to transform its data\n                                    // into a buffer for `Blob` because that supports data URLs already.\n                                    paramBlob = new Blob([param.value], { type: parsed.contentType || param.contentType || null });\n                                }\n                                else {\n                                    paramBlob = new Blob([param.value], { type: param.contentType || null });\n                                }\n                                form_1.append(param.name, paramBlob, param.fileName);\n                                return;\n                            }\n                            throw new Error(\"The supplied HAR has a postData parameter with `fileName`, but neither `value` content within the HAR or any file buffers were supplied with the `files` option. Since this library doesn't have access to the filesystem, it can't fetch that file.\");\n                        }\n                        form_1.append(param.name, param.value);\n                    });\n                    /**\n                     * If a the `fetch` polyfill that's being used here doesn't have spec-compliant handling\n                     * for the `FormData` API (like `node-fetch@2`), then you should pass in a handler (like\n                     * the `form-data-encoder` library) to transform its contents into something that can be\n                     * used with the `Request` object.\n                     *\n                     * @see {@link https://www.npmjs.com/package/formdata-node}\n                     */\n                    if (opts.multipartEncoder) {\n                        // eslint-disable-next-line new-cap\n                        var encoder_1 = new opts.multipartEncoder(form_1);\n                        Object.keys(encoder_1.headers).forEach(function (header) {\n                            headers.set(header, encoder_1.headers[header]);\n                        });\n                        // @ts-expect-error \"Property 'from' does not exist on type 'typeof Readable'.\" but it does!\n                        options.body = readable_stream_1.Readable.from(encoder_1);\n                        shouldSetDuplex = true;\n                    }\n                    else {\n                        options.body = form_1;\n                    }\n                    break;\n                default:\n                    var formBody_1 = {};\n                    request.postData.params.map(function (param) {\n                        try {\n                            formBody_1[param.name] = JSON.parse(param.value);\n                        }\n                        catch (e) {\n                            formBody_1[param.name] = param.value;\n                        }\n                        return true;\n                    });\n                    options.body = JSON.stringify(formBody_1);\n            }\n        }\n        else if ((_a = request.postData.text) === null || _a === void 0 ? void 0 : _a.length) {\n            // If we've got `files` map content present, and this post data content contains a valid data\n            // URL then we can substitute the payload with that file instead of the using data URL.\n            if (opts.files) {\n                var parsed = (0, data_urls_1.parse)(request.postData.text);\n                if (parsed) {\n                    if ((parsed === null || parsed === void 0 ? void 0 : parsed.name) && parsed.name in opts.files) {\n                        var fileContents = getFileFromSuppliedFiles(parsed.name, opts.files);\n                        if (fileContents) {\n                            if (isBuffer(fileContents)) {\n                                options.body = fileContents;\n                            }\n                            else if (isFile(fileContents)) {\n                                // `Readable.from` isn't available in browsers but the browser `Request` object can\n                                // handle `File` objects just fine without us having to mold it into shape.\n                                if (isBrowser()) {\n                                    options.body = fileContents;\n                                }\n                                else {\n                                    // @ts-expect-error \"Property 'from' does not exist on type 'typeof Readable'.\" but it does!\n                                    options.body = readable_stream_1.Readable.from(fileContents.stream());\n                                    shouldSetDuplex = true;\n                                    // Supplying a polyfilled `File` stream into `Request.body` doesn't automatically\n                                    // add `Content-Length`.\n                                    if (!headers.has('content-length')) {\n                                        headers.set('content-length', String(fileContents.size));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (typeof options.body === 'undefined') {\n                options.body = request.postData.text;\n            }\n        }\n        /**\n         * The fetch spec, which Node 18+ strictly abides by, now requires that `duplex` be sent with\n         * requests that have payloads.\n         *\n         * As `RequestInit#duplex` isn't supported by any browsers, or even mentioned on MDN, we aren't\n         * sending it in browser environments. This work is purely to support Node 18+ and `undici`\n         * environments.\n         *\n         * @see {@link https://github.com/nodejs/node/issues/46221}\n         * @see {@link https://github.com/whatwg/fetch/pull/1457}\n         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request/Request}\n         */\n        if (shouldSetDuplex && !isBrowser()) {\n            options.duplex = 'half';\n        }\n    }\n    // We automaticaly assume that the HAR that we have already has query parameters encoded within\n    // it so we do **not** use the `URLSearchParams` API here for composing the query string.\n    var requestURL = url;\n    if ('queryString' in request && request.queryString.length) {\n        var urlObj = new URL(requestURL);\n        var queryParams_1 = Array.from(urlObj.searchParams).map(function (_a) {\n            var k = _a[0], v = _a[1];\n            return \"\".concat(k, \"=\").concat(v);\n        });\n        request.queryString.forEach(function (q) {\n            queryParams_1.push(\"\".concat(q.name, \"=\").concat(q.value));\n        });\n        querystring = queryParams_1.join('&');\n        // Because anchor hashes before query strings will prevent query strings from being delivered\n        // we need to pop them off and re-add them after.\n        if (urlObj.hash) {\n            var urlWithoutHashes = requestURL.replace(urlObj.hash, '');\n            requestURL = \"\".concat(urlWithoutHashes.split('?')[0]).concat(querystring ? \"?\".concat(querystring) : '');\n            requestURL += urlObj.hash;\n        }\n        else {\n            requestURL = \"\".concat(requestURL.split('?')[0]).concat(querystring ? \"?\".concat(querystring) : '');\n        }\n    }\n    if (opts.userAgent) {\n        headers.append('User-Agent', opts.userAgent);\n    }\n    options.headers = headers;\n    return fetch(requestURL, options);\n}\nexports[\"default\"] = fetchHAR;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}