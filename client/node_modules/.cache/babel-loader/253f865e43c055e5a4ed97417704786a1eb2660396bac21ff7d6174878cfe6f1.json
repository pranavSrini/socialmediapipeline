{"ast":null,"code":"const compare = require('json-schema-compare');\nconst forEach = require('lodash/forEach');\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n} = require('../common');\nfunction removeFalseSchemas(target) {\n  forEach(target, function (schema, prop) {\n    if (schema === false) {\n      delete target[prop];\n    }\n  });\n}\nfunction mergeSchemaGroup(group, mergeSchemas) {\n  const allKeys = allUniqueKeys(group);\n  return allKeys.reduce(function (all, key) {\n    const schemas = getValues(group, key);\n    const compacted = uniqWith(schemas.filter(notUndefined), compare);\n    all[key] = mergeSchemas(compacted, key);\n    return all;\n  }, {});\n}\nmodule.exports = {\n  keywords: ['properties', 'patternProperties', 'additionalProperties'],\n  resolver(values, parents, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function (subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema);\n        const ownKeys = keys(subSchema.properties);\n        const ownPatternKeys = keys(subSchema.patternProperties);\n        const ownPatterns = ownPatternKeys.map(k => new RegExp(k));\n        otherSubSchemas.forEach(function (other) {\n          const allOtherKeys = keys(other.properties);\n          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)));\n          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);\n          additionalKeys.forEach(function (key) {\n            other.properties[key] = mergers.properties([other.properties[key], subSchema.additionalProperties], key);\n          });\n        });\n      });\n\n      // remove disallowed patternProperties\n      values.forEach(function (subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema);\n        const ownPatternKeys = keys(subSchema.patternProperties);\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function (other) {\n            const allOtherPatterns = keys(other.patternProperties);\n            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key]);\n          });\n        }\n      });\n    }\n    const returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    };\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties);\n    }\n    return deleteUndefinedProps(returnObject);\n  }\n};","map":{"version":3,"names":["compare","require","forEach","allUniqueKeys","deleteUndefinedProps","getValues","keys","notUndefined","uniqWith","withoutArr","removeFalseSchemas","target","schema","prop","mergeSchemaGroup","group","mergeSchemas","allKeys","reduce","all","key","schemas","compacted","filter","module","exports","keywords","resolver","values","parents","mergers","options","ignoreAdditionalProperties","subSchema","otherSubSchemas","s","ownKeys","properties","ownPatternKeys","patternProperties","ownPatterns","map","k","RegExp","other","allOtherKeys","keysMatchingPattern","some","pk","test","additionalKeys","additionalProperties","allOtherPatterns","additionalPatternKeys","returnObject"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"],"sourcesContent":["\nconst compare = require('json-schema-compare')\nconst forEach = require('lodash/forEach')\nconst {\n  allUniqueKeys,\n  deleteUndefinedProps,\n  getValues,\n  keys,\n  notUndefined,\n  uniqWith,\n  withoutArr\n} = require('../common')\n\nfunction removeFalseSchemas(target) {\n  forEach(target, function(schema, prop) {\n    if (schema === false) {\n      delete target[prop]\n    }\n  })\n}\n\nfunction mergeSchemaGroup(group, mergeSchemas) {\n  const allKeys = allUniqueKeys(group)\n  return allKeys.reduce(function(all, key) {\n    const schemas = getValues(group, key)\n    const compacted = uniqWith(schemas.filter(notUndefined), compare)\n    all[key] = mergeSchemas(compacted, key)\n    return all\n  }, {})\n}\n\nmodule.exports = {\n  keywords: ['properties', 'patternProperties', 'additionalProperties'],\n  resolver(values, parents, mergers, options) {\n    // first get rid of all non permitted properties\n    if (!options.ignoreAdditionalProperties) {\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownKeys = keys(subSchema.properties)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        const ownPatterns = ownPatternKeys.map(k => new RegExp(k))\n        otherSubSchemas.forEach(function(other) {\n          const allOtherKeys = keys(other.properties)\n          const keysMatchingPattern = allOtherKeys.filter(k => ownPatterns.some(pk => pk.test(k)))\n          const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)\n          additionalKeys.forEach(function(key) {\n            other.properties[key] = mergers.properties([\n              other.properties[key], subSchema.additionalProperties\n            ], key)\n          })\n        })\n      })\n\n      // remove disallowed patternProperties\n      values.forEach(function(subSchema) {\n        const otherSubSchemas = values.filter(s => s !== subSchema)\n        const ownPatternKeys = keys(subSchema.patternProperties)\n        if (subSchema.additionalProperties === false) {\n          otherSubSchemas.forEach(function(other) {\n            const allOtherPatterns = keys(other.patternProperties)\n            const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)\n            additionalPatternKeys.forEach(key => delete other.patternProperties[key])\n          })\n        }\n      })\n    }\n\n    const returnObject = {\n      additionalProperties: mergers.additionalProperties(values.map(s => s.additionalProperties)),\n      patternProperties: mergeSchemaGroup(values.map(s => s.patternProperties), mergers.patternProperties),\n      properties: mergeSchemaGroup(values.map(s => s.properties), mergers.properties)\n    }\n\n    if (returnObject.additionalProperties === false) {\n      removeFalseSchemas(returnObject.properties)\n    }\n\n    return deleteUndefinedProps(returnObject)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}