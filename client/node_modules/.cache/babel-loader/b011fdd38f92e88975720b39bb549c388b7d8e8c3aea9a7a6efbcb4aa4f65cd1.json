{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nexports.isPrimitive = exports.getSchemaVersionString = void 0;\nvar json_schema_merge_allof_1 = __importDefault(require(\"json-schema-merge-allof\"));\nvar jsonpointer_1 = __importDefault(require(\"jsonpointer\"));\nvar RMOAS = __importStar(require(\"../rmoas.types\"));\n/**\n * This list has been pulled from `openapi-schema-to-json-schema` but been slightly modified to fit\n * within the constraints in which ReadMe uses the output from this library in schema form\n * rendering as while properties like `readOnly` aren't represented within JSON Schema, we support\n * it within that library's handling of OpenAPI-friendly JSON Schema.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/master/index.js#L23-L27}\n */\nvar UNSUPPORTED_SCHEMA_PROPS = ['nullable',\n// 'discriminator',\n// 'readOnly',\n// 'writeOnly',\n'xml', 'externalDocs', 'example' // OpenAPI supports `example`, but we're mapping it to `examples` below.\n// 'deprecated',\n];\n/**\n * List partially sourced from `openapi-schema-to-json-schema`.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/master/lib/converters/schema.js#L140-L154}\n */\nvar FORMAT_OPTIONS = {\n  INT8_MIN: 0 - Math.pow(2, 7),\n  INT8_MAX: Math.pow(2, 7) - 1,\n  INT16_MIN: 0 - Math.pow(2, 15),\n  INT16_MAX: Math.pow(2, 15) - 1,\n  INT32_MIN: 0 - Math.pow(2, 31),\n  INT32_MAX: Math.pow(2, 31) - 1,\n  INT64_MIN: 0 - Math.pow(2, 63),\n  INT64_MAX: Math.pow(2, 63) - 1,\n  UINT8_MIN: 0,\n  UINT8_MAX: Math.pow(2, 8) - 1,\n  UINT16_MIN: 0,\n  UINT16_MAX: Math.pow(2, 16) - 1,\n  UINT32_MIN: 0,\n  UINT32_MAX: Math.pow(2, 32) - 1,\n  UINT64_MIN: 0,\n  UINT64_MAX: Math.pow(2, 64) - 1,\n  FLOAT_MIN: 0 - Math.pow(2, 128),\n  FLOAT_MAX: Math.pow(2, 128) - 1,\n  DOUBLE_MIN: 0 - Number.MAX_VALUE,\n  DOUBLE_MAX: Number.MAX_VALUE\n};\n/**\n * Encode a string to be used as a JSON pointer.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param str String to encode into string that can be used as a JSON pointer.\n */\nfunction encodePointer(str) {\n  return str.replace('~', '~0').replace('/', '~1');\n}\nfunction getSchemaVersionString(schema, api) {\n  // If we're not on version 3.1.0, we always fall back to the default schema version for pre-3.1.0.\n  if (!RMOAS.isOAS31(api)) {\n    // This should remain as an HTTP url, not HTTPS.\n    return 'http://json-schema.org/draft-04/schema#';\n  }\n  /**\n   * If the schema indicates the version, prefer that.\n   *\n   * We use `as` here because the schema *should* be an OAS 3.1 schema due to the `isOAS31` check\n   * above.\n   */\n  if (schema.$schema) {\n    return schema.$schema;\n  }\n  // If the user defined a global schema version on their OAS document, prefer that.\n  if (api.jsonSchemaDialect) {\n    return api.jsonSchemaDialect;\n  }\n  return 'https://json-schema.org/draft/2020-12/schema#';\n}\nexports.getSchemaVersionString = getSchemaVersionString;\nfunction isPrimitive(val) {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\nexports.isPrimitive = isPrimitive;\nfunction isPolymorphicSchema(schema) {\n  return 'allOf' in schema || 'anyOf' in schema || 'oneOf' in schema;\n}\nfunction isRequestBodySchema(schema) {\n  return 'content' in schema;\n}\n/**\n * Given a JSON pointer and an array of examples do a reverse search through them until we find the\n * JSON pointer, or part of it, within the array.\n *\n * This function will allow you to take a pointer like `/tags/name` and return back `buster` from\n * the following array:\n *\n * ```\n *  [\n *    {\n *      example: {id: 20}\n *    },\n *    {\n *      examples: {\n *        distinctName: {\n *          tags: {name: 'buster'}\n *        }\n *      }\n *    }\n *  ]\n * ```\n *\n * As with most things however, this is not without its quirks! If a deeply nested property shares\n * the same name as an example that's further up the stack (like `tags.id` and an example for `id`),\n * there's a chance that it'll be misidentified as having an example and receive the wrong value.\n *\n * That said, any example is usually better than no example though, so while it's quirky behavior\n * it shouldn't raise immediate cause for alarm.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param pointer JSON pointer to search for an example for.\n * @param examples Array of previous schemas we've found relating to this pointer.\n */\nfunction searchForExampleByPointer(pointer, examples) {\n  if (examples === void 0) {\n    examples = [];\n  }\n  if (!examples.length || !pointer.length) {\n    return undefined;\n  }\n  var locSplit = pointer.split('/').filter(Boolean).reverse();\n  var pointers = [];\n  var point = '';\n  for (var i = 0; i < locSplit.length; i += 1) {\n    point = \"/\".concat(locSplit[i]).concat(point);\n    pointers.push(point);\n  }\n  var example;\n  var rev = __spreadArray([], examples, true).reverse();\n  for (var i = 0; i < pointers.length; i += 1) {\n    for (var ii = 0; ii < rev.length; ii += 1) {\n      var schema = rev[ii];\n      if ('example' in schema) {\n        schema = schema.example;\n      } else {\n        if (!Array.isArray(schema.examples) || !schema.examples.length) {\n          continue;\n        }\n        // Prevent us from crashing if `examples` is a completely empty object.\n        schema = schema.examples.shift();\n      }\n      try {\n        example = jsonpointer_1[\"default\"].get(schema, pointers[i]);\n      } catch (err) {\n        // If the schema we're looking at is `{obj: null}` and our pointer if `/obj/propertyName`\n        // jsonpointer will throw an error. If that happens, we should silently catch and toss it\n        // and return no example.\n      }\n      if (example !== undefined) {\n        break;\n      }\n    }\n    if (example !== undefined) {\n      break;\n    }\n  }\n  return example;\n}\n/**\n * Given an OpenAPI-flavored JSON Schema, make an effort to modify it so it's shaped more towards\n * stock JSON Schema.\n *\n * Why do this?\n *\n *  1. OpenAPI 3.0.x supports its own flavor of JSON Schema that isn't fully compatible with most\n *    JSON Schema tooling (like `@readme/oas-form` or `@rjsf/core`).\n *  2. While validating an OpenAPI definition will prevent corrupted or improper schemas from\n *    occuring, we have a lot of legacy schemas in ReadMe that were ingested before we had proper\n *    validation in place, and as a result have some API definitions that will not pass validation\n *    right now. In addition to reshaping OAS-JSON Schema into JSON Schema this library will also\n *    fix these improper schemas: things like `type: object` having `items` instead of `properties`,\n *    or `type: array` missing `items`.\n *  3. To ease the burden of polymorphic handling on our form rendering engine we make an attempt\n *    to merge `allOf` schemas here.\n *  4. Additionally due to OpenAPI 3.0.x not supporting JSON Schema, in order to support the\n *    `example` keyword that OAS supports, we need to do some work in here to remap it into\n *    `examples`. However, since all we care about in respect to examples for usage within\n *    `@readme/oas-form`, we're only retaining primitives. This *slightly* deviates from JSON\n *    Schema in that JSON Schema allows for any schema to be an example, but since\n *    `@readme/oas-form` can only actually **render** primitives, that's what we're retaining.\n *  5. Though OpenAPI 3.1 does support full JSON Schema, this library should be able to handle it\n *    without any problems.\n *\n * And why use this over `@openapi-contrib/openapi-schema-to-json-schema`? Fortunately and\n * unfortunately we've got a lot of API definitions in our database that aren't currently valid so\n * we need to have a lot of bespoke handling for odd quirks, typos, and missing declarations that\n * might be present.\n *\n * @todo add support for `schema: false` and `not` cases.\n * @see {@link https://json-schema.org/draft/2019-09/json-schema-validation.html}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schemaObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schemaObject}\n * @param data OpenAPI Schema Object to convert to pure JSON Schema.\n */\nfunction toJSONSchema(data, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var schema = data === true ? {} : __assign({}, data);\n  var schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;\n  var _a = __assign({\n      addEnumsToDescriptions: false,\n      currentLocation: '',\n      globalDefaults: {},\n      isPolymorphicAllOfChild: false,\n      prevSchemas: [],\n      refLogger: function () {\n        return true;\n      },\n      transformer: function (s) {\n        return s;\n      }\n    }, opts),\n    addEnumsToDescriptions = _a.addEnumsToDescriptions,\n    currentLocation = _a.currentLocation,\n    globalDefaults = _a.globalDefaults,\n    isPolymorphicAllOfChild = _a.isPolymorphicAllOfChild,\n    prevSchemas = _a.prevSchemas,\n    refLogger = _a.refLogger,\n    transformer = _a.transformer;\n  // If this schema contains a `$ref`, it's circular and we shouldn't try to resolve it. Just\n  // return and move along.\n  if (RMOAS.isRef(schema)) {\n    refLogger(schema.$ref, 'ref');\n    return transformer({\n      $ref: schema.$ref\n    });\n  }\n  // If we don't have a set type, but are dealing with an `anyOf`, `oneOf`, or `allOf`\n  // representation let's run through them and make sure they're good.\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    // If this is an `allOf` schema we should make an attempt to merge so as to ease the burden on\n    // the tooling that ingests these schemas.\n    if ('allOf' in schema && Array.isArray(schema.allOf)) {\n      try {\n        schema = (0, json_schema_merge_allof_1[\"default\"])(schema, {\n          ignoreAdditionalProperties: true,\n          resolvers: {\n            // JSON Schema ony supports examples with the `examples` property, since we're\n            // ingesting OpenAPI definitions we need to add a custom resolver for its `example`\n            // property.\n            example: function (obj) {\n              return obj[0];\n            },\n            // JSON Schema has no support for `format` on anything other than `string`, but since\n            // OpenAPI has it on `integer` and `number` we need to add a custom resolver here so we\n            // can still merge schemas that may have those.\n            format: function (obj) {\n              return obj[0];\n            },\n            // Since JSON Schema obviously doesn't know about our vendor extension we need to tell\n            // the library to essentially ignore and pass it along.\n            'x-readme-ref-name': function (obj) {\n              return obj[0];\n            }\n          }\n        });\n      } catch (e) {\n        // If we can't merge the `allOf` for whatever reason (like if one item is a `string` and\n        // the other is a `object`) then we should completely remove it from the schema and continue\n        // with whatever we've got. Why? If we don't, any tooling that's ingesting this will need\n        // to account for the incompatible `allOf` and it may be subject to more breakages than\n        // just not having it present would be.\n        var schemaWithoutAllOf = __rest(schema, []);\n        schema = schemaWithoutAllOf;\n        delete schema.allOf;\n      }\n    }\n    ['anyOf', 'oneOf'].forEach(function (polyType) {\n      if (polyType in schema && Array.isArray(schema[polyType])) {\n        schema[polyType].forEach(function (item, idx) {\n          var polyOptions = {\n            addEnumsToDescriptions: addEnumsToDescriptions,\n            currentLocation: \"\".concat(currentLocation, \"/\").concat(idx),\n            globalDefaults: globalDefaults,\n            isPolymorphicAllOfChild: false,\n            prevSchemas: prevSchemas,\n            refLogger: refLogger,\n            transformer: transformer\n          };\n          // When `properties` or `items` are present alongside a polymorphic schema instead of\n          // letting whatever JSON Schema interpreter is handling these constructed schemas we can\n          // guide its hand a bit by manually transforming it into an inferred `allOf` of the\n          // `properties` + the polymorph schema.\n          //\n          // This `allOf` schema will be merged together when fed through `toJSONSchema`.\n          if ('properties' in schema) {\n            schema[polyType][idx] = toJSONSchema({\n              allOf: [item, {\n                properties: schema.properties\n              }]\n            }, polyOptions);\n          } else if ('items' in schema) {\n            schema[polyType][idx] = toJSONSchema({\n              allOf: [item, {\n                items: schema.items\n              }]\n            }, polyOptions);\n          } else {\n            schema[polyType][idx] = toJSONSchema(item, polyOptions);\n          }\n        });\n      }\n    });\n    if ('discriminator' in schema) {\n      if ('mapping' in schema.discriminator && typeof schema.discriminator.mapping === 'object') {\n        // Discriminator mappings aren't written as traditional `$ref` pointers so in order to log\n        // them to the supplied `refLogger`.\n        var mapping_1 = schema.discriminator.mapping;\n        Object.keys(mapping_1).forEach(function (k) {\n          refLogger(mapping_1[k], 'discriminator');\n        });\n      }\n    }\n  }\n  // If this schema is malformed for some reason, let's do our best to repair it.\n  if (!('type' in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {\n    if ('properties' in schema) {\n      schema.type = 'object';\n    } else if ('items' in schema) {\n      schema.type = 'array';\n    } else {\n      // If there's still no `type` on the schema we should leave it alone because we don't have a\n      // great way to know if it's part of a nested schema that should, and couldn't be merged,\n      // into another, or it's just purely malformed.\n      //\n      // Whatever tooling that ingests the generated schema should handle it however it needs to.\n    }\n  }\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    // JSON Schema doesn't support OpenAPI-style examples so we need to reshape them a bit.\n    if ('example' in schema) {\n      // Only bother adding primitive examples.\n      if (isPrimitive(schema.example)) {\n        schema.examples = [schema.example];\n      } else if (Array.isArray(schema.example)) {\n        schema.examples = schema.example.filter(function (example) {\n          return isPrimitive(example);\n        });\n        if (!schema.examples.length) {\n          delete schema.examples;\n        }\n      } else {\n        prevSchemas.push({\n          example: schema.example\n        });\n      }\n      delete schema.example;\n    } else if ('examples' in schema) {\n      var reshapedExamples_1 = false;\n      if (typeof schema.examples === 'object' && !Array.isArray(schema.examples)) {\n        var examples_1 = [];\n        Object.keys(schema.examples).forEach(function (name) {\n          var example = schema.examples[name];\n          if ('$ref' in example) {\n            // no-op because any `$ref` example here after dereferencing is circular so we should\n            // ignore it\n            refLogger(example.$ref, 'ref');\n          } else if ('value' in example) {\n            if (isPrimitive(example.value)) {\n              examples_1.push(example.value);\n              reshapedExamples_1 = true;\n            } else if (Array.isArray(example.value) && isPrimitive(example.value[0])) {\n              examples_1.push(example.value[0]);\n              reshapedExamples_1 = true;\n            } else {\n              // If this example is neither a primitive or an array we should dump it into the\n              // `prevSchemas` array because we might be able to extract an example from it further\n              // downstream.\n              prevSchemas.push({\n                example: example.value\n              });\n            }\n          }\n        });\n        if (examples_1.length) {\n          reshapedExamples_1 = true;\n          schema.examples = examples_1;\n        }\n      } else if (Array.isArray(schema.examples) && isPrimitive(schema.examples[0])) {\n        // We haven't reshaped `examples` here, but since it's in a state that's preferrable to us\n        // let's keep it around.\n        reshapedExamples_1 = true;\n      }\n      if (!reshapedExamples_1) {\n        delete schema.examples;\n      }\n    }\n    // If we didn't have any immediately defined examples, let's search backwards and see if we can\n    // find one. But as we're only looking for primitive example, only try to search for one if\n    // we're dealing with a primitive schema.\n    if (schema.type !== 'array' && schema.type !== 'object' && !schema.examples) {\n      var foundExample = searchForExampleByPointer(currentLocation, prevSchemas);\n      if (foundExample) {\n        // We can only really deal with primitives, so only promote those as the found example if\n        // it is.\n        if (isPrimitive(foundExample) || Array.isArray(foundExample) && isPrimitive(foundExample[0])) {\n          schema.examples = [foundExample];\n        }\n      }\n    }\n    if (schema.type === 'array') {\n      if ('items' in schema) {\n        if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {\n          // `items` contains a `$ref`, so since it's circular we should do a no-op here and log\n          // and ignore it.\n          refLogger(schema.items.$ref, 'ref');\n        } else if (schema.items !== true) {\n          // Run through the arrays contents and clean them up.\n          schema.items = toJSONSchema(schema.items, {\n            addEnumsToDescriptions: addEnumsToDescriptions,\n            currentLocation: \"\".concat(currentLocation, \"/0\"),\n            globalDefaults: globalDefaults,\n            prevSchemas: prevSchemas,\n            refLogger: refLogger,\n            transformer: transformer\n          });\n        }\n      } else if ('properties' in schema || 'additionalProperties' in schema) {\n        // This is a fix to handle cases where someone may have typod `items` as `properties` on an\n        // array. Since throwing a complete failure isn't ideal, we can see that they meant for the\n        // type to be `object`, so we can do our best to shape the data into what they were\n        // intending it to be.\n        // README-6R\n        schema.type = 'object';\n      } else {\n        // This is a fix to handle cases where we have a malformed array with no `items` property\n        // present.\n        // README-8E\n        schema.items = {};\n      }\n    } else if (schema.type === 'object') {\n      if ('properties' in schema) {\n        Object.keys(schema.properties).forEach(function (prop) {\n          if (Array.isArray(schema.properties[prop]) || typeof schema.properties[prop] === 'object' && schema.properties[prop] !== null) {\n            schema.properties[prop] = toJSONSchema(schema.properties[prop], {\n              addEnumsToDescriptions: addEnumsToDescriptions,\n              currentLocation: \"\".concat(currentLocation, \"/\").concat(encodePointer(prop)),\n              globalDefaults: globalDefaults,\n              prevSchemas: prevSchemas,\n              refLogger: refLogger,\n              transformer: transformer\n            });\n          }\n        });\n      }\n      if (typeof schemaAdditionalProperties === 'object' && schemaAdditionalProperties !== null) {\n        // If this `additionalProperties` is completely empty and devoid of any sort of schema,\n        // treat it as such. Otherwise let's recurse into it and see if we can sort it out.\n        if (!('type' in schemaAdditionalProperties) && !('$ref' in schemaAdditionalProperties) &&\n        // We know it will be a schema object because it's dereferenced\n        !isPolymorphicSchema(schemaAdditionalProperties)) {\n          schema.additionalProperties = true;\n        } else {\n          // We know it will be a schema object because it's dereferenced\n          schema.additionalProperties = toJSONSchema(schemaAdditionalProperties, {\n            addEnumsToDescriptions: addEnumsToDescriptions,\n            currentLocation: currentLocation,\n            globalDefaults: globalDefaults,\n            prevSchemas: prevSchemas,\n            refLogger: refLogger,\n            transformer: transformer\n          });\n        }\n      }\n      // Since neither `properties` and `additionalProperties` are actually required to be present\n      // on an object, since we construct this schema work to build up a form we still need\n      // *something* for the user to enter in for this object so we'll add back in\n      // `additionalProperties` for that.\n      if (!isPolymorphicSchema(schema) && !('properties' in schema) && !('additionalProperties' in schema)) {\n        schema.additionalProperties = true;\n      }\n    }\n  }\n  // Ensure that number schemas formats have properly constrained min/max attributes according to\n  // whatever type of `format` and `type` they adhere to.\n  if ('format' in schema) {\n    var formatUpper = schema.format.toUpperCase();\n    if (\"\".concat(formatUpper, \"_MIN\") in FORMAT_OPTIONS) {\n      if (!schema.minimum && schema.minimum !== 0 || schema.minimum < FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")]) {\n        schema.minimum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")];\n      }\n    }\n    if (\"\".concat(formatUpper, \"_MAX\") in FORMAT_OPTIONS) {\n      if (!schema.maximum && schema.maximum !== 0 || schema.maximum > FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")]) {\n        schema.maximum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")];\n      }\n    }\n  }\n  /**\n   * Users can pass in parameter defaults via JWT User Data. We're checking to see if the defaults\n   * being passed in exist on endpoints via jsonpointer\n   *\n   * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n   */\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && globalDefaults && Object.keys(globalDefaults).length > 0 && currentLocation) {\n    try {\n      var userJwtDefault = jsonpointer_1[\"default\"].get(globalDefaults, currentLocation);\n      if (userJwtDefault) {\n        schema[\"default\"] = userJwtDefault;\n      }\n    } catch (err) {\n      // If jsonpointer returns an error, we won't show any defaults for that path.\n    }\n  }\n  // Only add a default value if we actually have one.\n  if ('default' in schema && typeof schema[\"default\"] !== 'undefined') {\n    if ('allowEmptyValue' in schema && schema.allowEmptyValue && schema[\"default\"] === '' || schema[\"default\"] !== '') {\n      // If we have `allowEmptyValue` present, and the default is actually an empty string, let it\n      // through as it's allowed.\n    } else {\n      // If the default is empty and we don't want to allowEmptyValue, we need to remove the\n      // default.\n      delete schema[\"default\"];\n    }\n  }\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && 'enum' in schema && Array.isArray(schema[\"enum\"])) {\n    // Enums should not have duplicated items as those will break AJV validation.\n    // If we ever target ES6 for typescript we can drop this array.from.\n    // https://stackoverflow.com/questions/33464504/using-spread-syntax-and-new-set-with-typescript/56870548\n    schema[\"enum\"] = Array.from(new Set(schema[\"enum\"]));\n    // If we want to add enums to descriptions (like in the case of response JSON Schema)\n    // generation we need to convert them into a list of Markdown tilda'd strings. We're also\n    // filtering away empty and falsy strings here because adding empty `` blocks to the description\n    // will serve nobody any good.\n    if (addEnumsToDescriptions) {\n      var enums = schema[\"enum\"].filter(Boolean).map(function (str) {\n        return \"`\".concat(str, \"`\");\n      }).join(' ');\n      if (enums.length) {\n        if ('description' in schema) {\n          schema.description += \"\\n\\n\".concat(enums);\n        } else {\n          schema.description = enums;\n        }\n      }\n    }\n  }\n  // Clean up any remaining `items` or `properties` schema fragments lying around if there's also\n  // polymorphism present.\n  if ('anyOf' in schema || 'oneOf' in schema) {\n    if ('properties' in schema) {\n      delete schema.properties;\n    }\n    if ('items' in schema) {\n      delete schema.items;\n    }\n  }\n  // Remove unsupported JSON Schema props.\n  for (var i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {\n    // Using the as here because the purpose is to delete keys we don't expect, so of course the\n    // typing won't work\n    delete schema[UNSUPPORTED_SCHEMA_PROPS[i]];\n  }\n  return transformer(schema);\n}\nexports[\"default\"] = toJSONSchema;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__spreadArray","to","from","pack","l","ar","Array","slice","concat","__importDefault","exports","isPrimitive","getSchemaVersionString","json_schema_merge_allof_1","require","jsonpointer_1","RMOAS","UNSUPPORTED_SCHEMA_PROPS","FORMAT_OPTIONS","INT8_MIN","Math","pow","INT8_MAX","INT16_MIN","INT16_MAX","INT32_MIN","INT32_MAX","INT64_MIN","INT64_MAX","UINT8_MIN","UINT8_MAX","UINT16_MIN","UINT16_MAX","UINT32_MIN","UINT32_MAX","UINT64_MIN","UINT64_MAX","FLOAT_MIN","FLOAT_MAX","DOUBLE_MIN","Number","MAX_VALUE","DOUBLE_MAX","encodePointer","str","replace","schema","api","isOAS31","$schema","jsonSchemaDialect","val","isPolymorphicSchema","isRequestBodySchema","searchForExampleByPointer","pointer","examples","locSplit","split","filter","Boolean","reverse","pointers","point","push","example","rev","ii","isArray","shift","err","toJSONSchema","data","opts","schemaAdditionalProperties","isSchema","additionalProperties","_a","addEnumsToDescriptions","currentLocation","globalDefaults","isPolymorphicAllOfChild","prevSchemas","refLogger","transformer","isRef","$ref","allOf","ignoreAdditionalProperties","resolvers","obj","format","x-readme-ref-name","schemaWithoutAllOf","forEach","polyType","item","idx","polyOptions","properties","items","discriminator","mapping","mapping_1","keys","type","reshapedExamples_1","examples_1","name","foundExample","prop","formatUpper","toUpperCase","minimum","maximum","userJwtDefault","allowEmptyValue","Set","enums","map","join","description"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/oas/dist/lib/openapi-to-json-schema.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nexports.isPrimitive = exports.getSchemaVersionString = void 0;\nvar json_schema_merge_allof_1 = __importDefault(require(\"json-schema-merge-allof\"));\nvar jsonpointer_1 = __importDefault(require(\"jsonpointer\"));\nvar RMOAS = __importStar(require(\"../rmoas.types\"));\n/**\n * This list has been pulled from `openapi-schema-to-json-schema` but been slightly modified to fit\n * within the constraints in which ReadMe uses the output from this library in schema form\n * rendering as while properties like `readOnly` aren't represented within JSON Schema, we support\n * it within that library's handling of OpenAPI-friendly JSON Schema.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/master/index.js#L23-L27}\n */\nvar UNSUPPORTED_SCHEMA_PROPS = [\n    'nullable',\n    // 'discriminator',\n    // 'readOnly',\n    // 'writeOnly',\n    'xml',\n    'externalDocs',\n    'example', // OpenAPI supports `example`, but we're mapping it to `examples` below.\n    // 'deprecated',\n];\n/**\n * List partially sourced from `openapi-schema-to-json-schema`.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/master/lib/converters/schema.js#L140-L154}\n */\nvar FORMAT_OPTIONS = {\n    INT8_MIN: 0 - Math.pow(2, 7),\n    INT8_MAX: Math.pow(2, 7) - 1,\n    INT16_MIN: 0 - Math.pow(2, 15),\n    INT16_MAX: Math.pow(2, 15) - 1,\n    INT32_MIN: 0 - Math.pow(2, 31),\n    INT32_MAX: Math.pow(2, 31) - 1,\n    INT64_MIN: 0 - Math.pow(2, 63),\n    INT64_MAX: Math.pow(2, 63) - 1,\n    UINT8_MIN: 0,\n    UINT8_MAX: Math.pow(2, 8) - 1,\n    UINT16_MIN: 0,\n    UINT16_MAX: Math.pow(2, 16) - 1,\n    UINT32_MIN: 0,\n    UINT32_MAX: Math.pow(2, 32) - 1,\n    UINT64_MIN: 0,\n    UINT64_MAX: Math.pow(2, 64) - 1,\n    FLOAT_MIN: 0 - Math.pow(2, 128),\n    FLOAT_MAX: Math.pow(2, 128) - 1,\n    DOUBLE_MIN: 0 - Number.MAX_VALUE,\n    DOUBLE_MAX: Number.MAX_VALUE\n};\n/**\n * Encode a string to be used as a JSON pointer.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param str String to encode into string that can be used as a JSON pointer.\n */\nfunction encodePointer(str) {\n    return str.replace('~', '~0').replace('/', '~1');\n}\nfunction getSchemaVersionString(schema, api) {\n    // If we're not on version 3.1.0, we always fall back to the default schema version for pre-3.1.0.\n    if (!RMOAS.isOAS31(api)) {\n        // This should remain as an HTTP url, not HTTPS.\n        return 'http://json-schema.org/draft-04/schema#';\n    }\n    /**\n     * If the schema indicates the version, prefer that.\n     *\n     * We use `as` here because the schema *should* be an OAS 3.1 schema due to the `isOAS31` check\n     * above.\n     */\n    if (schema.$schema) {\n        return schema.$schema;\n    }\n    // If the user defined a global schema version on their OAS document, prefer that.\n    if (api.jsonSchemaDialect) {\n        return api.jsonSchemaDialect;\n    }\n    return 'https://json-schema.org/draft/2020-12/schema#';\n}\nexports.getSchemaVersionString = getSchemaVersionString;\nfunction isPrimitive(val) {\n    return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\nexports.isPrimitive = isPrimitive;\nfunction isPolymorphicSchema(schema) {\n    return 'allOf' in schema || 'anyOf' in schema || 'oneOf' in schema;\n}\nfunction isRequestBodySchema(schema) {\n    return 'content' in schema;\n}\n/**\n * Given a JSON pointer and an array of examples do a reverse search through them until we find the\n * JSON pointer, or part of it, within the array.\n *\n * This function will allow you to take a pointer like `/tags/name` and return back `buster` from\n * the following array:\n *\n * ```\n *  [\n *    {\n *      example: {id: 20}\n *    },\n *    {\n *      examples: {\n *        distinctName: {\n *          tags: {name: 'buster'}\n *        }\n *      }\n *    }\n *  ]\n * ```\n *\n * As with most things however, this is not without its quirks! If a deeply nested property shares\n * the same name as an example that's further up the stack (like `tags.id` and an example for `id`),\n * there's a chance that it'll be misidentified as having an example and receive the wrong value.\n *\n * That said, any example is usually better than no example though, so while it's quirky behavior\n * it shouldn't raise immediate cause for alarm.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param pointer JSON pointer to search for an example for.\n * @param examples Array of previous schemas we've found relating to this pointer.\n */\nfunction searchForExampleByPointer(pointer, examples) {\n    if (examples === void 0) { examples = []; }\n    if (!examples.length || !pointer.length) {\n        return undefined;\n    }\n    var locSplit = pointer.split('/').filter(Boolean).reverse();\n    var pointers = [];\n    var point = '';\n    for (var i = 0; i < locSplit.length; i += 1) {\n        point = \"/\".concat(locSplit[i]).concat(point);\n        pointers.push(point);\n    }\n    var example;\n    var rev = __spreadArray([], examples, true).reverse();\n    for (var i = 0; i < pointers.length; i += 1) {\n        for (var ii = 0; ii < rev.length; ii += 1) {\n            var schema = rev[ii];\n            if ('example' in schema) {\n                schema = schema.example;\n            }\n            else {\n                if (!Array.isArray(schema.examples) || !schema.examples.length) {\n                    continue;\n                }\n                // Prevent us from crashing if `examples` is a completely empty object.\n                schema = schema.examples.shift();\n            }\n            try {\n                example = jsonpointer_1[\"default\"].get(schema, pointers[i]);\n            }\n            catch (err) {\n                // If the schema we're looking at is `{obj: null}` and our pointer if `/obj/propertyName`\n                // jsonpointer will throw an error. If that happens, we should silently catch and toss it\n                // and return no example.\n            }\n            if (example !== undefined) {\n                break;\n            }\n        }\n        if (example !== undefined) {\n            break;\n        }\n    }\n    return example;\n}\n/**\n * Given an OpenAPI-flavored JSON Schema, make an effort to modify it so it's shaped more towards\n * stock JSON Schema.\n *\n * Why do this?\n *\n *  1. OpenAPI 3.0.x supports its own flavor of JSON Schema that isn't fully compatible with most\n *    JSON Schema tooling (like `@readme/oas-form` or `@rjsf/core`).\n *  2. While validating an OpenAPI definition will prevent corrupted or improper schemas from\n *    occuring, we have a lot of legacy schemas in ReadMe that were ingested before we had proper\n *    validation in place, and as a result have some API definitions that will not pass validation\n *    right now. In addition to reshaping OAS-JSON Schema into JSON Schema this library will also\n *    fix these improper schemas: things like `type: object` having `items` instead of `properties`,\n *    or `type: array` missing `items`.\n *  3. To ease the burden of polymorphic handling on our form rendering engine we make an attempt\n *    to merge `allOf` schemas here.\n *  4. Additionally due to OpenAPI 3.0.x not supporting JSON Schema, in order to support the\n *    `example` keyword that OAS supports, we need to do some work in here to remap it into\n *    `examples`. However, since all we care about in respect to examples for usage within\n *    `@readme/oas-form`, we're only retaining primitives. This *slightly* deviates from JSON\n *    Schema in that JSON Schema allows for any schema to be an example, but since\n *    `@readme/oas-form` can only actually **render** primitives, that's what we're retaining.\n *  5. Though OpenAPI 3.1 does support full JSON Schema, this library should be able to handle it\n *    without any problems.\n *\n * And why use this over `@openapi-contrib/openapi-schema-to-json-schema`? Fortunately and\n * unfortunately we've got a lot of API definitions in our database that aren't currently valid so\n * we need to have a lot of bespoke handling for odd quirks, typos, and missing declarations that\n * might be present.\n *\n * @todo add support for `schema: false` and `not` cases.\n * @see {@link https://json-schema.org/draft/2019-09/json-schema-validation.html}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schemaObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schemaObject}\n * @param data OpenAPI Schema Object to convert to pure JSON Schema.\n */\nfunction toJSONSchema(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var schema = data === true ? {} : __assign({}, data);\n    var schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;\n    var _a = __assign({ addEnumsToDescriptions: false, currentLocation: '', globalDefaults: {}, isPolymorphicAllOfChild: false, prevSchemas: [], refLogger: function () { return true; }, transformer: function (s) { return s; } }, opts), addEnumsToDescriptions = _a.addEnumsToDescriptions, currentLocation = _a.currentLocation, globalDefaults = _a.globalDefaults, isPolymorphicAllOfChild = _a.isPolymorphicAllOfChild, prevSchemas = _a.prevSchemas, refLogger = _a.refLogger, transformer = _a.transformer;\n    // If this schema contains a `$ref`, it's circular and we shouldn't try to resolve it. Just\n    // return and move along.\n    if (RMOAS.isRef(schema)) {\n        refLogger(schema.$ref, 'ref');\n        return transformer({\n            $ref: schema.$ref\n        });\n    }\n    // If we don't have a set type, but are dealing with an `anyOf`, `oneOf`, or `allOf`\n    // representation let's run through them and make sure they're good.\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n        // If this is an `allOf` schema we should make an attempt to merge so as to ease the burden on\n        // the tooling that ingests these schemas.\n        if ('allOf' in schema && Array.isArray(schema.allOf)) {\n            try {\n                schema = (0, json_schema_merge_allof_1[\"default\"])(schema, {\n                    ignoreAdditionalProperties: true,\n                    resolvers: {\n                        // JSON Schema ony supports examples with the `examples` property, since we're\n                        // ingesting OpenAPI definitions we need to add a custom resolver for its `example`\n                        // property.\n                        example: function (obj) { return obj[0]; },\n                        // JSON Schema has no support for `format` on anything other than `string`, but since\n                        // OpenAPI has it on `integer` and `number` we need to add a custom resolver here so we\n                        // can still merge schemas that may have those.\n                        format: function (obj) { return obj[0]; },\n                        // Since JSON Schema obviously doesn't know about our vendor extension we need to tell\n                        // the library to essentially ignore and pass it along.\n                        'x-readme-ref-name': function (obj) { return obj[0]; }\n                    }\n                });\n            }\n            catch (e) {\n                // If we can't merge the `allOf` for whatever reason (like if one item is a `string` and\n                // the other is a `object`) then we should completely remove it from the schema and continue\n                // with whatever we've got. Why? If we don't, any tooling that's ingesting this will need\n                // to account for the incompatible `allOf` and it may be subject to more breakages than\n                // just not having it present would be.\n                var schemaWithoutAllOf = __rest(schema, []);\n                schema = schemaWithoutAllOf;\n                delete schema.allOf;\n            }\n        }\n        ['anyOf', 'oneOf'].forEach(function (polyType) {\n            if (polyType in schema && Array.isArray(schema[polyType])) {\n                schema[polyType].forEach(function (item, idx) {\n                    var polyOptions = {\n                        addEnumsToDescriptions: addEnumsToDescriptions,\n                        currentLocation: \"\".concat(currentLocation, \"/\").concat(idx),\n                        globalDefaults: globalDefaults,\n                        isPolymorphicAllOfChild: false,\n                        prevSchemas: prevSchemas,\n                        refLogger: refLogger,\n                        transformer: transformer\n                    };\n                    // When `properties` or `items` are present alongside a polymorphic schema instead of\n                    // letting whatever JSON Schema interpreter is handling these constructed schemas we can\n                    // guide its hand a bit by manually transforming it into an inferred `allOf` of the\n                    // `properties` + the polymorph schema.\n                    //\n                    // This `allOf` schema will be merged together when fed through `toJSONSchema`.\n                    if ('properties' in schema) {\n                        schema[polyType][idx] = toJSONSchema({ allOf: [item, { properties: schema.properties }] }, polyOptions);\n                    }\n                    else if ('items' in schema) {\n                        schema[polyType][idx] = toJSONSchema({ allOf: [item, { items: schema.items }] }, polyOptions);\n                    }\n                    else {\n                        schema[polyType][idx] = toJSONSchema(item, polyOptions);\n                    }\n                });\n            }\n        });\n        if ('discriminator' in schema) {\n            if ('mapping' in schema.discriminator && typeof schema.discriminator.mapping === 'object') {\n                // Discriminator mappings aren't written as traditional `$ref` pointers so in order to log\n                // them to the supplied `refLogger`.\n                var mapping_1 = schema.discriminator.mapping;\n                Object.keys(mapping_1).forEach(function (k) {\n                    refLogger(mapping_1[k], 'discriminator');\n                });\n            }\n        }\n    }\n    // If this schema is malformed for some reason, let's do our best to repair it.\n    if (!('type' in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {\n        if ('properties' in schema) {\n            schema.type = 'object';\n        }\n        else if ('items' in schema) {\n            schema.type = 'array';\n        }\n        else {\n            // If there's still no `type` on the schema we should leave it alone because we don't have a\n            // great way to know if it's part of a nested schema that should, and couldn't be merged,\n            // into another, or it's just purely malformed.\n            //\n            // Whatever tooling that ingests the generated schema should handle it however it needs to.\n        }\n    }\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n        // JSON Schema doesn't support OpenAPI-style examples so we need to reshape them a bit.\n        if ('example' in schema) {\n            // Only bother adding primitive examples.\n            if (isPrimitive(schema.example)) {\n                schema.examples = [schema.example];\n            }\n            else if (Array.isArray(schema.example)) {\n                schema.examples = schema.example.filter(function (example) { return isPrimitive(example); });\n                if (!schema.examples.length) {\n                    delete schema.examples;\n                }\n            }\n            else {\n                prevSchemas.push({ example: schema.example });\n            }\n            delete schema.example;\n        }\n        else if ('examples' in schema) {\n            var reshapedExamples_1 = false;\n            if (typeof schema.examples === 'object' && !Array.isArray(schema.examples)) {\n                var examples_1 = [];\n                Object.keys(schema.examples).forEach(function (name) {\n                    var example = schema.examples[name];\n                    if ('$ref' in example) {\n                        // no-op because any `$ref` example here after dereferencing is circular so we should\n                        // ignore it\n                        refLogger(example.$ref, 'ref');\n                    }\n                    else if ('value' in example) {\n                        if (isPrimitive(example.value)) {\n                            examples_1.push(example.value);\n                            reshapedExamples_1 = true;\n                        }\n                        else if (Array.isArray(example.value) && isPrimitive(example.value[0])) {\n                            examples_1.push(example.value[0]);\n                            reshapedExamples_1 = true;\n                        }\n                        else {\n                            // If this example is neither a primitive or an array we should dump it into the\n                            // `prevSchemas` array because we might be able to extract an example from it further\n                            // downstream.\n                            prevSchemas.push({\n                                example: example.value\n                            });\n                        }\n                    }\n                });\n                if (examples_1.length) {\n                    reshapedExamples_1 = true;\n                    schema.examples = examples_1;\n                }\n            }\n            else if (Array.isArray(schema.examples) && isPrimitive(schema.examples[0])) {\n                // We haven't reshaped `examples` here, but since it's in a state that's preferrable to us\n                // let's keep it around.\n                reshapedExamples_1 = true;\n            }\n            if (!reshapedExamples_1) {\n                delete schema.examples;\n            }\n        }\n        // If we didn't have any immediately defined examples, let's search backwards and see if we can\n        // find one. But as we're only looking for primitive example, only try to search for one if\n        // we're dealing with a primitive schema.\n        if (schema.type !== 'array' && schema.type !== 'object' && !schema.examples) {\n            var foundExample = searchForExampleByPointer(currentLocation, prevSchemas);\n            if (foundExample) {\n                // We can only really deal with primitives, so only promote those as the found example if\n                // it is.\n                if (isPrimitive(foundExample) || (Array.isArray(foundExample) && isPrimitive(foundExample[0]))) {\n                    schema.examples = [foundExample];\n                }\n            }\n        }\n        if (schema.type === 'array') {\n            if ('items' in schema) {\n                if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {\n                    // `items` contains a `$ref`, so since it's circular we should do a no-op here and log\n                    // and ignore it.\n                    refLogger(schema.items.$ref, 'ref');\n                }\n                else if (schema.items !== true) {\n                    // Run through the arrays contents and clean them up.\n                    schema.items = toJSONSchema(schema.items, {\n                        addEnumsToDescriptions: addEnumsToDescriptions,\n                        currentLocation: \"\".concat(currentLocation, \"/0\"),\n                        globalDefaults: globalDefaults,\n                        prevSchemas: prevSchemas,\n                        refLogger: refLogger,\n                        transformer: transformer\n                    });\n                }\n            }\n            else if ('properties' in schema || 'additionalProperties' in schema) {\n                // This is a fix to handle cases where someone may have typod `items` as `properties` on an\n                // array. Since throwing a complete failure isn't ideal, we can see that they meant for the\n                // type to be `object`, so we can do our best to shape the data into what they were\n                // intending it to be.\n                // README-6R\n                schema.type = 'object';\n            }\n            else {\n                // This is a fix to handle cases where we have a malformed array with no `items` property\n                // present.\n                // README-8E\n                schema.items = {};\n            }\n        }\n        else if (schema.type === 'object') {\n            if ('properties' in schema) {\n                Object.keys(schema.properties).forEach(function (prop) {\n                    if (Array.isArray(schema.properties[prop]) ||\n                        (typeof schema.properties[prop] === 'object' && schema.properties[prop] !== null)) {\n                        schema.properties[prop] = toJSONSchema(schema.properties[prop], {\n                            addEnumsToDescriptions: addEnumsToDescriptions,\n                            currentLocation: \"\".concat(currentLocation, \"/\").concat(encodePointer(prop)),\n                            globalDefaults: globalDefaults,\n                            prevSchemas: prevSchemas,\n                            refLogger: refLogger,\n                            transformer: transformer\n                        });\n                    }\n                });\n            }\n            if (typeof schemaAdditionalProperties === 'object' && schemaAdditionalProperties !== null) {\n                // If this `additionalProperties` is completely empty and devoid of any sort of schema,\n                // treat it as such. Otherwise let's recurse into it and see if we can sort it out.\n                if (!('type' in schemaAdditionalProperties) &&\n                    !('$ref' in schemaAdditionalProperties) &&\n                    // We know it will be a schema object because it's dereferenced\n                    !isPolymorphicSchema(schemaAdditionalProperties)) {\n                    schema.additionalProperties = true;\n                }\n                else {\n                    // We know it will be a schema object because it's dereferenced\n                    schema.additionalProperties = toJSONSchema(schemaAdditionalProperties, {\n                        addEnumsToDescriptions: addEnumsToDescriptions,\n                        currentLocation: currentLocation,\n                        globalDefaults: globalDefaults,\n                        prevSchemas: prevSchemas,\n                        refLogger: refLogger,\n                        transformer: transformer\n                    });\n                }\n            }\n            // Since neither `properties` and `additionalProperties` are actually required to be present\n            // on an object, since we construct this schema work to build up a form we still need\n            // *something* for the user to enter in for this object so we'll add back in\n            // `additionalProperties` for that.\n            if (!isPolymorphicSchema(schema) && !('properties' in schema) && !('additionalProperties' in schema)) {\n                schema.additionalProperties = true;\n            }\n        }\n    }\n    // Ensure that number schemas formats have properly constrained min/max attributes according to\n    // whatever type of `format` and `type` they adhere to.\n    if ('format' in schema) {\n        var formatUpper = schema.format.toUpperCase();\n        if (\"\".concat(formatUpper, \"_MIN\") in FORMAT_OPTIONS) {\n            if ((!schema.minimum && schema.minimum !== 0) || schema.minimum < FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")]) {\n                schema.minimum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")];\n            }\n        }\n        if (\"\".concat(formatUpper, \"_MAX\") in FORMAT_OPTIONS) {\n            if ((!schema.maximum && schema.maximum !== 0) || schema.maximum > FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")]) {\n                schema.maximum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")];\n            }\n        }\n    }\n    /**\n     * Users can pass in parameter defaults via JWT User Data. We're checking to see if the defaults\n     * being passed in exist on endpoints via jsonpointer\n     *\n     * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n     */\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) &&\n        globalDefaults &&\n        Object.keys(globalDefaults).length > 0 &&\n        currentLocation) {\n        try {\n            var userJwtDefault = jsonpointer_1[\"default\"].get(globalDefaults, currentLocation);\n            if (userJwtDefault) {\n                schema[\"default\"] = userJwtDefault;\n            }\n        }\n        catch (err) {\n            // If jsonpointer returns an error, we won't show any defaults for that path.\n        }\n    }\n    // Only add a default value if we actually have one.\n    if ('default' in schema && typeof schema[\"default\"] !== 'undefined') {\n        if (('allowEmptyValue' in schema && schema.allowEmptyValue && schema[\"default\"] === '') || schema[\"default\"] !== '') {\n            // If we have `allowEmptyValue` present, and the default is actually an empty string, let it\n            // through as it's allowed.\n        }\n        else {\n            // If the default is empty and we don't want to allowEmptyValue, we need to remove the\n            // default.\n            delete schema[\"default\"];\n        }\n    }\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && 'enum' in schema && Array.isArray(schema[\"enum\"])) {\n        // Enums should not have duplicated items as those will break AJV validation.\n        // If we ever target ES6 for typescript we can drop this array.from.\n        // https://stackoverflow.com/questions/33464504/using-spread-syntax-and-new-set-with-typescript/56870548\n        schema[\"enum\"] = Array.from(new Set(schema[\"enum\"]));\n        // If we want to add enums to descriptions (like in the case of response JSON Schema)\n        // generation we need to convert them into a list of Markdown tilda'd strings. We're also\n        // filtering away empty and falsy strings here because adding empty `` blocks to the description\n        // will serve nobody any good.\n        if (addEnumsToDescriptions) {\n            var enums = schema[\"enum\"]\n                .filter(Boolean)\n                .map(function (str) { return \"`\".concat(str, \"`\"); })\n                .join(' ');\n            if (enums.length) {\n                if ('description' in schema) {\n                    schema.description += \"\\n\\n\".concat(enums);\n                }\n                else {\n                    schema.description = enums;\n                }\n            }\n        }\n    }\n    // Clean up any remaining `items` or `properties` schema fragments lying around if there's also\n    // polymorphism present.\n    if ('anyOf' in schema || 'oneOf' in schema) {\n        if ('properties' in schema) {\n            delete schema.properties;\n        }\n        if ('items' in schema) {\n            delete schema.items;\n        }\n    }\n    // Remove unsupported JSON Schema props.\n    for (var i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {\n        // Using the as here because the purpose is to delete keys we don't expect, so of course the\n        // typing won't work\n        delete schema[UNSUPPORTED_SCHEMA_PROPS[i]];\n    }\n    return transformer(schema);\n}\nexports[\"default\"] = toJSONSchema;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,YAAY;EAClDA,QAAQ,GAAGC,MAAM,CAACC,MAAM,IAAI,UAASC,CAAC,EAAE;IACpC,KAAK,IAAIC,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACjDD,CAAC,GAAGG,SAAS,CAACF,CAAC,CAAC;MAChB,KAAK,IAAII,CAAC,IAAIL,CAAC,EAAE,IAAIH,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,CAAC,EAAEK,CAAC,CAAC,EAC3DN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IACnB;IACA,OAAON,CAAC;EACZ,CAAC;EACD,OAAOH,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEN,SAAS,CAAC;AAC1C,CAAC;AACD,IAAIO,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,KAAMb,MAAM,CAACc,MAAM,GAAI,UAASC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EAC5F,IAAIA,EAAE,KAAKC,SAAS,EAAED,EAAE,GAAGD,CAAC;EAC5B,IAAIG,IAAI,GAAGpB,MAAM,CAACqB,wBAAwB,CAACL,CAAC,EAAEC,CAAC,CAAC;EAChD,IAAI,CAACG,IAAI,KAAK,KAAK,IAAIA,IAAI,GAAG,CAACJ,CAAC,CAACM,UAAU,GAAGF,IAAI,CAACG,QAAQ,IAAIH,IAAI,CAACI,YAAY,CAAC,EAAE;IACjFJ,IAAI,GAAG;MAAEK,UAAU,EAAE,IAAI;MAAEC,GAAG,EAAE,SAAAA,CAAA,EAAW;QAAE,OAAOV,CAAC,CAACC,CAAC,CAAC;MAAE;IAAE,CAAC;EAC/D;EACAjB,MAAM,CAAC2B,cAAc,CAACZ,CAAC,EAAEG,EAAE,EAAEE,IAAI,CAAC;AACtC,CAAC,GAAK,UAASL,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EACxB,IAAIA,EAAE,KAAKC,SAAS,EAAED,EAAE,GAAGD,CAAC;EAC5BF,CAAC,CAACG,EAAE,CAAC,GAAGF,CAAC,CAACC,CAAC,CAAC;AAChB,CAAE,CAAC;AACH,IAAIW,kBAAkB,GAAI,IAAI,IAAI,IAAI,CAACA,kBAAkB,KAAM5B,MAAM,CAACc,MAAM,GAAI,UAASC,CAAC,EAAEc,CAAC,EAAE;EAC3F7B,MAAM,CAAC2B,cAAc,CAACZ,CAAC,EAAE,SAAS,EAAE;IAAEU,UAAU,EAAE,IAAI;IAAEK,KAAK,EAAED;EAAE,CAAC,CAAC;AACvE,CAAC,GAAI,UAASd,CAAC,EAAEc,CAAC,EAAE;EAChBd,CAAC,CAAC,SAAS,CAAC,GAAGc,CAAC;AACpB,CAAC,CAAC;AACF,IAAIE,YAAY,GAAI,IAAI,IAAI,IAAI,CAACA,YAAY,IAAK,UAAUC,GAAG,EAAE;EAC7D,IAAIA,GAAG,IAAIA,GAAG,CAACV,UAAU,EAAE,OAAOU,GAAG;EACrC,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,IAAID,GAAG,IAAI,IAAI,EAAE,KAAK,IAAIf,CAAC,IAAIe,GAAG,EAAE,IAAIf,CAAC,KAAK,SAAS,IAAIjB,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACqB,GAAG,EAAEf,CAAC,CAAC,EAAEJ,eAAe,CAACoB,MAAM,EAAED,GAAG,EAAEf,CAAC,CAAC;EACxIW,kBAAkB,CAACK,MAAM,EAAED,GAAG,CAAC;EAC/B,OAAOC,MAAM;AACjB,CAAC;AACD,IAAIC,MAAM,GAAI,IAAI,IAAI,IAAI,CAACA,MAAM,IAAK,UAAU/B,CAAC,EAAEgC,CAAC,EAAE;EAClD,IAAIjC,CAAC,GAAG,CAAC,CAAC;EACV,KAAK,IAAIM,CAAC,IAAIL,CAAC,EAAE,IAAIH,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,CAAC,EAAEK,CAAC,CAAC,IAAI2B,CAAC,CAACC,OAAO,CAAC5B,CAAC,CAAC,GAAG,CAAC,EAC/EN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;EACf,IAAIL,CAAC,IAAI,IAAI,IAAI,OAAOH,MAAM,CAACqC,qBAAqB,KAAK,UAAU,EAC/D,KAAK,IAAIjC,CAAC,GAAG,CAAC,EAAEI,CAAC,GAAGR,MAAM,CAACqC,qBAAqB,CAAClC,CAAC,CAAC,EAAEC,CAAC,GAAGI,CAAC,CAACD,MAAM,EAAEH,CAAC,EAAE,EAAE;IACpE,IAAI+B,CAAC,CAACC,OAAO,CAAC5B,CAAC,CAACJ,CAAC,CAAC,CAAC,GAAG,CAAC,IAAIJ,MAAM,CAACS,SAAS,CAAC6B,oBAAoB,CAAC3B,IAAI,CAACR,CAAC,EAAEK,CAAC,CAACJ,CAAC,CAAC,CAAC,EAC1EF,CAAC,CAACM,CAAC,CAACJ,CAAC,CAAC,CAAC,GAAGD,CAAC,CAACK,CAAC,CAACJ,CAAC,CAAC,CAAC;EACzB;EACJ,OAAOF,CAAC;AACZ,CAAC;AACD,IAAIqC,aAAa,GAAI,IAAI,IAAI,IAAI,CAACA,aAAa,IAAK,UAAUC,EAAE,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAC1E,IAAIA,IAAI,IAAIpC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEuC,CAAC,GAAGF,IAAI,CAAClC,MAAM,EAAEqC,EAAE,EAAExC,CAAC,GAAGuC,CAAC,EAAEvC,CAAC,EAAE,EAAE;IACjF,IAAIwC,EAAE,IAAI,EAAExC,CAAC,IAAIqC,IAAI,CAAC,EAAE;MACpB,IAAI,CAACG,EAAE,EAAEA,EAAE,GAAGC,KAAK,CAACpC,SAAS,CAACqC,KAAK,CAACnC,IAAI,CAAC8B,IAAI,EAAE,CAAC,EAAErC,CAAC,CAAC;MACpDwC,EAAE,CAACxC,CAAC,CAAC,GAAGqC,IAAI,CAACrC,CAAC,CAAC;IACnB;EACJ;EACA,OAAOoC,EAAE,CAACO,MAAM,CAACH,EAAE,IAAIC,KAAK,CAACpC,SAAS,CAACqC,KAAK,CAACnC,IAAI,CAAC8B,IAAI,CAAC,CAAC;AAC5D,CAAC;AACD,IAAIO,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUhB,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACV,UAAU,GAAIU,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDiB,OAAO,CAAC3B,UAAU,GAAG,IAAI;AACzB2B,OAAO,CAACC,WAAW,GAAGD,OAAO,CAACE,sBAAsB,GAAG,KAAK,CAAC;AAC7D,IAAIC,yBAAyB,GAAGJ,eAAe,CAACK,OAAO,CAAC,yBAAyB,CAAC,CAAC;AACnF,IAAIC,aAAa,GAAGN,eAAe,CAACK,OAAO,CAAC,aAAa,CAAC,CAAC;AAC3D,IAAIE,KAAK,GAAGxB,YAAY,CAACsB,OAAO,CAAC,gBAAgB,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,wBAAwB,GAAG,CAC3B,UAAU;AACV;AACA;AACA;AACA,KAAK,EACL,cAAc,EACd,SAAS,CAAE;AACX;AAAA,CACH;AACD;AACA;AACA;AACA;AACA;AACA,IAAIC,cAAc,GAAG;EACjBC,QAAQ,EAAE,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EAC5BC,QAAQ,EAAEF,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC;EAC5BE,SAAS,EAAE,CAAC,GAAGH,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;EAC9BG,SAAS,EAAEJ,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;EAC9BI,SAAS,EAAE,CAAC,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;EAC9BK,SAAS,EAAEN,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;EAC9BM,SAAS,EAAE,CAAC,GAAGP,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;EAC9BO,SAAS,EAAER,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;EAC9BQ,SAAS,EAAE,CAAC;EACZC,SAAS,EAAEV,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC;EAC7BU,UAAU,EAAE,CAAC;EACbC,UAAU,EAAEZ,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;EAC/BY,UAAU,EAAE,CAAC;EACbC,UAAU,EAAEd,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;EAC/Bc,UAAU,EAAE,CAAC;EACbC,UAAU,EAAEhB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;EAC/BgB,SAAS,EAAE,CAAC,GAAGjB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;EAC/BiB,SAAS,EAAElB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC;EAC/BkB,UAAU,EAAE,CAAC,GAAGC,MAAM,CAACC,SAAS;EAChCC,UAAU,EAAEF,MAAM,CAACC;AACvB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,aAAaA,CAACC,GAAG,EAAE;EACxB,OAAOA,GAAG,CAACC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC;AACpD;AACA,SAASjC,sBAAsBA,CAACkC,MAAM,EAAEC,GAAG,EAAE;EACzC;EACA,IAAI,CAAC/B,KAAK,CAACgC,OAAO,CAACD,GAAG,CAAC,EAAE;IACrB;IACA,OAAO,yCAAyC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAID,MAAM,CAACG,OAAO,EAAE;IAChB,OAAOH,MAAM,CAACG,OAAO;EACzB;EACA;EACA,IAAIF,GAAG,CAACG,iBAAiB,EAAE;IACvB,OAAOH,GAAG,CAACG,iBAAiB;EAChC;EACA,OAAO,+CAA+C;AAC1D;AACAxC,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB;AACvD,SAASD,WAAWA,CAACwC,GAAG,EAAE;EACtB,OAAO,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,SAAS;AACzF;AACAzC,OAAO,CAACC,WAAW,GAAGA,WAAW;AACjC,SAASyC,mBAAmBA,CAACN,MAAM,EAAE;EACjC,OAAO,OAAO,IAAIA,MAAM,IAAI,OAAO,IAAIA,MAAM,IAAI,OAAO,IAAIA,MAAM;AACtE;AACA,SAASO,mBAAmBA,CAACP,MAAM,EAAE;EACjC,OAAO,SAAS,IAAIA,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,yBAAyBA,CAACC,OAAO,EAAEC,QAAQ,EAAE;EAClD,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;IAAEA,QAAQ,GAAG,EAAE;EAAE;EAC1C,IAAI,CAACA,QAAQ,CAACxF,MAAM,IAAI,CAACuF,OAAO,CAACvF,MAAM,EAAE;IACrC,OAAOY,SAAS;EACpB;EACA,IAAI6E,QAAQ,GAAGF,OAAO,CAACG,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,CAAC;EAC3D,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,KAAK,GAAG,EAAE;EACd,KAAK,IAAIlG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4F,QAAQ,CAACzF,MAAM,EAAEH,CAAC,IAAI,CAAC,EAAE;IACzCkG,KAAK,GAAG,GAAG,CAACvD,MAAM,CAACiD,QAAQ,CAAC5F,CAAC,CAAC,CAAC,CAAC2C,MAAM,CAACuD,KAAK,CAAC;IAC7CD,QAAQ,CAACE,IAAI,CAACD,KAAK,CAAC;EACxB;EACA,IAAIE,OAAO;EACX,IAAIC,GAAG,GAAGlE,aAAa,CAAC,EAAE,EAAEwD,QAAQ,EAAE,IAAI,CAAC,CAACK,OAAO,CAAC,CAAC;EACrD,KAAK,IAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiG,QAAQ,CAAC9F,MAAM,EAAEH,CAAC,IAAI,CAAC,EAAE;IACzC,KAAK,IAAIsG,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGD,GAAG,CAAClG,MAAM,EAAEmG,EAAE,IAAI,CAAC,EAAE;MACvC,IAAIrB,MAAM,GAAGoB,GAAG,CAACC,EAAE,CAAC;MACpB,IAAI,SAAS,IAAIrB,MAAM,EAAE;QACrBA,MAAM,GAAGA,MAAM,CAACmB,OAAO;MAC3B,CAAC,MACI;QACD,IAAI,CAAC3D,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACU,QAAQ,CAAC,IAAI,CAACV,MAAM,CAACU,QAAQ,CAACxF,MAAM,EAAE;UAC5D;QACJ;QACA;QACA8E,MAAM,GAAGA,MAAM,CAACU,QAAQ,CAACa,KAAK,CAAC,CAAC;MACpC;MACA,IAAI;QACAJ,OAAO,GAAGlD,aAAa,CAAC,SAAS,CAAC,CAAC5B,GAAG,CAAC2D,MAAM,EAAEgB,QAAQ,CAACjG,CAAC,CAAC,CAAC;MAC/D,CAAC,CACD,OAAOyG,GAAG,EAAE;QACR;QACA;QACA;MAAA;MAEJ,IAAIL,OAAO,KAAKrF,SAAS,EAAE;QACvB;MACJ;IACJ;IACA,IAAIqF,OAAO,KAAKrF,SAAS,EAAE;MACvB;IACJ;EACJ;EACA,OAAOqF,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,YAAYA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC9B,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;IAAEA,IAAI,GAAG,CAAC,CAAC;EAAE;EAClC,IAAI3B,MAAM,GAAG0B,IAAI,KAAK,IAAI,GAAG,CAAC,CAAC,GAAGhH,QAAQ,CAAC,CAAC,CAAC,EAAEgH,IAAI,CAAC;EACpD,IAAIE,0BAA0B,GAAG1D,KAAK,CAAC2D,QAAQ,CAAC7B,MAAM,CAAC,GAAGA,MAAM,CAAC8B,oBAAoB,GAAG,IAAI;EAC5F,IAAIC,EAAE,GAAGrH,QAAQ,CAAC;MAAEsH,sBAAsB,EAAE,KAAK;MAAEC,eAAe,EAAE,EAAE;MAAEC,cAAc,EAAE,CAAC,CAAC;MAAEC,uBAAuB,EAAE,KAAK;MAAEC,WAAW,EAAE,EAAE;MAAEC,SAAS,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAO,IAAI;MAAE,CAAC;MAAEC,WAAW,EAAE,SAAAA,CAAUxH,CAAC,EAAE;QAAE,OAAOA,CAAC;MAAE;IAAE,CAAC,EAAE6G,IAAI,CAAC;IAAEK,sBAAsB,GAAGD,EAAE,CAACC,sBAAsB;IAAEC,eAAe,GAAGF,EAAE,CAACE,eAAe;IAAEC,cAAc,GAAGH,EAAE,CAACG,cAAc;IAAEC,uBAAuB,GAAGJ,EAAE,CAACI,uBAAuB;IAAEC,WAAW,GAAGL,EAAE,CAACK,WAAW;IAAEC,SAAS,GAAGN,EAAE,CAACM,SAAS;IAAEC,WAAW,GAAGP,EAAE,CAACO,WAAW;EAChf;EACA;EACA,IAAIpE,KAAK,CAACqE,KAAK,CAACvC,MAAM,CAAC,EAAE;IACrBqC,SAAS,CAACrC,MAAM,CAACwC,IAAI,EAAE,KAAK,CAAC;IAC7B,OAAOF,WAAW,CAAC;MACfE,IAAI,EAAExC,MAAM,CAACwC;IACjB,CAAC,CAAC;EACN;EACA;EACA;EACA,IAAItE,KAAK,CAAC2D,QAAQ,CAAC7B,MAAM,EAAEmC,uBAAuB,CAAC,EAAE;IACjD;IACA;IACA,IAAI,OAAO,IAAInC,MAAM,IAAIxC,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACyC,KAAK,CAAC,EAAE;MAClD,IAAI;QACAzC,MAAM,GAAG,CAAC,CAAC,EAAEjC,yBAAyB,CAAC,SAAS,CAAC,EAAEiC,MAAM,EAAE;UACvD0C,0BAA0B,EAAE,IAAI;UAChCC,SAAS,EAAE;YACP;YACA;YACA;YACAxB,OAAO,EAAE,SAAAA,CAAUyB,GAAG,EAAE;cAAE,OAAOA,GAAG,CAAC,CAAC,CAAC;YAAE,CAAC;YAC1C;YACA;YACA;YACAC,MAAM,EAAE,SAAAA,CAAUD,GAAG,EAAE;cAAE,OAAOA,GAAG,CAAC,CAAC,CAAC;YAAE,CAAC;YACzC;YACA;YACA,mBAAmB,EAAE,SAAAE,CAAUF,GAAG,EAAE;cAAE,OAAOA,GAAG,CAAC,CAAC,CAAC;YAAE;UACzD;QACJ,CAAC,CAAC;MACN,CAAC,CACD,OAAO9F,CAAC,EAAE;QACN;QACA;QACA;QACA;QACA;QACA,IAAIiG,kBAAkB,GAAGlG,MAAM,CAACmD,MAAM,EAAE,EAAE,CAAC;QAC3CA,MAAM,GAAG+C,kBAAkB;QAC3B,OAAO/C,MAAM,CAACyC,KAAK;MACvB;IACJ;IACA,CAAC,OAAO,EAAE,OAAO,CAAC,CAACO,OAAO,CAAC,UAAUC,QAAQ,EAAE;MAC3C,IAAIA,QAAQ,IAAIjD,MAAM,IAAIxC,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACiD,QAAQ,CAAC,CAAC,EAAE;QACvDjD,MAAM,CAACiD,QAAQ,CAAC,CAACD,OAAO,CAAC,UAAUE,IAAI,EAAEC,GAAG,EAAE;UAC1C,IAAIC,WAAW,GAAG;YACdpB,sBAAsB,EAAEA,sBAAsB;YAC9CC,eAAe,EAAE,EAAE,CAACvE,MAAM,CAACuE,eAAe,EAAE,GAAG,CAAC,CAACvE,MAAM,CAACyF,GAAG,CAAC;YAC5DjB,cAAc,EAAEA,cAAc;YAC9BC,uBAAuB,EAAE,KAAK;YAC9BC,WAAW,EAAEA,WAAW;YACxBC,SAAS,EAAEA,SAAS;YACpBC,WAAW,EAAEA;UACjB,CAAC;UACD;UACA;UACA;UACA;UACA;UACA;UACA,IAAI,YAAY,IAAItC,MAAM,EAAE;YACxBA,MAAM,CAACiD,QAAQ,CAAC,CAACE,GAAG,CAAC,GAAG1B,YAAY,CAAC;cAAEgB,KAAK,EAAE,CAACS,IAAI,EAAE;gBAAEG,UAAU,EAAErD,MAAM,CAACqD;cAAW,CAAC;YAAE,CAAC,EAAED,WAAW,CAAC;UAC3G,CAAC,MACI,IAAI,OAAO,IAAIpD,MAAM,EAAE;YACxBA,MAAM,CAACiD,QAAQ,CAAC,CAACE,GAAG,CAAC,GAAG1B,YAAY,CAAC;cAAEgB,KAAK,EAAE,CAACS,IAAI,EAAE;gBAAEI,KAAK,EAAEtD,MAAM,CAACsD;cAAM,CAAC;YAAE,CAAC,EAAEF,WAAW,CAAC;UACjG,CAAC,MACI;YACDpD,MAAM,CAACiD,QAAQ,CAAC,CAACE,GAAG,CAAC,GAAG1B,YAAY,CAACyB,IAAI,EAAEE,WAAW,CAAC;UAC3D;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;IACF,IAAI,eAAe,IAAIpD,MAAM,EAAE;MAC3B,IAAI,SAAS,IAAIA,MAAM,CAACuD,aAAa,IAAI,OAAOvD,MAAM,CAACuD,aAAa,CAACC,OAAO,KAAK,QAAQ,EAAE;QACvF;QACA;QACA,IAAIC,SAAS,GAAGzD,MAAM,CAACuD,aAAa,CAACC,OAAO;QAC5C7I,MAAM,CAAC+I,IAAI,CAACD,SAAS,CAAC,CAACT,OAAO,CAAC,UAAUpH,CAAC,EAAE;UACxCyG,SAAS,CAACoB,SAAS,CAAC7H,CAAC,CAAC,EAAE,eAAe,CAAC;QAC5C,CAAC,CAAC;MACN;IACJ;EACJ;EACA;EACA,IAAI,EAAE,MAAM,IAAIoE,MAAM,CAAC,IAAI,CAACM,mBAAmB,CAACN,MAAM,CAAC,IAAI,CAACO,mBAAmB,CAACP,MAAM,CAAC,EAAE;IACrF,IAAI,YAAY,IAAIA,MAAM,EAAE;MACxBA,MAAM,CAAC2D,IAAI,GAAG,QAAQ;IAC1B,CAAC,MACI,IAAI,OAAO,IAAI3D,MAAM,EAAE;MACxBA,MAAM,CAAC2D,IAAI,GAAG,OAAO;IACzB,CAAC,MACI;MACD;MACA;MACA;MACA;MACA;IAAA;EAER;EACA,IAAIzF,KAAK,CAAC2D,QAAQ,CAAC7B,MAAM,EAAEmC,uBAAuB,CAAC,EAAE;IACjD;IACA,IAAI,SAAS,IAAInC,MAAM,EAAE;MACrB;MACA,IAAInC,WAAW,CAACmC,MAAM,CAACmB,OAAO,CAAC,EAAE;QAC7BnB,MAAM,CAACU,QAAQ,GAAG,CAACV,MAAM,CAACmB,OAAO,CAAC;MACtC,CAAC,MACI,IAAI3D,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACmB,OAAO,CAAC,EAAE;QACpCnB,MAAM,CAACU,QAAQ,GAAGV,MAAM,CAACmB,OAAO,CAACN,MAAM,CAAC,UAAUM,OAAO,EAAE;UAAE,OAAOtD,WAAW,CAACsD,OAAO,CAAC;QAAE,CAAC,CAAC;QAC5F,IAAI,CAACnB,MAAM,CAACU,QAAQ,CAACxF,MAAM,EAAE;UACzB,OAAO8E,MAAM,CAACU,QAAQ;QAC1B;MACJ,CAAC,MACI;QACD0B,WAAW,CAAClB,IAAI,CAAC;UAAEC,OAAO,EAAEnB,MAAM,CAACmB;QAAQ,CAAC,CAAC;MACjD;MACA,OAAOnB,MAAM,CAACmB,OAAO;IACzB,CAAC,MACI,IAAI,UAAU,IAAInB,MAAM,EAAE;MAC3B,IAAI4D,kBAAkB,GAAG,KAAK;MAC9B,IAAI,OAAO5D,MAAM,CAACU,QAAQ,KAAK,QAAQ,IAAI,CAAClD,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACU,QAAQ,CAAC,EAAE;QACxE,IAAImD,UAAU,GAAG,EAAE;QACnBlJ,MAAM,CAAC+I,IAAI,CAAC1D,MAAM,CAACU,QAAQ,CAAC,CAACsC,OAAO,CAAC,UAAUc,IAAI,EAAE;UACjD,IAAI3C,OAAO,GAAGnB,MAAM,CAACU,QAAQ,CAACoD,IAAI,CAAC;UACnC,IAAI,MAAM,IAAI3C,OAAO,EAAE;YACnB;YACA;YACAkB,SAAS,CAAClB,OAAO,CAACqB,IAAI,EAAE,KAAK,CAAC;UAClC,CAAC,MACI,IAAI,OAAO,IAAIrB,OAAO,EAAE;YACzB,IAAItD,WAAW,CAACsD,OAAO,CAAC1E,KAAK,CAAC,EAAE;cAC5BoH,UAAU,CAAC3C,IAAI,CAACC,OAAO,CAAC1E,KAAK,CAAC;cAC9BmH,kBAAkB,GAAG,IAAI;YAC7B,CAAC,MACI,IAAIpG,KAAK,CAAC8D,OAAO,CAACH,OAAO,CAAC1E,KAAK,CAAC,IAAIoB,WAAW,CAACsD,OAAO,CAAC1E,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;cACpEoH,UAAU,CAAC3C,IAAI,CAACC,OAAO,CAAC1E,KAAK,CAAC,CAAC,CAAC,CAAC;cACjCmH,kBAAkB,GAAG,IAAI;YAC7B,CAAC,MACI;cACD;cACA;cACA;cACAxB,WAAW,CAAClB,IAAI,CAAC;gBACbC,OAAO,EAAEA,OAAO,CAAC1E;cACrB,CAAC,CAAC;YACN;UACJ;QACJ,CAAC,CAAC;QACF,IAAIoH,UAAU,CAAC3I,MAAM,EAAE;UACnB0I,kBAAkB,GAAG,IAAI;UACzB5D,MAAM,CAACU,QAAQ,GAAGmD,UAAU;QAChC;MACJ,CAAC,MACI,IAAIrG,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACU,QAAQ,CAAC,IAAI7C,WAAW,CAACmC,MAAM,CAACU,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;QACxE;QACA;QACAkD,kBAAkB,GAAG,IAAI;MAC7B;MACA,IAAI,CAACA,kBAAkB,EAAE;QACrB,OAAO5D,MAAM,CAACU,QAAQ;MAC1B;IACJ;IACA;IACA;IACA;IACA,IAAIV,MAAM,CAAC2D,IAAI,KAAK,OAAO,IAAI3D,MAAM,CAAC2D,IAAI,KAAK,QAAQ,IAAI,CAAC3D,MAAM,CAACU,QAAQ,EAAE;MACzE,IAAIqD,YAAY,GAAGvD,yBAAyB,CAACyB,eAAe,EAAEG,WAAW,CAAC;MAC1E,IAAI2B,YAAY,EAAE;QACd;QACA;QACA,IAAIlG,WAAW,CAACkG,YAAY,CAAC,IAAKvG,KAAK,CAAC8D,OAAO,CAACyC,YAAY,CAAC,IAAIlG,WAAW,CAACkG,YAAY,CAAC,CAAC,CAAC,CAAE,EAAE;UAC5F/D,MAAM,CAACU,QAAQ,GAAG,CAACqD,YAAY,CAAC;QACpC;MACJ;IACJ;IACA,IAAI/D,MAAM,CAAC2D,IAAI,KAAK,OAAO,EAAE;MACzB,IAAI,OAAO,IAAI3D,MAAM,EAAE;QACnB,IAAI,CAACxC,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACsD,KAAK,CAAC,IAAI3I,MAAM,CAAC+I,IAAI,CAAC1D,MAAM,CAACsD,KAAK,CAAC,CAACpI,MAAM,KAAK,CAAC,IAAIgD,KAAK,CAACqE,KAAK,CAACvC,MAAM,CAACsD,KAAK,CAAC,EAAE;UACrG;UACA;UACAjB,SAAS,CAACrC,MAAM,CAACsD,KAAK,CAACd,IAAI,EAAE,KAAK,CAAC;QACvC,CAAC,MACI,IAAIxC,MAAM,CAACsD,KAAK,KAAK,IAAI,EAAE;UAC5B;UACAtD,MAAM,CAACsD,KAAK,GAAG7B,YAAY,CAACzB,MAAM,CAACsD,KAAK,EAAE;YACtCtB,sBAAsB,EAAEA,sBAAsB;YAC9CC,eAAe,EAAE,EAAE,CAACvE,MAAM,CAACuE,eAAe,EAAE,IAAI,CAAC;YACjDC,cAAc,EAAEA,cAAc;YAC9BE,WAAW,EAAEA,WAAW;YACxBC,SAAS,EAAEA,SAAS;YACpBC,WAAW,EAAEA;UACjB,CAAC,CAAC;QACN;MACJ,CAAC,MACI,IAAI,YAAY,IAAItC,MAAM,IAAI,sBAAsB,IAAIA,MAAM,EAAE;QACjE;QACA;QACA;QACA;QACA;QACAA,MAAM,CAAC2D,IAAI,GAAG,QAAQ;MAC1B,CAAC,MACI;QACD;QACA;QACA;QACA3D,MAAM,CAACsD,KAAK,GAAG,CAAC,CAAC;MACrB;IACJ,CAAC,MACI,IAAItD,MAAM,CAAC2D,IAAI,KAAK,QAAQ,EAAE;MAC/B,IAAI,YAAY,IAAI3D,MAAM,EAAE;QACxBrF,MAAM,CAAC+I,IAAI,CAAC1D,MAAM,CAACqD,UAAU,CAAC,CAACL,OAAO,CAAC,UAAUgB,IAAI,EAAE;UACnD,IAAIxG,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAACqD,UAAU,CAACW,IAAI,CAAC,CAAC,IACrC,OAAOhE,MAAM,CAACqD,UAAU,CAACW,IAAI,CAAC,KAAK,QAAQ,IAAIhE,MAAM,CAACqD,UAAU,CAACW,IAAI,CAAC,KAAK,IAAK,EAAE;YACnFhE,MAAM,CAACqD,UAAU,CAACW,IAAI,CAAC,GAAGvC,YAAY,CAACzB,MAAM,CAACqD,UAAU,CAACW,IAAI,CAAC,EAAE;cAC5DhC,sBAAsB,EAAEA,sBAAsB;cAC9CC,eAAe,EAAE,EAAE,CAACvE,MAAM,CAACuE,eAAe,EAAE,GAAG,CAAC,CAACvE,MAAM,CAACmC,aAAa,CAACmE,IAAI,CAAC,CAAC;cAC5E9B,cAAc,EAAEA,cAAc;cAC9BE,WAAW,EAAEA,WAAW;cACxBC,SAAS,EAAEA,SAAS;cACpBC,WAAW,EAAEA;YACjB,CAAC,CAAC;UACN;QACJ,CAAC,CAAC;MACN;MACA,IAAI,OAAOV,0BAA0B,KAAK,QAAQ,IAAIA,0BAA0B,KAAK,IAAI,EAAE;QACvF;QACA;QACA,IAAI,EAAE,MAAM,IAAIA,0BAA0B,CAAC,IACvC,EAAE,MAAM,IAAIA,0BAA0B,CAAC;QACvC;QACA,CAACtB,mBAAmB,CAACsB,0BAA0B,CAAC,EAAE;UAClD5B,MAAM,CAAC8B,oBAAoB,GAAG,IAAI;QACtC,CAAC,MACI;UACD;UACA9B,MAAM,CAAC8B,oBAAoB,GAAGL,YAAY,CAACG,0BAA0B,EAAE;YACnEI,sBAAsB,EAAEA,sBAAsB;YAC9CC,eAAe,EAAEA,eAAe;YAChCC,cAAc,EAAEA,cAAc;YAC9BE,WAAW,EAAEA,WAAW;YACxBC,SAAS,EAAEA,SAAS;YACpBC,WAAW,EAAEA;UACjB,CAAC,CAAC;QACN;MACJ;MACA;MACA;MACA;MACA;MACA,IAAI,CAAChC,mBAAmB,CAACN,MAAM,CAAC,IAAI,EAAE,YAAY,IAAIA,MAAM,CAAC,IAAI,EAAE,sBAAsB,IAAIA,MAAM,CAAC,EAAE;QAClGA,MAAM,CAAC8B,oBAAoB,GAAG,IAAI;MACtC;IACJ;EACJ;EACA;EACA;EACA,IAAI,QAAQ,IAAI9B,MAAM,EAAE;IACpB,IAAIiE,WAAW,GAAGjE,MAAM,CAAC6C,MAAM,CAACqB,WAAW,CAAC,CAAC;IAC7C,IAAI,EAAE,CAACxG,MAAM,CAACuG,WAAW,EAAE,MAAM,CAAC,IAAI7F,cAAc,EAAE;MAClD,IAAK,CAAC4B,MAAM,CAACmE,OAAO,IAAInE,MAAM,CAACmE,OAAO,KAAK,CAAC,IAAKnE,MAAM,CAACmE,OAAO,GAAG/F,cAAc,CAAC,EAAE,CAACV,MAAM,CAACuG,WAAW,EAAE,MAAM,CAAC,CAAC,EAAE;QAC9GjE,MAAM,CAACmE,OAAO,GAAG/F,cAAc,CAAC,EAAE,CAACV,MAAM,CAACuG,WAAW,EAAE,MAAM,CAAC,CAAC;MACnE;IACJ;IACA,IAAI,EAAE,CAACvG,MAAM,CAACuG,WAAW,EAAE,MAAM,CAAC,IAAI7F,cAAc,EAAE;MAClD,IAAK,CAAC4B,MAAM,CAACoE,OAAO,IAAIpE,MAAM,CAACoE,OAAO,KAAK,CAAC,IAAKpE,MAAM,CAACoE,OAAO,GAAGhG,cAAc,CAAC,EAAE,CAACV,MAAM,CAACuG,WAAW,EAAE,MAAM,CAAC,CAAC,EAAE;QAC9GjE,MAAM,CAACoE,OAAO,GAAGhG,cAAc,CAAC,EAAE,CAACV,MAAM,CAACuG,WAAW,EAAE,MAAM,CAAC,CAAC;MACnE;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAI/F,KAAK,CAAC2D,QAAQ,CAAC7B,MAAM,EAAEmC,uBAAuB,CAAC,IAC/CD,cAAc,IACdvH,MAAM,CAAC+I,IAAI,CAACxB,cAAc,CAAC,CAAChH,MAAM,GAAG,CAAC,IACtC+G,eAAe,EAAE;IACjB,IAAI;MACA,IAAIoC,cAAc,GAAGpG,aAAa,CAAC,SAAS,CAAC,CAAC5B,GAAG,CAAC6F,cAAc,EAAED,eAAe,CAAC;MAClF,IAAIoC,cAAc,EAAE;QAChBrE,MAAM,CAAC,SAAS,CAAC,GAAGqE,cAAc;MACtC;IACJ,CAAC,CACD,OAAO7C,GAAG,EAAE;MACR;IAAA;EAER;EACA;EACA,IAAI,SAAS,IAAIxB,MAAM,IAAI,OAAOA,MAAM,CAAC,SAAS,CAAC,KAAK,WAAW,EAAE;IACjE,IAAK,iBAAiB,IAAIA,MAAM,IAAIA,MAAM,CAACsE,eAAe,IAAItE,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,IAAKA,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE;MACjH;MACA;IAAA,CACH,MACI;MACD;MACA;MACA,OAAOA,MAAM,CAAC,SAAS,CAAC;IAC5B;EACJ;EACA,IAAI9B,KAAK,CAAC2D,QAAQ,CAAC7B,MAAM,EAAEmC,uBAAuB,CAAC,IAAI,MAAM,IAAInC,MAAM,IAAIxC,KAAK,CAAC8D,OAAO,CAACtB,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE;IACtG;IACA;IACA;IACAA,MAAM,CAAC,MAAM,CAAC,GAAGxC,KAAK,CAACJ,IAAI,CAAC,IAAImH,GAAG,CAACvE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IACpD;IACA;IACA;IACA;IACA,IAAIgC,sBAAsB,EAAE;MACxB,IAAIwC,KAAK,GAAGxE,MAAM,CAAC,MAAM,CAAC,CACrBa,MAAM,CAACC,OAAO,CAAC,CACf2D,GAAG,CAAC,UAAU3E,GAAG,EAAE;QAAE,OAAO,GAAG,CAACpC,MAAM,CAACoC,GAAG,EAAE,GAAG,CAAC;MAAE,CAAC,CAAC,CACpD4E,IAAI,CAAC,GAAG,CAAC;MACd,IAAIF,KAAK,CAACtJ,MAAM,EAAE;QACd,IAAI,aAAa,IAAI8E,MAAM,EAAE;UACzBA,MAAM,CAAC2E,WAAW,IAAI,MAAM,CAACjH,MAAM,CAAC8G,KAAK,CAAC;QAC9C,CAAC,MACI;UACDxE,MAAM,CAAC2E,WAAW,GAAGH,KAAK;QAC9B;MACJ;IACJ;EACJ;EACA;EACA;EACA,IAAI,OAAO,IAAIxE,MAAM,IAAI,OAAO,IAAIA,MAAM,EAAE;IACxC,IAAI,YAAY,IAAIA,MAAM,EAAE;MACxB,OAAOA,MAAM,CAACqD,UAAU;IAC5B;IACA,IAAI,OAAO,IAAIrD,MAAM,EAAE;MACnB,OAAOA,MAAM,CAACsD,KAAK;IACvB;EACJ;EACA;EACA,KAAK,IAAIvI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoD,wBAAwB,CAACjD,MAAM,EAAEH,CAAC,IAAI,CAAC,EAAE;IACzD;IACA;IACA,OAAOiF,MAAM,CAAC7B,wBAAwB,CAACpD,CAAC,CAAC,CAAC;EAC9C;EACA,OAAOuH,WAAW,CAACtC,MAAM,CAAC;AAC9B;AACApC,OAAO,CAAC,SAAS,CAAC,GAAG6D,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}