{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRealtimeClient = createRealtimeClient;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst msgpack_1 = require(\"@msgpack/msgpack\");\nconst robot3_1 = require(\"robot3\");\nconst auth_1 = require(\"./auth\");\nconst response_1 = require(\"./response\");\nconst runtime_1 = require(\"./runtime\");\nconst utils_1 = require(\"./utils\");\nconst initialState = () => ({\n  enqueuedMessage: undefined\n});\nfunction hasToken(context) {\n  return context.token !== undefined;\n}\nfunction noToken(context) {\n  return !hasToken(context);\n}\nfunction enqueueMessage(context, event) {\n  return Object.assign(Object.assign({}, context), {\n    enqueuedMessage: event.message\n  });\n}\nfunction closeConnection(context) {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    context.websocket.close();\n  }\n  return Object.assign(Object.assign({}, context), {\n    websocket: undefined\n  });\n}\nfunction sendMessage(context, event) {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    if (event.message instanceof Uint8Array) {\n      context.websocket.send(event.message);\n    } else {\n      context.websocket.send((0, msgpack_1.encode)(event.message));\n    }\n    return Object.assign(Object.assign({}, context), {\n      enqueuedMessage: undefined\n    });\n  }\n  return Object.assign(Object.assign({}, context), {\n    enqueuedMessage: event.message\n  });\n}\nfunction expireToken(context) {\n  return Object.assign(Object.assign({}, context), {\n    token: undefined\n  });\n}\nfunction setToken(context, event) {\n  return Object.assign(Object.assign({}, context), {\n    token: event.token\n  });\n}\nfunction connectionEstablished(context, event) {\n  return Object.assign(Object.assign({}, context), {\n    websocket: event.websocket\n  });\n}\n// State machine\nconst connectionStateMachine = (0, robot3_1.createMachine)(\"idle\", {\n  idle: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"expireToken\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n  connecting: (0, robot3_1.state)((0, robot3_1.transition)(\"connecting\", \"connecting\"), (0, robot3_1.transition)(\"connected\", \"active\", (0, robot3_1.reduce)(connectionEstablished)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.immediate)(\"authRequired\", (0, robot3_1.guard)(noToken))),\n  authRequired: (0, robot3_1.state)((0, robot3_1.transition)(\"initiateAuth\", \"authInProgress\"), (0, robot3_1.transition)(\"send\", \"authRequired\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n  authInProgress: (0, robot3_1.state)((0, robot3_1.transition)(\"authenticated\", \"connecting\", (0, robot3_1.reduce)(setToken)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken), (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"authInProgress\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n  active: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"active\", (0, robot3_1.reduce)(sendMessage)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n  failed: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"failed\"), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection)))\n}, initialState);\nfunction buildRealtimeUrl(app, {\n  token,\n  maxBuffering\n}) {\n  if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n    throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n  }\n  const queryParams = new URLSearchParams({\n    fal_jwt_token: token\n  });\n  if (maxBuffering !== undefined) {\n    queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n  }\n  const appId = (0, utils_1.ensureEndpointIdFormat)(app);\n  return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\nconst DEFAULT_THROTTLE_INTERVAL = 128;\nfunction isUnauthorizedError(message) {\n  // TODO we need better protocol definition with error codes\n  return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n  NORMAL_CLOSURE: 1000,\n  GOING_AWAY: 1001\n};\nconst connectionCache = new Map();\nconst connectionCallbacks = new Map();\nfunction reuseInterpreter(key, throttleInterval, onChange) {\n  if (!connectionCache.has(key)) {\n    const machine = (0, robot3_1.interpret)(connectionStateMachine, onChange);\n    connectionCache.set(key, Object.assign(Object.assign({}, machine), {\n      throttledSend: throttleInterval > 0 ? (0, utils_1.throttle)(machine.send, throttleInterval, true) : machine.send\n    }));\n  }\n  return connectionCache.get(key);\n}\nconst noop = () => {\n  /* No-op */\n};\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection = {\n  send: noop,\n  close: noop\n};\nfunction isSuccessfulResult(data) {\n  return data.status !== \"error\" && data.type !== \"x-fal-message\" && !isFalErrorResult(data);\n}\nfunction isFalErrorResult(data) {\n  return data.type === \"x-fal-error\";\n}\nfunction createRealtimeClient({\n  config\n}) {\n  return {\n    connect(app, handler) {\n      const {\n        // if running on React in the server, set clientOnly to true by default\n        clientOnly = (0, utils_1.isReact)() && !(0, runtime_1.isBrowser)(),\n        connectionKey = crypto.randomUUID(),\n        maxBuffering,\n        throttleInterval = DEFAULT_THROTTLE_INTERVAL\n      } = handler;\n      if (clientOnly && !(0, runtime_1.isBrowser)()) {\n        return NoOpConnection;\n      }\n      let previousState;\n      // Although the state machine is cached so we don't open multiple connections,\n      // we still need to update the callbacks so we can call the correct references\n      // when the state machine is reused. This is needed because the callbacks\n      // are passed as part of the handler object, which can be different across\n      // different calls to `connect`.\n      connectionCallbacks.set(connectionKey, {\n        onError: handler.onError,\n        onResult: handler.onResult\n      });\n      const getCallbacks = () => connectionCallbacks.get(connectionKey);\n      const stateMachine = reuseInterpreter(connectionKey, throttleInterval, ({\n        context,\n        machine,\n        send\n      }) => {\n        const {\n          enqueuedMessage,\n          token\n        } = context;\n        if (machine.current === \"active\" && enqueuedMessage) {\n          send({\n            type: \"send\",\n            message: enqueuedMessage\n          });\n        }\n        if (machine.current === \"authRequired\" && token === undefined && previousState !== machine.current) {\n          send({\n            type: \"initiateAuth\"\n          });\n          (0, auth_1.getTemporaryAuthToken)(app, config).then(token => {\n            send({\n              type: \"authenticated\",\n              token\n            });\n            const tokenExpirationTimeout = Math.round(auth_1.TOKEN_EXPIRATION_SECONDS * 0.9 * 1000);\n            setTimeout(() => {\n              send({\n                type: \"expireToken\"\n              });\n            }, tokenExpirationTimeout);\n          }).catch(error => {\n            send({\n              type: \"unauthorized\",\n              error\n            });\n          });\n        }\n        if (machine.current === \"connecting\" && previousState !== machine.current && token !== undefined) {\n          const ws = new WebSocket(buildRealtimeUrl(app, {\n            token,\n            maxBuffering\n          }));\n          ws.onopen = () => {\n            send({\n              type: \"connected\",\n              websocket: ws\n            });\n          };\n          ws.onclose = event => {\n            if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n              const {\n                onError = noop\n              } = getCallbacks();\n              onError(new response_1.ApiError({\n                message: `Error closing the connection: ${event.reason}`,\n                status: event.code\n              }));\n            }\n            send({\n              type: \"connectionClosed\",\n              code: event.code\n            });\n          };\n          ws.onerror = event => {\n            // TODO specify error protocol for identified errors\n            const {\n              onError = noop\n            } = getCallbacks();\n            onError(new response_1.ApiError({\n              message: \"Unknown error\",\n              status: 500\n            }));\n          };\n          ws.onmessage = event => {\n            const {\n              onResult\n            } = getCallbacks();\n            // Handle binary messages as msgpack messages\n            if (event.data instanceof ArrayBuffer) {\n              const result = (0, msgpack_1.decode)(new Uint8Array(event.data));\n              onResult(result);\n              return;\n            }\n            if (event.data instanceof Uint8Array) {\n              const result = (0, msgpack_1.decode)(event.data);\n              onResult(result);\n              return;\n            }\n            if (event.data instanceof Blob) {\n              event.data.arrayBuffer().then(buffer => {\n                const result = (0, msgpack_1.decode)(new Uint8Array(buffer));\n                onResult(result);\n              });\n              return;\n            }\n            // Otherwise handle strings as plain JSON messages\n            const data = JSON.parse(event.data);\n            // Drop messages that are not related to the actual result.\n            // In the future, we might want to handle other types of messages.\n            // TODO: specify the fal ws protocol format\n            if (isUnauthorizedError(data)) {\n              send({\n                type: \"unauthorized\",\n                error: new Error(\"Unauthorized\")\n              });\n              return;\n            }\n            if (isSuccessfulResult(data)) {\n              onResult(data);\n              return;\n            }\n            if (isFalErrorResult(data)) {\n              if (data.error === \"TIMEOUT\") {\n                // Timeout error messages just indicate that the connection hasn't\n                // received an incoming message for a while. We don't need to\n                // handle them as errors.\n                return;\n              }\n              const {\n                onError = noop\n              } = getCallbacks();\n              onError(new response_1.ApiError({\n                message: `${data.error}: ${data.reason}`,\n                // TODO better error status code\n                status: 400,\n                body: data\n              }));\n              return;\n            }\n          };\n        }\n        previousState = machine.current;\n      });\n      const send = input => {\n        // Use throttled send to avoid sending too many messages\n        stateMachine.throttledSend({\n          type: \"send\",\n          message: input\n        });\n      };\n      const close = () => {\n        stateMachine.send({\n          type: \"close\"\n        });\n      };\n      return {\n        send,\n        close\n      };\n    }\n  };\n}","map":{"version":3,"names":["exports","createRealtimeClient","msgpack_1","require","robot3_1","auth_1","response_1","runtime_1","utils_1","initialState","enqueuedMessage","undefined","hasToken","context","token","noToken","enqueueMessage","event","Object","assign","message","closeConnection","websocket","readyState","WebSocket","OPEN","close","sendMessage","Uint8Array","send","encode","expireToken","setToken","connectionEstablished","connectionStateMachine","createMachine","idle","state","transition","reduce","connecting","immediate","guard","authRequired","authInProgress","active","failed","buildRealtimeUrl","app","maxBuffering","Error","queryParams","URLSearchParams","fal_jwt_token","set","toFixed","appId","ensureEndpointIdFormat","toString","DEFAULT_THROTTLE_INTERVAL","isUnauthorizedError","WebSocketErrorCodes","NORMAL_CLOSURE","GOING_AWAY","connectionCache","Map","connectionCallbacks","reuseInterpreter","key","throttleInterval","onChange","has","machine","interpret","throttledSend","throttle","get","noop","NoOpConnection","isSuccessfulResult","data","status","type","isFalErrorResult","config","connect","handler","clientOnly","isReact","isBrowser","connectionKey","crypto","randomUUID","previousState","onError","onResult","getCallbacks","stateMachine","current","getTemporaryAuthToken","then","tokenExpirationTimeout","Math","round","TOKEN_EXPIRATION_SECONDS","setTimeout","catch","error","ws","onopen","onclose","code","ApiError","reason","onerror","onmessage","ArrayBuffer","result","decode","Blob","arrayBuffer","buffer","JSON","parse","body","input"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/libs/client/src/realtime.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { decode, encode } from \"@msgpack/msgpack\";\nimport {\n  ContextFunction,\n  InterpretOnChangeFunction,\n  Service,\n  createMachine,\n  guard,\n  immediate,\n  interpret,\n  reduce,\n  state,\n  transition,\n} from \"robot3\";\nimport { TOKEN_EXPIRATION_SECONDS, getTemporaryAuthToken } from \"./auth\";\nimport { RequiredConfig } from \"./config\";\nimport { ApiError } from \"./response\";\nimport { isBrowser } from \"./runtime\";\nimport { ensureEndpointIdFormat, isReact, throttle } from \"./utils\";\n\n// Define the context\ninterface Context {\n  token?: string;\n  enqueuedMessage?: any;\n  websocket?: WebSocket;\n  error?: Error;\n}\n\nconst initialState: ContextFunction<Context> = () => ({\n  enqueuedMessage: undefined,\n});\n\ntype SendEvent = { type: \"send\"; message: any };\ntype AuthenticatedEvent = { type: \"authenticated\"; token: string };\ntype InitiateAuthEvent = { type: \"initiateAuth\" };\ntype UnauthorizedEvent = { type: \"unauthorized\"; error: Error };\ntype ConnectedEvent = { type: \"connected\"; websocket: WebSocket };\ntype ConnectionClosedEvent = {\n  type: \"connectionClosed\";\n  code: number;\n  reason: string;\n};\n\ntype Event =\n  | SendEvent\n  | AuthenticatedEvent\n  | InitiateAuthEvent\n  | UnauthorizedEvent\n  | ConnectedEvent\n  | ConnectionClosedEvent;\n\nfunction hasToken(context: Context): boolean {\n  return context.token !== undefined;\n}\n\nfunction noToken(context: Context): boolean {\n  return !hasToken(context);\n}\n\nfunction enqueueMessage(context: Context, event: SendEvent): Context {\n  return {\n    ...context,\n    enqueuedMessage: event.message,\n  };\n}\n\nfunction closeConnection(context: Context): Context {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    context.websocket.close();\n  }\n  return {\n    ...context,\n    websocket: undefined,\n  };\n}\n\nfunction sendMessage(context: Context, event: SendEvent): Context {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    if (event.message instanceof Uint8Array) {\n      context.websocket.send(event.message);\n    } else {\n      context.websocket.send(encode(event.message));\n    }\n\n    return {\n      ...context,\n      enqueuedMessage: undefined,\n    };\n  }\n  return {\n    ...context,\n    enqueuedMessage: event.message,\n  };\n}\n\nfunction expireToken(context: Context): Context {\n  return {\n    ...context,\n    token: undefined,\n  };\n}\n\nfunction setToken(context: Context, event: AuthenticatedEvent): Context {\n  return {\n    ...context,\n    token: event.token,\n  };\n}\n\nfunction connectionEstablished(\n  context: Context,\n  event: ConnectedEvent,\n): Context {\n  return {\n    ...context,\n    websocket: event.websocket,\n  };\n}\n\n// State machine\nconst connectionStateMachine = createMachine(\n  \"idle\",\n  {\n    idle: state(\n      transition(\"send\", \"connecting\", reduce(enqueueMessage)),\n      transition(\"expireToken\", \"idle\", reduce(expireToken)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    connecting: state(\n      transition(\"connecting\", \"connecting\"),\n      transition(\"connected\", \"active\", reduce(connectionEstablished)),\n      transition(\"connectionClosed\", \"idle\", reduce(closeConnection)),\n      transition(\"send\", \"connecting\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n      immediate(\"authRequired\", guard(noToken)),\n    ),\n    authRequired: state(\n      transition(\"initiateAuth\", \"authInProgress\"),\n      transition(\"send\", \"authRequired\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    authInProgress: state(\n      transition(\"authenticated\", \"connecting\", reduce(setToken)),\n      transition(\n        \"unauthorized\",\n        \"idle\",\n        reduce(expireToken),\n        reduce(closeConnection),\n      ),\n      transition(\"send\", \"authInProgress\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    active: state(\n      transition(\"send\", \"active\", reduce(sendMessage)),\n      transition(\"unauthorized\", \"idle\", reduce(expireToken)),\n      transition(\"connectionClosed\", \"idle\", reduce(closeConnection)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    failed: state(\n      transition(\"send\", \"failed\"),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n  },\n  initialState,\n);\n\ntype WithRequestId = {\n  request_id: string;\n};\n\n/**\n * A connection object that allows you to `send` request payloads to a\n * realtime endpoint.\n */\nexport interface RealtimeConnection<Input> {\n  send(input: Input & Partial<WithRequestId>): void;\n\n  close(): void;\n}\n\n/**\n * Options for connecting to the realtime endpoint.\n */\nexport interface RealtimeConnectionHandler<Output> {\n  /**\n   * The connection key. This is used to reuse the same connection\n   * across multiple calls to `connect`. This is particularly useful in\n   * contexts where the connection is established as part of a component\n   * lifecycle (e.g. React) and the component is re-rendered multiple times.\n   */\n  connectionKey?: string;\n\n  /**\n   * If `true`, the connection will only be established on the client side.\n   * This is useful for frameworks that reuse code for both server-side\n   * rendering and client-side rendering (e.g. Next.js).\n   *\n   * This is set to `true` by default when running on React in the server.\n   * Otherwise, it is set to `false`.\n   *\n   * Note that more SSR frameworks might be automatically detected\n   * in the future. In the meantime, you can set this to `true` when needed.\n   */\n  clientOnly?: boolean;\n\n  /**\n   * The throtle duration in milliseconds. This is used to throtle the\n   * calls to the `send` function. Realtime apps usually react to user\n   * input, which can be very frequent (e.g. fast typing or mouse/drag movements).\n   *\n   * The default value is `128` milliseconds.\n   */\n  throttleInterval?: number;\n\n  /**\n   * Configures the maximum amount of frames to store in memory before starting to drop\n   * old ones for in favor of the newer ones. It must be between `1` and `60`.\n   *\n   * The recommended is `2`. The default is `undefined` so it can be determined\n   * by the app (normally is set to the recommended setting).\n   */\n  maxBuffering?: number;\n\n  /**\n   * Callback function that is called when a result is received.\n   * @param result - The result of the request.\n   */\n  onResult(result: Output & WithRequestId): void;\n\n  /**\n   * Callback function that is called when an error occurs.\n   * @param error - The error that occurred.\n   */\n  onError?(error: ApiError<any>): void;\n}\n\nexport interface RealtimeClient {\n  /**\n   * Connect to the realtime endpoint. The default implementation uses\n   * WebSockets to connect to fal function endpoints that support WSS.\n   *\n   * @param app the app alias or identifier.\n   * @param handler the connection handler.\n   */\n  connect<Input = any, Output = any>(\n    app: string,\n    handler: RealtimeConnectionHandler<Output>,\n  ): RealtimeConnection<Input>;\n}\n\ntype RealtimeUrlParams = {\n  token: string;\n  maxBuffering?: number;\n};\n\nfunction buildRealtimeUrl(\n  app: string,\n  { token, maxBuffering }: RealtimeUrlParams,\n): string {\n  if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n    throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n  }\n  const queryParams = new URLSearchParams({\n    fal_jwt_token: token,\n  });\n  if (maxBuffering !== undefined) {\n    queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n  }\n  const appId = ensureEndpointIdFormat(app);\n  return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\n\nconst DEFAULT_THROTTLE_INTERVAL = 128;\n\nfunction isUnauthorizedError(message: any): boolean {\n  // TODO we need better protocol definition with error codes\n  return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n  NORMAL_CLOSURE: 1000,\n  GOING_AWAY: 1001,\n};\n\ntype ConnectionStateMachine = Service<typeof connectionStateMachine> & {\n  throttledSend: (\n    event: Event,\n    payload?: any,\n  ) => void | Promise<void> | undefined;\n};\n\ntype ConnectionOnChange = InterpretOnChangeFunction<\n  typeof connectionStateMachine\n>;\n\ntype RealtimeConnectionCallback = Pick<\n  RealtimeConnectionHandler<any>,\n  \"onResult\" | \"onError\"\n>;\n\nconst connectionCache = new Map<string, ConnectionStateMachine>();\nconst connectionCallbacks = new Map<string, RealtimeConnectionCallback>();\nfunction reuseInterpreter(\n  key: string,\n  throttleInterval: number,\n  onChange: ConnectionOnChange,\n) {\n  if (!connectionCache.has(key)) {\n    const machine = interpret(connectionStateMachine, onChange);\n    connectionCache.set(key, {\n      ...machine,\n      throttledSend:\n        throttleInterval > 0\n          ? throttle(machine.send, throttleInterval, true)\n          : machine.send,\n    });\n  }\n  return connectionCache.get(key) as ConnectionStateMachine;\n}\n\nconst noop = () => {\n  /* No-op */\n};\n\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection: RealtimeConnection<any> = {\n  send: noop,\n  close: noop,\n};\n\nfunction isSuccessfulResult(data: any): boolean {\n  return (\n    data.status !== \"error\" &&\n    data.type !== \"x-fal-message\" &&\n    !isFalErrorResult(data)\n  );\n}\n\ntype FalErrorResult = {\n  type: \"x-fal-error\";\n  error: string;\n  reason: string;\n};\n\nfunction isFalErrorResult(data: any): data is FalErrorResult {\n  return data.type === \"x-fal-error\";\n}\n\ntype RealtimeClientDependencies = {\n  config: RequiredConfig;\n};\n\nexport function createRealtimeClient({\n  config,\n}: RealtimeClientDependencies): RealtimeClient {\n  return {\n    connect<Input, Output>(\n      app: string,\n      handler: RealtimeConnectionHandler<Output>,\n    ): RealtimeConnection<Input> {\n      const {\n        // if running on React in the server, set clientOnly to true by default\n        clientOnly = isReact() && !isBrowser(),\n        connectionKey = crypto.randomUUID(),\n        maxBuffering,\n        throttleInterval = DEFAULT_THROTTLE_INTERVAL,\n      } = handler;\n      if (clientOnly && !isBrowser()) {\n        return NoOpConnection;\n      }\n\n      let previousState: string | undefined;\n\n      // Although the state machine is cached so we don't open multiple connections,\n      // we still need to update the callbacks so we can call the correct references\n      // when the state machine is reused. This is needed because the callbacks\n      // are passed as part of the handler object, which can be different across\n      // different calls to `connect`.\n      connectionCallbacks.set(connectionKey, {\n        onError: handler.onError,\n        onResult: handler.onResult,\n      });\n      const getCallbacks = () =>\n        connectionCallbacks.get(connectionKey) as RealtimeConnectionCallback;\n      const stateMachine = reuseInterpreter(\n        connectionKey,\n        throttleInterval,\n        ({ context, machine, send }) => {\n          const { enqueuedMessage, token } = context;\n          if (machine.current === \"active\" && enqueuedMessage) {\n            send({ type: \"send\", message: enqueuedMessage });\n          }\n          if (\n            machine.current === \"authRequired\" &&\n            token === undefined &&\n            previousState !== machine.current\n          ) {\n            send({ type: \"initiateAuth\" });\n            getTemporaryAuthToken(app, config)\n              .then((token) => {\n                send({ type: \"authenticated\", token });\n                const tokenExpirationTimeout = Math.round(\n                  TOKEN_EXPIRATION_SECONDS * 0.9 * 1000,\n                );\n                setTimeout(() => {\n                  send({ type: \"expireToken\" });\n                }, tokenExpirationTimeout);\n              })\n              .catch((error) => {\n                send({ type: \"unauthorized\", error });\n              });\n          }\n          if (\n            machine.current === \"connecting\" &&\n            previousState !== machine.current &&\n            token !== undefined\n          ) {\n            const ws = new WebSocket(\n              buildRealtimeUrl(app, { token, maxBuffering }),\n            );\n            ws.onopen = () => {\n              send({ type: \"connected\", websocket: ws });\n            };\n            ws.onclose = (event) => {\n              if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n                const { onError = noop } = getCallbacks();\n                onError(\n                  new ApiError({\n                    message: `Error closing the connection: ${event.reason}`,\n                    status: event.code,\n                  }),\n                );\n              }\n              send({ type: \"connectionClosed\", code: event.code });\n            };\n            ws.onerror = (event) => {\n              // TODO specify error protocol for identified errors\n              const { onError = noop } = getCallbacks();\n              onError(new ApiError({ message: \"Unknown error\", status: 500 }));\n            };\n            ws.onmessage = (event) => {\n              const { onResult } = getCallbacks();\n\n              // Handle binary messages as msgpack messages\n              if (event.data instanceof ArrayBuffer) {\n                const result = decode(new Uint8Array(event.data));\n                onResult(result);\n                return;\n              }\n              if (event.data instanceof Uint8Array) {\n                const result = decode(event.data);\n                onResult(result);\n                return;\n              }\n              if (event.data instanceof Blob) {\n                event.data.arrayBuffer().then((buffer) => {\n                  const result = decode(new Uint8Array(buffer));\n                  onResult(result);\n                });\n                return;\n              }\n\n              // Otherwise handle strings as plain JSON messages\n              const data = JSON.parse(event.data);\n\n              // Drop messages that are not related to the actual result.\n              // In the future, we might want to handle other types of messages.\n              // TODO: specify the fal ws protocol format\n              if (isUnauthorizedError(data)) {\n                send({\n                  type: \"unauthorized\",\n                  error: new Error(\"Unauthorized\"),\n                });\n                return;\n              }\n              if (isSuccessfulResult(data)) {\n                onResult(data);\n                return;\n              }\n              if (isFalErrorResult(data)) {\n                if (data.error === \"TIMEOUT\") {\n                  // Timeout error messages just indicate that the connection hasn't\n                  // received an incoming message for a while. We don't need to\n                  // handle them as errors.\n                  return;\n                }\n                const { onError = noop } = getCallbacks();\n                onError(\n                  new ApiError({\n                    message: `${data.error}: ${data.reason}`,\n                    // TODO better error status code\n                    status: 400,\n                    body: data,\n                  }),\n                );\n                return;\n              }\n            };\n          }\n          previousState = machine.current;\n        },\n      );\n\n      const send = (input: Input & Partial<WithRequestId>) => {\n        // Use throttled send to avoid sending too many messages\n        stateMachine.throttledSend({\n          type: \"send\",\n          message: input,\n        });\n      };\n\n      const close = () => {\n        stateMachine.send({ type: \"close\" });\n      };\n\n      return {\n        send,\n        close,\n      };\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}