{"ast":null,"code":"// This export needs to be loaded before everything else or else this export doesn't work. ü§∑‚Äç‚ôÇÔ∏è\nmodule.exports = $Ref;\nconst Pointer = require('./pointer');\nconst {\n  InvalidPointerError,\n  isHandledError,\n  normalizeError\n} = require('./util/errors');\nconst {\n  safePointerToPath,\n  stripHash,\n  getHash\n} = require('./util/url');\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nfunction $Ref() {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   *\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   *\n   * @type {$Refs}\n   */\n  this.$refs = undefined;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   *\n   * @type {?string}\n   */\n  this.pathType = undefined;\n\n  /**\n   * List of all errors. Undefined if no errors.\n   *\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */\n  this.errors = undefined;\n}\n\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed\n * @returns {void}\n */\n$Ref.prototype.addError = function (err) {\n  if (this.errors === undefined) {\n    this.errors = [];\n  }\n  const existingErrors = this.errors.map(({\n    footprint\n  }) => footprint);\n\n  // the path has been almost certainly set at this point,\n  // but just in case something went wrong, normalizeError injects path if necessary\n  // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n  if (Array.isArray(err.errors)) {\n    this.errors.push(...err.errors.map(normalizeError).filter(({\n      footprint\n    }) => !existingErrors.includes(footprint)));\n  } else if (!existingErrors.includes(err.footprint)) {\n    this.errors.push(normalizeError(err));\n  }\n};\n\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n *  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer | null}\n */\n$Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {\n  const pointer = new Pointer(this, path, friendlyPath);\n  try {\n    return pointer.resolve(this.value, options, pathFromRoot);\n  } catch (err) {\n    if (!options || !options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n    if (err.path === null) {\n      err.path = safePointerToPath(getHash(pathFromRoot));\n    }\n    if (err instanceof InvalidPointerError) {\n      // this is a special case - InvalidPointerError is thrown when dereferencing external file,\n      // but the issue is caused by the source file that referenced the file that undergoes dereferencing\n      err.source = stripHash(pathFromRoot);\n    }\n    this.addError(err);\n    return null;\n  }\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Ref.prototype.set = function (path, value) {\n  const pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.is$Ref = function (value) {\n  return value && typeof value === 'object' && typeof value.$ref === 'string' && value.$ref.length > 0;\n};\n\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== '#';\n};\n\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === '#/' || value.$ref === '#') {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    } else if (value.$ref[0] !== '#' && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === 'object' && $Ref.isExtended$Ref($ref)) {\n    const merged = {};\n    for (const key of Object.keys($ref)) {\n      if (key !== '$ref') {\n        merged[key] = $ref[key];\n      }\n    }\n    for (const key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n    return merged;\n  }\n\n  // Completely replace the original reference with the resolved value\n  return resolvedValue;\n};","map":{"version":3,"names":["module","exports","$Ref","Pointer","require","InvalidPointerError","isHandledError","normalizeError","safePointerToPath","stripHash","getHash","path","undefined","value","$refs","pathType","errors","prototype","addError","err","existingErrors","map","footprint","Array","isArray","push","filter","includes","exists","options","resolve","e","get","friendlyPath","pathFromRoot","pointer","continueOnError","source","set","is$Ref","$ref","length","isExternal$Ref","isAllowed$Ref","substr","external","isExtended$Ref","Object","keys","dereference","resolvedValue","merged","key"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/ref.js"],"sourcesContent":["// This export needs to be loaded before everything else or else this export doesn't work. ü§∑‚Äç‚ôÇÔ∏è\nmodule.exports = $Ref;\n\nconst Pointer = require('./pointer');\nconst { InvalidPointerError, isHandledError, normalizeError } = require('./util/errors');\nconst { safePointerToPath, stripHash, getHash } = require('./util/url');\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nfunction $Ref() {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   *\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   *\n   * @type {$Refs}\n   */\n  this.$refs = undefined;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   *\n   * @type {?string}\n   */\n  this.pathType = undefined;\n\n  /**\n   * List of all errors. Undefined if no errors.\n   *\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */\n  this.errors = undefined;\n}\n\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed\n * @returns {void}\n */\n$Ref.prototype.addError = function (err) {\n  if (this.errors === undefined) {\n    this.errors = [];\n  }\n\n  const existingErrors = this.errors.map(({ footprint }) => footprint);\n\n  // the path has been almost certainly set at this point,\n  // but just in case something went wrong, normalizeError injects path if necessary\n  // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n  if (Array.isArray(err.errors)) {\n    this.errors.push(...err.errors.map(normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint)));\n  } else if (!existingErrors.includes(err.footprint)) {\n    this.errors.push(normalizeError(err));\n  }\n};\n\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n *  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer | null}\n */\n$Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {\n  const pointer = new Pointer(this, path, friendlyPath);\n  try {\n    return pointer.resolve(this.value, options, pathFromRoot);\n  } catch (err) {\n    if (!options || !options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if (err.path === null) {\n      err.path = safePointerToPath(getHash(pathFromRoot));\n    }\n\n    if (err instanceof InvalidPointerError) {\n      // this is a special case - InvalidPointerError is thrown when dereferencing external file,\n      // but the issue is caused by the source file that referenced the file that undergoes dereferencing\n      err.source = stripHash(pathFromRoot);\n    }\n\n    this.addError(err);\n    return null;\n  }\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Ref.prototype.set = function (path, value) {\n  const pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.is$Ref = function (value) {\n  return value && typeof value === 'object' && typeof value.$ref === 'string' && value.$ref.length > 0;\n};\n\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== '#';\n};\n\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === '#/' || value.$ref === '#') {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    } else if (value.$ref[0] !== '#' && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === 'object' && $Ref.isExtended$Ref($ref)) {\n    const merged = {};\n    for (const key of Object.keys($ref)) {\n      if (key !== '$ref') {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (const key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  }\n\n  // Completely replace the original reference with the resolved value\n  return resolvedValue;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}