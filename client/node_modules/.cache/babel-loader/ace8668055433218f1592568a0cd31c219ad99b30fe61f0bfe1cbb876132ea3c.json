{"ast":null,"code":"const parse = require('./parse');\nconst Pointer = require('./pointer');\nconst $Ref = require('./ref');\nconst {\n  isHandledError\n} = require('./util/errors');\nconst url = require('./util/url');\nmodule.exports = resolveExternal;\n\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal(parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    const promises = crawl(parser.schema, `${parser.$refs._root$Ref.path}#`, parser.$refs, options);\n    return Promise.all(promises);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @param {Set} seen - Internal.\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl(obj, path, $refs, options, seen) {\n  // eslint-disable-next-line no-param-reassign\n  seen = seen || new Set();\n  let promises = [];\n  if (obj && typeof obj === 'object' && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n    seen.add(obj); // Track previously seen objects to avoid infinite recursion\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    } else {\n      for (const key of Object.keys(obj)) {\n        const keyPath = Pointer.join(path, key);\n        const value = obj[key];\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        } else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options, seen));\n        }\n      }\n    }\n  }\n  return promises;\n}\n\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  const resolvedPath = url.resolve(path, $ref.$ref);\n  const withoutHash = url.stripHash(resolvedPath);\n\n  // Do we already have this $ref?\n  // eslint-disable-next-line no-param-reassign\n  $ref = $refs._$refs[withoutHash];\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  }\n\n  // Parse the $referenced file/url\n  try {\n    const result = await parse(resolvedPath, $refs, options);\n\n    // Crawl the parsed value\n    // console.log('Resolving $ref pointers in %s', withoutHash);\n    const promises = crawl(result, `${withoutHash}#`, $refs, options);\n    return Promise.all(promises);\n  } catch (err) {\n    if (!options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n    if ($refs._$refs[withoutHash]) {\n      err.source = url.stripHash(path);\n      err.path = url.safePointerToPath(url.getHash(path));\n    }\n    return [];\n  }\n}","map":{"version":3,"names":["parse","require","Pointer","$Ref","isHandledError","url","module","exports","resolveExternal","parser","options","resolve","external","Promise","promises","crawl","schema","$refs","_root$Ref","path","all","e","reject","obj","seen","Set","ArrayBuffer","isView","has","add","isExternal$Ref","push","resolve$Ref","key","Object","keys","keyPath","join","value","concat","$ref","resolvedPath","withoutHash","stripHash","_$refs","result","err","continueOnError","source","safePointerToPath","getHash"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/resolve-external.js"],"sourcesContent":["const parse = require('./parse');\nconst Pointer = require('./pointer');\nconst $Ref = require('./ref');\nconst { isHandledError } = require('./util/errors');\nconst url = require('./util/url');\n\nmodule.exports = resolveExternal;\n\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal(parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    const promises = crawl(parser.schema, `${parser.$refs._root$Ref.path}#`, parser.$refs, options);\n    return Promise.all(promises);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @param {Set} seen - Internal.\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl(obj, path, $refs, options, seen) {\n  // eslint-disable-next-line no-param-reassign\n  seen = seen || new Set();\n  let promises = [];\n\n  if (obj && typeof obj === 'object' && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n    seen.add(obj); // Track previously seen objects to avoid infinite recursion\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    } else {\n      for (const key of Object.keys(obj)) {\n        const keyPath = Pointer.join(path, key);\n        const value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        } else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options, seen));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  const resolvedPath = url.resolve(path, $ref.$ref);\n  const withoutHash = url.stripHash(resolvedPath);\n\n  // Do we already have this $ref?\n  // eslint-disable-next-line no-param-reassign\n  $ref = $refs._$refs[withoutHash];\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  }\n\n  // Parse the $referenced file/url\n  try {\n    const result = await parse(resolvedPath, $refs, options);\n\n    // Crawl the parsed value\n    // console.log('Resolving $ref pointers in %s', withoutHash);\n    const promises = crawl(result, `${withoutHash}#`, $refs, options);\n\n    return Promise.all(promises);\n  } catch (err) {\n    if (!options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if ($refs._$refs[withoutHash]) {\n      err.source = url.stripHash(path);\n      err.path = url.safePointerToPath(url.getHash(path));\n    }\n\n    return [];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}