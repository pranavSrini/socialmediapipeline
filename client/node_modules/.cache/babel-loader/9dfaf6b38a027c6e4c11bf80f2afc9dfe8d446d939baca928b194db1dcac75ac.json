{"ast":null,"code":"/* eslint-disable no-param-reassign */\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst Pointer = require('./pointer');\nconst $Ref = require('./ref');\nconst url = require('./util/url');\n\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\nmodule.exports = function dereference(parser, options) {\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n  const dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, '#', new Set(), new Set(), new Map(), parser.$refs, options);\n  parser.$refs.circular = dereferenced.circular;\n  parser.schema = dereferenced.value;\n};\n\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been processed\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  let dereferenced;\n  const result = {\n    value: obj,\n    circular: false\n  };\n  if (options.dereference.circular === 'ignore' || !processedObjects.has(obj)) {\n    if (obj && typeof obj === 'object' && !ArrayBuffer.isView(obj)) {\n      parents.add(obj);\n      processedObjects.add(obj);\n      if ($Ref.isAllowed$Ref(obj, options)) {\n        dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n        result.circular = dereferenced.circular;\n        result.value = dereferenced.value;\n\n        // OpenAPI 3.1 $ref overrides: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-19\n        if (obj.description) {\n          result.value.description = obj.description;\n        }\n        if (obj.summary) {\n          result.value.summary = obj.summary;\n        }\n      } else {\n        for (const key of Object.keys(obj)) {\n          const keyPath = Pointer.join(path, key);\n          const keyPathFromRoot = Pointer.join(pathFromRoot, key);\n          const value = obj[key];\n          let circular = false;\n          if ($Ref.isAllowed$Ref(value, options)) {\n            dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n            circular = dereferenced.circular;\n\n            // Avoid pointless mutations; breaks frozen objects to no profit\n            if (obj[key] !== dereferenced.value) {\n              obj[key] = dereferenced.value;\n\n              // OpenAPI 3.1 $ref overrides: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-19\n              if (value.description) {\n                obj[key].description = value.description;\n              }\n              if (value.summary) {\n                obj[key].summary = value.summary;\n              }\n            }\n          } else if (!parents.has(value)) {\n            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n            circular = dereferenced.circular;\n\n            // Avoid pointless mutations; breaks frozen objects to no profit\n            if (obj[key] !== dereferenced.value) {\n              obj[key] = dereferenced.value;\n            }\n          } else {\n            circular = foundCircularReference(keyPath, $refs, options);\n          }\n\n          // Set the \"isCircular\" flag if this or any other property is circular\n          result.circular = result.circular || circular;\n        }\n      }\n      parents.delete(obj);\n    }\n  }\n  return result;\n}\n\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  const $refPath = url.resolve(path, $ref.$ref);\n  const cache = dereferencedCache.get($refPath);\n  if (cache) {\n    const refKeys = Object.keys($ref);\n    if (refKeys.length > 1) {\n      const extraKeys = {};\n      for (const key of refKeys) {\n        if (key !== '$ref' && !(key in cache.value)) {\n          extraKeys[key] = $ref[key];\n        }\n      }\n      return {\n        circular: cache.circular,\n        value: {\n          ...cache.value,\n          ...extraKeys\n        }\n      };\n    }\n    return cache;\n  }\n  const pointer = $refs._resolve($refPath, path, options);\n  if (pointer === null) {\n    return {\n      circular: false,\n      value: null\n    };\n  }\n\n  // Check for circular references\n  const directCircular = pointer.circular;\n  let circular = directCircular || parents.has(pointer.value);\n  // eslint-disable-next-line chai-friendly/no-unused-expressions\n  circular && foundCircularReference(path, $refs, options);\n\n  // Dereference the JSON reference\n  let dereferencedValue = $Ref.dereference($ref, pointer.value);\n\n  // Crawl the dereferenced value (unless it's circular)\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    const dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n    circular = dereferenced.circular;\n    dereferencedValue = dereferenced.value;\n  }\n  if (circular && !directCircular && options.dereference.circular === 'ignore') {\n    // The user has chosen to \"ignore\" circular references, so don't change the value\n    dereferencedValue = $ref;\n  }\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref = pathFromRoot;\n  }\n  const dereferencedObject = {\n    circular,\n    value: dereferencedValue\n  };\n\n  // only cache if no extra properties than $ref\n  if (Object.keys($ref).length === 1) {\n    dereferencedCache.set($refPath, dereferencedObject);\n  }\n  return dereferencedObject;\n}\n\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param {string} keyPath - The JSON Reference path of the circular reference\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference(keyPath, $refs, options) {\n  $refs.circular = true;\n  $refs.circularRefs.push(keyPath);\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n  return true;\n}","map":{"version":3,"names":["ono","require","Pointer","$Ref","url","module","exports","dereference","parser","options","dereferenced","crawl","schema","$refs","_root$Ref","path","Set","Map","circular","value","obj","pathFromRoot","parents","processedObjects","dereferencedCache","result","has","ArrayBuffer","isView","add","isAllowed$Ref","dereference$Ref","description","summary","key","Object","keys","keyPath","join","keyPathFromRoot","foundCircularReference","delete","$ref","$refPath","resolve","cache","get","refKeys","length","extraKeys","pointer","_resolve","directCircular","dereferencedValue","dereferencedObject","set","circularRefs","push","reference"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/dereference.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\nconst { ono } = require('@jsdevtools/ono');\n\nconst Pointer = require('./pointer');\nconst $Ref = require('./ref');\nconst url = require('./util/url');\n\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n */\nmodule.exports = function dereference(parser, options) {\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n  const dereferenced = crawl(\n    parser.schema,\n    parser.$refs._root$Ref.path,\n    '#',\n    new Set(),\n    new Set(),\n    new Map(),\n    parser.$refs,\n    options\n  );\n\n  parser.$refs.circular = dereferenced.circular;\n  parser.schema = dereferenced.value;\n};\n\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `obj` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been processed\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  let dereferenced;\n  const result = {\n    value: obj,\n    circular: false,\n  };\n\n  if (options.dereference.circular === 'ignore' || !processedObjects.has(obj)) {\n    if (obj && typeof obj === 'object' && !ArrayBuffer.isView(obj)) {\n      parents.add(obj);\n      processedObjects.add(obj);\n\n      if ($Ref.isAllowed$Ref(obj, options)) {\n        dereferenced = dereference$Ref(\n          obj,\n          path,\n          pathFromRoot,\n          parents,\n          processedObjects,\n          dereferencedCache,\n          $refs,\n          options\n        );\n\n        result.circular = dereferenced.circular;\n        result.value = dereferenced.value;\n\n        // OpenAPI 3.1 $ref overrides: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-19\n        if (obj.description) {\n          result.value.description = obj.description;\n        }\n\n        if (obj.summary) {\n          result.value.summary = obj.summary;\n        }\n      } else {\n        for (const key of Object.keys(obj)) {\n          const keyPath = Pointer.join(path, key);\n          const keyPathFromRoot = Pointer.join(pathFromRoot, key);\n          const value = obj[key];\n          let circular = false;\n\n          if ($Ref.isAllowed$Ref(value, options)) {\n            dereferenced = dereference$Ref(\n              value,\n              keyPath,\n              keyPathFromRoot,\n              parents,\n              processedObjects,\n              dereferencedCache,\n              $refs,\n              options\n            );\n\n            circular = dereferenced.circular;\n\n            // Avoid pointless mutations; breaks frozen objects to no profit\n            if (obj[key] !== dereferenced.value) {\n              obj[key] = dereferenced.value;\n\n              // OpenAPI 3.1 $ref overrides: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-19\n              if (value.description) {\n                obj[key].description = value.description;\n              }\n\n              if (value.summary) {\n                obj[key].summary = value.summary;\n              }\n            }\n          } else if (!parents.has(value)) {\n            dereferenced = crawl(\n              value,\n              keyPath,\n              keyPathFromRoot,\n              parents,\n              processedObjects,\n              dereferencedCache,\n              $refs,\n              options\n            );\n\n            circular = dereferenced.circular;\n\n            // Avoid pointless mutations; breaks frozen objects to no profit\n            if (obj[key] !== dereferenced.value) {\n              obj[key] = dereferenced.value;\n            }\n          } else {\n            circular = foundCircularReference(keyPath, $refs, options);\n          }\n\n          // Set the \"isCircular\" flag if this or any other property is circular\n          result.circular = result.circular || circular;\n        }\n      }\n\n      parents.delete(obj);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\n * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced\n * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced\n * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {{value: object, circular: boolean}}\n */\nfunction dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  const $refPath = url.resolve(path, $ref.$ref);\n\n  const cache = dereferencedCache.get($refPath);\n  if (cache) {\n    const refKeys = Object.keys($ref);\n    if (refKeys.length > 1) {\n      const extraKeys = {};\n      for (const key of refKeys) {\n        if (key !== '$ref' && !(key in cache.value)) {\n          extraKeys[key] = $ref[key];\n        }\n      }\n\n      return {\n        circular: cache.circular,\n        value: { ...cache.value, ...extraKeys },\n      };\n    }\n\n    return cache;\n  }\n\n  const pointer = $refs._resolve($refPath, path, options);\n\n  if (pointer === null) {\n    return {\n      circular: false,\n      value: null,\n    };\n  }\n\n  // Check for circular references\n  const directCircular = pointer.circular;\n  let circular = directCircular || parents.has(pointer.value);\n  // eslint-disable-next-line chai-friendly/no-unused-expressions\n  circular && foundCircularReference(path, $refs, options);\n\n  // Dereference the JSON reference\n  let dereferencedValue = $Ref.dereference($ref, pointer.value);\n\n  // Crawl the dereferenced value (unless it's circular)\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    const dereferenced = crawl(\n      dereferencedValue,\n      pointer.path,\n      pathFromRoot,\n      parents,\n      processedObjects,\n      dereferencedCache,\n      $refs,\n      options\n    );\n\n    circular = dereferenced.circular;\n    dereferencedValue = dereferenced.value;\n  }\n\n  if (circular && !directCircular && options.dereference.circular === 'ignore') {\n    // The user has chosen to \"ignore\" circular references, so don't change the value\n    dereferencedValue = $ref;\n  }\n\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref = pathFromRoot;\n  }\n\n  const dereferencedObject = {\n    circular,\n    value: dereferencedValue,\n  };\n\n  // only cache if no extra properties than $ref\n  if (Object.keys($ref).length === 1) {\n    dereferencedCache.set($refPath, dereferencedObject);\n  }\n\n  return dereferencedObject;\n}\n\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param {string} keyPath - The JSON Reference path of the circular reference\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference(keyPath, $refs, options) {\n  $refs.circular = true;\n  $refs.circularRefs.push(keyPath);\n\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}