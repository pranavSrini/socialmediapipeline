{"ast":null,"code":"'use strict';\n\n// MODULES //\nvar isArray = require('validate.io-array'),\n  isIntegerArray = require('validate.io-integer-array'),\n  isFunction = require('validate.io-function');\n\n// VARIABLES //\n\nvar MAXINT = Math.pow(2, 31) - 1;\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: gcd( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.\n*\n* @param {Number} a - integer\n* @param {Number} b - integer\n* @returns {Number} greatest common divisor\n*/\nfunction gcd(a, b) {\n  var k = 1,\n    t;\n  // Simple cases:\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  // Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n  while (a % 2 === 0 && b % 2 === 0) {\n    a = a / 2; // right shift\n    b = b / 2; // right shift\n    k = k * 2; // left shift\n  }\n  // Reduce `a` to an odd number...\n  while (a % 2 === 0) {\n    a = a / 2; // right shift\n  }\n  // Henceforth, `a` is always odd...\n  while (b) {\n    // Remove all factors of 2 in `b`, as they are not common...\n    while (b % 2 === 0) {\n      b = b / 2; // right shift\n    }\n    // `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n    if (a > b) {\n      t = b;\n      b = a;\n      a = t;\n    }\n    b = b - a; // b=0 iff b=a\n  }\n  // Restore common factors of 2...\n  return k * a;\n} // end FUNCTION gcd()\n\n/**\n* FUNCTION: bitwise( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.\n*\n* @param {Number} a - safe integer\n* @param {Number} b - safe integer\n* @returns {Number} greatest common divisor\n*/\nfunction bitwise(a, b) {\n  var k = 0,\n    t;\n  // Simple cases:\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  // Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n  while ((a & 1) === 0 && (b & 1) === 0) {\n    a >>>= 1; // right shift\n    b >>>= 1; // right shift\n    k++;\n  }\n  // Reduce `a` to an odd number...\n  while ((a & 1) === 0) {\n    a >>>= 1; // right shift\n  }\n  // Henceforth, `a` is always odd...\n  while (b) {\n    // Remove all factors of 2 in `b`, as they are not common...\n    while ((b & 1) === 0) {\n      b >>>= 1; // right shift\n    }\n    // `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n    if (a > b) {\n      t = b;\n      b = a;\n      a = t;\n    }\n    b = b - a; // b=0 iff b=a\n  }\n  // Restore common factors of 2...\n  return a << k;\n} // end FUNCTION bitwise()\n\n// GREATEST COMMON DIVISOR //\n\n/**\n* FUNCTION: compute( arr[, clbk] )\n*\tComputes the greatest common divisor.\n*\n* @param {Number[]|Number} arr - input array of integers\n* @param {Function|Number} [clbk] - accessor function for accessing array values\n* @returns {Number|Null} greatest common divisor or null\n*/\nfunction compute() {\n  var nargs = arguments.length,\n    args,\n    clbk,\n    arr,\n    len,\n    a,\n    b,\n    i;\n\n  // Copy the input arguments to an array...\n  args = new Array(nargs);\n  for (i = 0; i < nargs; i++) {\n    args[i] = arguments[i];\n  }\n  // Have we been provided with integer arguments?\n  if (isIntegerArray(args)) {\n    if (nargs === 2) {\n      a = args[0];\n      b = args[1];\n      if (a < 0) {\n        a = -a;\n      }\n      if (b < 0) {\n        b = -b;\n      }\n      if (a <= MAXINT && b <= MAXINT) {\n        return bitwise(a, b);\n      } else {\n        return gcd(a, b);\n      }\n    }\n    arr = args;\n  }\n  // If not integers, ensure the first argument is an array...\n  else if (!isArray(args[0])) {\n    throw new TypeError('gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[0] + '`.');\n  }\n  // Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...\n  else if (nargs > 1) {\n    arr = args[0];\n    clbk = args[1];\n    if (!isFunction(clbk)) {\n      throw new TypeError('gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.');\n    }\n  }\n  // We have been provided an array...\n  else {\n    arr = args[0];\n  }\n  len = arr.length;\n\n  // Check if a sufficient number of values have been provided...\n  if (len < 2) {\n    return null;\n  }\n  // If an accessor is provided, extract the array values...\n  if (clbk) {\n    a = new Array(len);\n    for (i = 0; i < len; i++) {\n      a[i] = clbk(arr[i], i);\n    }\n    arr = a;\n  }\n  // Given an input array, ensure all array values are integers...\n  if (nargs < 3) {\n    if (!isIntegerArray(arr)) {\n      throw new TypeError('gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.');\n    }\n  }\n  // Convert any negative integers to positive integers...\n  for (i = 0; i < len; i++) {\n    a = arr[i];\n    if (a < 0) {\n      arr[i] = -a;\n    }\n  }\n  // Exploit the fact that the gcd is an associative function...\n  a = arr[0];\n  for (i = 1; i < len; i++) {\n    b = arr[i];\n    if (b <= MAXINT && a <= MAXINT) {\n      a = bitwise(a, b);\n    } else {\n      a = gcd(a, b);\n    }\n  }\n  return a;\n} // end FUNCTION compute()\n\n// EXPORTS //\n\nmodule.exports = compute;","map":{"version":3,"names":["isArray","require","isIntegerArray","isFunction","MAXINT","Math","pow","gcd","a","b","k","t","bitwise","compute","nargs","arguments","length","args","clbk","arr","len","i","Array","TypeError","module","exports"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/compute-gcd/lib/index.js"],"sourcesContent":["'use strict';\n\n// MODULES //\n\nvar isArray = require( 'validate.io-array' ),\n\tisIntegerArray = require( 'validate.io-integer-array' ),\n\tisFunction = require( 'validate.io-function' );\n\n\n// VARIABLES //\n\nvar MAXINT = Math.pow( 2, 31 ) - 1;\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: gcd( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.\n*\n* @param {Number} a - integer\n* @param {Number} b - integer\n* @returns {Number} greatest common divisor\n*/\nfunction gcd( a, b ) {\n\tvar k = 1,\n\t\tt;\n\t// Simple cases:\n\tif ( a === 0 ) {\n\t\treturn b;\n\t}\n\tif ( b === 0 ) {\n\t\treturn a;\n\t}\n\t// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n\twhile ( a%2 === 0 && b%2 === 0 ) {\n\t\ta = a / 2; // right shift\n\t\tb = b / 2; // right shift\n\t\tk = k * 2; // left shift\n\t}\n\t// Reduce `a` to an odd number...\n\twhile ( a%2 === 0 ) {\n\t\ta = a / 2; // right shift\n\t}\n\t// Henceforth, `a` is always odd...\n\twhile ( b ) {\n\t\t// Remove all factors of 2 in `b`, as they are not common...\n\t\twhile ( b%2 === 0 ) {\n\t\t\tb = b / 2; // right shift\n\t\t}\n\t\t// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n\t\tif ( a > b ) {\n\t\t\tt = b;\n\t\t\tb = a;\n\t\t\ta = t;\n\t\t}\n\t\tb = b - a; // b=0 iff b=a\n\t}\n\t// Restore common factors of 2...\n\treturn k * a;\n} // end FUNCTION gcd()\n\n/**\n* FUNCTION: bitwise( a, b )\n*\tComputes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.\n*\n* @param {Number} a - safe integer\n* @param {Number} b - safe integer\n* @returns {Number} greatest common divisor\n*/\nfunction bitwise( a, b ) {\n\tvar k = 0,\n\t\tt;\n\t// Simple cases:\n\tif ( a === 0 ) {\n\t\treturn b;\n\t}\n\tif ( b === 0 ) {\n\t\treturn a;\n\t}\n\t// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...\n\twhile ( (a & 1) === 0 && (b & 1) === 0 ) {\n\t\ta >>>= 1; // right shift\n\t\tb >>>= 1; // right shift\n\t\tk++;\n\t}\n\t// Reduce `a` to an odd number...\n\twhile ( (a & 1) === 0 ) {\n\t\ta >>>= 1; // right shift\n\t}\n\t// Henceforth, `a` is always odd...\n\twhile ( b ) {\n\t\t// Remove all factors of 2 in `b`, as they are not common...\n\t\twhile ( (b & 1) === 0 ) {\n\t\t\tb >>>= 1; // right shift\n\t\t}\n\t\t// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...\n\t\tif ( a > b ) {\n\t\t\tt = b;\n\t\t\tb = a;\n\t\t\ta = t;\n\t\t}\n\t\tb = b - a; // b=0 iff b=a\n\t}\n\t// Restore common factors of 2...\n\treturn a << k;\n} // end FUNCTION bitwise()\n\n\n// GREATEST COMMON DIVISOR //\n\n/**\n* FUNCTION: compute( arr[, clbk] )\n*\tComputes the greatest common divisor.\n*\n* @param {Number[]|Number} arr - input array of integers\n* @param {Function|Number} [clbk] - accessor function for accessing array values\n* @returns {Number|Null} greatest common divisor or null\n*/\nfunction compute() {\n\tvar nargs = arguments.length,\n\t\targs,\n\t\tclbk,\n\t\tarr,\n\t\tlen,\n\t\ta, b,\n\t\ti;\n\n\t// Copy the input arguments to an array...\n\targs = new Array( nargs );\n\tfor ( i = 0; i < nargs; i++ ) {\n\t\targs[ i ] = arguments[ i ];\n\t}\n\t// Have we been provided with integer arguments?\n\tif ( isIntegerArray( args ) ) {\n\t\tif ( nargs === 2 ) {\n\t\t\ta = args[ 0 ];\n\t\t\tb = args[ 1 ];\n\t\t\tif ( a < 0 ) {\n\t\t\t\ta = -a;\n\t\t\t}\n\t\t\tif ( b < 0 ) {\n\t\t\t\tb = -b;\n\t\t\t}\n\t\t\tif ( a <= MAXINT && b <= MAXINT ) {\n\t\t\t\treturn bitwise( a, b );\n\t\t\t} else {\n\t\t\t\treturn gcd( a, b );\n\t\t\t}\n\t\t}\n\t\tarr = args;\n\t}\n\t// If not integers, ensure the first argument is an array...\n\telse if ( !isArray( args[ 0 ] ) ) {\n\t\tthrow new TypeError( 'gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );\n\t}\n\t// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...\n\telse if ( nargs > 1 ) {\n\t\tarr = args[ 0 ];\n\t\tclbk = args[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( 'gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n\t\t}\n\t}\n\t// We have been provided an array...\n\telse {\n\t\tarr = args[ 0 ];\n\t}\n\tlen = arr.length;\n\n\t// Check if a sufficient number of values have been provided...\n\tif ( len < 2 ) {\n\t\treturn null;\n\t}\n\t// If an accessor is provided, extract the array values...\n\tif ( clbk ) {\n\t\ta = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\ta[ i ] = clbk( arr[ i ], i );\n\t\t}\n\t\tarr = a;\n\t}\n\t// Given an input array, ensure all array values are integers...\n\tif ( nargs < 3 ) {\n\t\tif ( !isIntegerArray( arr ) ) {\n\t\t\tthrow new TypeError( 'gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );\n\t\t}\n\t}\n\t// Convert any negative integers to positive integers...\n\tfor ( i = 0; i < len; i++ ) {\n\t\ta = arr[ i ];\n\t\tif ( a < 0 ) {\n\t\t\tarr[ i ] = -a;\n\t\t}\n\t}\n\t// Exploit the fact that the gcd is an associative function...\n\ta = arr[ 0 ];\n\tfor ( i = 1; i < len; i++ ) {\n\t\tb = arr[ i ];\n\t\tif ( b <= MAXINT && a <= MAXINT ) {\n\t\t\ta = bitwise( a, b );\n\t\t} else {\n\t\t\ta = gcd( a, b );\n\t\t}\n\t}\n\treturn a;\n} // end FUNCTION compute()\n\n\n// EXPORTS //\n\nmodule.exports = compute;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}