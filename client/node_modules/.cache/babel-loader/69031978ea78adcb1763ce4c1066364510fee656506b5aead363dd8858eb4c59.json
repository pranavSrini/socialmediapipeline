{"ast":null,"code":"const {\n  ParserError\n} = require('../util/errors');\nconst TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: 'utf8',\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse(file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === 'string' || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {string}\n   */\n  parse(file) {\n    if (typeof file.data === 'string') {\n      return file.data;\n    } else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    }\n    throw new ParserError('data is not text', file.url);\n  }\n};","map":{"version":3,"names":["ParserError","require","TEXT_REGEXP","module","exports","order","allowEmpty","encoding","canParse","file","data","Buffer","isBuffer","test","url","parse","toString"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/parsers/text.js"],"sourcesContent":["const { ParserError } = require('../util/errors');\n\nconst TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: 'utf8',\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse(file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === 'string' || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {string}\n   */\n  parse(file) {\n    if (typeof file.data === 'string') {\n      return file.data;\n    } else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    }\n\n    throw new ParserError('data is not text', file.url);\n  },\n};\n"],"mappings":"AAAA,MAAM;EAAEA;AAAY,CAAC,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAEjD,MAAMC,WAAW,GAAG,wDAAwD;AAE5EC,MAAM,CAACC,OAAO,GAAG;EACf;AACF;AACA;AACA;AACA;EACEC,KAAK,EAAE,GAAG;EAEV;AACF;AACA;AACA;AACA;EACEC,UAAU,EAAE,IAAI;EAEhB;AACF;AACA;AACA;AACA;EACEC,QAAQ,EAAE,MAAM;EAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,QAAQA,CAACC,IAAI,EAAE;IACb;IACA,OAAO,CAAC,OAAOA,IAAI,CAACC,IAAI,KAAK,QAAQ,IAAIC,MAAM,CAACC,QAAQ,CAACH,IAAI,CAACC,IAAI,CAAC,KAAKR,WAAW,CAACW,IAAI,CAACJ,IAAI,CAACK,GAAG,CAAC;EACpG,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAKA,CAACN,IAAI,EAAE;IACV,IAAI,OAAOA,IAAI,CAACC,IAAI,KAAK,QAAQ,EAAE;MACjC,OAAOD,IAAI,CAACC,IAAI;IAClB,CAAC,MAAM,IAAIC,MAAM,CAACC,QAAQ,CAACH,IAAI,CAACC,IAAI,CAAC,EAAE;MACrC,OAAOD,IAAI,CAACC,IAAI,CAACM,QAAQ,CAAC,IAAI,CAACT,QAAQ,CAAC;IAC1C;IAEA,MAAM,IAAIP,WAAW,CAAC,kBAAkB,EAAES,IAAI,CAACK,GAAG,CAAC;EACrD;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}