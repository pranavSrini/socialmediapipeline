{"ast":null,"code":"import { prettyByte } from \"./utils/prettyByte.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.mjs\";\nimport { utf8Decode } from \"./utils/utf8.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.mjs\";\nimport { DecodeError } from \"./DecodeError.mjs\";\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\nconst mapKeyConverter = key => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\nclass StackPool {\n  constructor() {\n    this.stack = [];\n    this.stackHeadPosition = -1;\n  }\n  get length() {\n    return this.stackHeadPosition + 1;\n  }\n  top() {\n    return this.stack[this.stackHeadPosition];\n  }\n  pushArrayState(size) {\n    const state = this.getUninitializedStateFromPool();\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n  pushMapState(size) {\n    const state = this.getUninitializedStateFromPool();\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n  getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null\n      };\n      this.stack.push(partialState);\n    }\n    return this.stack[this.stackHeadPosition];\n  }\n  release(state) {\n    const topStackState = this.stack[this.stackHeadPosition];\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n    if (state.type === STATE_ARRAY) {\n      const partialState = state;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n    this.stackHeadPosition--;\n  }\n  reset() {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n  }\n}\nconst MORE_DATA = new RangeError(\"Insufficient data\");\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\nexport class Decoder {\n  constructor(options) {\n    this.totalPos = 0;\n    this.pos = 0;\n    this.view = EMPTY_VIEW;\n    this.bytes = EMPTY_BYTES;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack = new StackPool();\n    this.entered = false;\n    this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;\n    this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.rawStrings = options?.rawStrings ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n  }\n  clone() {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder\n    });\n  }\n  reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n  setBuffer(buffer) {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n  appendBuffer(buffer) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n  hasRemaining(size) {\n    return this.view.byteLength - this.pos >= size;\n  }\n  createExtraByteError(posToShow) {\n    const {\n      view,\n      pos\n    } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  decode(buffer) {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n    try {\n      this.entered = true;\n      this.reinitializeState();\n      this.setBuffer(buffer);\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n  *decodeMulti(buffer) {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n    try {\n      this.entered = true;\n      this.reinitializeState();\n      this.setBuffer(buffer);\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n  async decodeAsync(stream) {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n    try {\n      this.entered = true;\n      let decoded = false;\n      let object;\n      for await (const buffer of stream) {\n        if (decoded) {\n          this.entered = false;\n          throw this.createExtraByteError(this.totalPos);\n        }\n        this.appendBuffer(buffer);\n        try {\n          object = this.doDecodeSync();\n          decoded = true;\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n      const {\n        headByte,\n        pos,\n        totalPos\n      } = this;\n      throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);\n    } finally {\n      this.entered = false;\n    }\n  }\n  decodeArrayStream(stream) {\n    return this.decodeMultiAsync(stream, true);\n  }\n  decodeStream(stream) {\n    return this.decodeMultiAsync(stream, false);\n  }\n  async *decodeMultiAsync(stream, isArray) {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMultiAsync(stream, isArray);\n      return;\n    }\n    try {\n      this.entered = true;\n      let isArrayHeaderRequired = isArray;\n      let arrayItemsLeft = -1;\n      for await (const buffer of stream) {\n        if (isArray && arrayItemsLeft === 0) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        this.appendBuffer(buffer);\n        if (isArrayHeaderRequired) {\n          arrayItemsLeft = this.readArraySize();\n          isArrayHeaderRequired = false;\n          this.complete();\n        }\n        try {\n          while (true) {\n            yield this.doDecodeSync();\n            if (--arrayItemsLeft === 0) {\n              break;\n            }\n          }\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n  doDecodeSync() {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object;\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n      this.complete();\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top();\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n          state.map[state.key] = object;\n          state.readCount++;\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n      return object;\n    }\n  }\n  readHeadByte() {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n    return this.headByte;\n  }\n  complete() {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n  readArraySize() {\n    const headByte = this.readHeadByte();\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default:\n        {\n          if (headByte < 0xa0) {\n            return headByte - 0x90;\n          } else {\n            throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n          }\n        }\n    }\n  }\n  pushMapState(size) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n    this.stack.pushMapState(size);\n  }\n  pushArrayState(size) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n    this.stack.pushArrayState(size);\n  }\n  decodeString(byteLength, headerOffset) {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n  /**\n   * @throws {@link RangeError}\n   */\n  decodeUtf8String(byteLength, headerOffset) {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n    }\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n    const offset = this.pos + headerOffset;\n    let object;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n  stateIsMapKey() {\n    if (this.stack.length > 0) {\n      const state = this.stack.top();\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n  /**\n   * @throws {@link RangeError}\n   */\n  decodeBinary(byteLength, headOffset) {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n  decodeExtension(size, headOffset) {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n  lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n  lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n  lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n  readU8() {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n  readI8() {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n  readU16() {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n  readI16() {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n  readU32() {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n  readI32() {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n  readU64() {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readI64() {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readU64AsBigInt() {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readI64AsBigInt() {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n  readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}","map":{"version":3,"names":["prettyByte","ExtensionCodec","getInt64","getUint64","UINT32_MAX","utf8Decode","ensureUint8Array","CachedKeyDecoder","DecodeError","STATE_ARRAY","STATE_MAP_KEY","STATE_MAP_VALUE","mapKeyConverter","key","StackPool","constructor","stack","stackHeadPosition","length","top","pushArrayState","size","state","getUninitializedStateFromPool","type","position","array","Array","pushMapState","readCount","map","partialState","undefined","push","release","topStackState","Error","reset","HEAD_BYTE_REQUIRED","EMPTY_VIEW","DataView","ArrayBuffer","EMPTY_BYTES","Uint8Array","buffer","getInt8","e","RangeError","MORE_DATA","sharedCachedKeyDecoder","Decoder","options","totalPos","pos","view","bytes","headByte","entered","extensionCodec","defaultCodec","context","useBigInt64","rawStrings","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","clone","reinitializeState","setBuffer","byteOffset","byteLength","appendBuffer","hasRemaining","remainingData","subarray","newData","newBuffer","set","createExtraByteError","posToShow","decode","instance","object","doDecodeSync","decodeMulti","decodeAsync","stream","decoded","decodeArrayStream","decodeMultiAsync","decodeStream","isArray","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","DECODE","readHeadByte","decodeString","readF32","readF64","readU8","readU16","readU32","readU64AsBigInt","readU64","readI8","readI16","readI32","readI64AsBigInt","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","headerOffset","stateIsMapKey","decodeUtf8String","offset","canBeCached","headOffset","extType","data","getUint8","getUint16","getUint32","value","getInt16","getInt32","getBigUint64","getBigInt64","getFloat32","getFloat64"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/node_modules/@msgpack/msgpack/src/Decoder.ts"],"sourcesContent":["import { prettyByte } from \"./utils/prettyByte.ts\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec.ts\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.ts\";\nimport { utf8Decode } from \"./utils/utf8.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder.ts\";\nimport { DecodeError } from \"./DecodeError.ts\";\nimport type { ContextOf } from \"./context.ts\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * By default, string values will be decoded as UTF-8 strings. However, if this option is true,\n     * string values will be returned as Uint8Arrays without additional decoding.\n     *\n     * This is useful if the strings may contain invalid UTF-8 sequences.\n     *\n     * Note that this option only applies to string values, not map keys. Additionally, when\n     * enabled, raw string length is limited by the maxBinLength option.\n     */\n    rawStrings: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n\n    /**\n     * A function to convert decoded map key to a valid JS key type.\n     * \n     * Defaults to a function that throws an error if the key is not a string or a number.\n     */\n    mapKeyConverter: (key: unknown) => MapKeyType;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst mapKeyConverter = (key: unknown): MapKeyType => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\nclass StackPool {\n  private readonly stack: Array<StackState> = [];\n  private stackHeadPosition = -1;\n\n  public get length(): number {\n    return this.stackHeadPosition + 1;\n  }\n\n  public top(): StackState | undefined {\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public pushArrayState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\n\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n\n  public pushMapState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackMapState;\n\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n\n  private getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState: Partial<StackState> = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null,\n      };\n\n      this.stack.push(partialState as StackState);\n    }\n\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public release(state: StackState): void {\n    const topStackState = this.stack[this.stackHeadPosition];\n\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n\n    if (state.type === STATE_ARRAY) {\n      const partialState = state as Partial<StackArrayState>;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state as Partial<StackMapState>;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n\n    this.stackHeadPosition--;\n  }\n\n  public reset(): void {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView<ArrayBufferLike>(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array<ArrayBufferLike>(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\n    );\n  }\n}\n\nconst MORE_DATA = new RangeError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly rawStrings: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n  private readonly mapKeyConverter: (key: unknown) => MapKeyType;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack = new StackPool();\n\n  private entered = false;\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.rawStrings = options?.rawStrings ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n  }\n\n  private clone(): Decoder<ContextType> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): unknown {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): Generator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): Promise<unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n\n    try {\n      this.entered = true;\n\n      let decoded = false;\n      let object: unknown;\n      for await (const buffer of stream) {\n        if (decoded) {\n          this.entered = false;\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        try {\n          object = this.doDecodeSync();\n          decoded = true;\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n\n      const { headByte, pos, totalPos } = this;\n      throw new RangeError(\n        `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n      );\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>, isArray: boolean): AsyncGenerator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMultiAsync(stream, isArray);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      let isArrayHeaderRequired = isArray;\n      let arrayItemsLeft = -1;\n\n      for await (const buffer of stream) {\n        if (isArray && arrayItemsLeft === 0) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        if (isArrayHeaderRequired) {\n          arrayItemsLeft = this.readArraySize();\n          isArrayHeaderRequired = false;\n          this.complete();\n        }\n\n        try {\n          while (true) {\n            yield this.doDecodeSync();\n            if (--arrayItemsLeft === 0) {\n              break;\n            }\n          }\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top()!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.pushMapState(size);\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.pushArrayState(size);\n  }\n\n  private decodeString(byteLength: number, headerOffset: number): string | Uint8Array {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack.top()!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readU64AsBigInt(): bigint {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64AsBigInt(): bigint {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}