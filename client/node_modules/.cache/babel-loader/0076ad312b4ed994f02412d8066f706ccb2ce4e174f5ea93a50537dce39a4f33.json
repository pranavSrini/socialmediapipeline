{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createStorageClient = createStorageClient;\nconst config_1 = require(\"./config\");\nconst request_1 = require(\"./request\");\nconst utils_1 = require(\"./utils\");\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType) {\n  var _a;\n  const [_, fileType] = contentType.split(\"/\");\n  return (_a = fileType.split(/[-;]/)[0]) !== null && _a !== void 0 ? _a : \"bin\";\n}\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateUpload(file, config, contentType) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n    return yield (0, request_1.dispatchRequest)({\n      method: \"POST\",\n      // NOTE: We want to test V3 without making it the default at the API level\n      targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate?storage_type=fal-cdn-v3`,\n      input: {\n        content_type: contentType,\n        file_name: filename\n      },\n      config\n    });\n  });\n}\n/**\n * Initiate the multipart upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateMultipartUpload(file, config, contentType) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n    return yield (0, request_1.dispatchRequest)({\n      method: \"POST\",\n      targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,\n      input: {\n        content_type: contentType,\n        file_name: filename\n      },\n      config\n    });\n  });\n}\nfunction partUploadRetries(uploadUrl_1, chunk_1, config_2) {\n  return __awaiter(this, arguments, void 0, function* (uploadUrl, chunk, config, tries = 3) {\n    if (tries === 0) {\n      throw new Error(\"Part upload failed, retries exhausted\");\n    }\n    const {\n      fetch,\n      responseHandler\n    } = config;\n    try {\n      const response = yield fetch(uploadUrl, {\n        method: \"PUT\",\n        body: chunk\n      });\n      return yield responseHandler(response);\n    } catch (error) {\n      return yield partUploadRetries(uploadUrl, chunk, config, tries - 1);\n    }\n  });\n}\nfunction multipartUpload(file, config) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      fetch,\n      responseHandler\n    } = config;\n    const contentType = file.type || \"application/octet-stream\";\n    const {\n      upload_url: uploadUrl,\n      file_url: url\n    } = yield initiateMultipartUpload(file, config, contentType);\n    // Break the file into 10MB chunks\n    const chunkSize = 10 * 1024 * 1024;\n    const chunks = Math.ceil(file.size / chunkSize);\n    const parsedUrl = new URL(uploadUrl);\n    const responses = [];\n    for (let i = 0; i < chunks; i++) {\n      const start = i * chunkSize;\n      const end = Math.min(start + chunkSize, file.size);\n      const chunk = file.slice(start, end);\n      const partNumber = i + 1;\n      // {uploadUrl}/{part_number}?uploadUrlParams=...\n      const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;\n      responses.push(yield partUploadRetries(partUploadUrl, chunk, config));\n    }\n    // Complete the upload\n    const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;\n    const response = yield fetch(completeUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        parts: responses.map(mpart => ({\n          partNumber: mpart.partNumber,\n          etag: mpart.etag\n        }))\n      })\n    });\n    yield responseHandler(response);\n    return url;\n  });\n}\nfunction createStorageClient({\n  config\n}) {\n  const ref = {\n    upload: file => __awaiter(this, void 0, void 0, function* () {\n      // Check for 90+ MB file size to do multipart upload\n      if (file.size > 90 * 1024 * 1024) {\n        return yield multipartUpload(file, config);\n      }\n      const contentType = file.type || \"application/octet-stream\";\n      const {\n        fetch,\n        responseHandler\n      } = config;\n      const {\n        upload_url: uploadUrl,\n        file_url: url\n      } = yield initiateUpload(file, config, contentType);\n      const response = yield fetch(uploadUrl, {\n        method: \"PUT\",\n        body: file,\n        headers: {\n          \"Content-Type\": file.type || \"application/octet-stream\"\n        }\n      });\n      yield responseHandler(response);\n      return url;\n    }),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    transformInput: input => __awaiter(this, void 0, void 0, function* () {\n      if (Array.isArray(input)) {\n        return Promise.all(input.map(item => ref.transformInput(item)));\n      } else if (input instanceof Blob) {\n        return yield ref.upload(input);\n      } else if ((0, utils_1.isPlainObject)(input)) {\n        const inputObject = input;\n        const promises = Object.entries(inputObject).map(_a => __awaiter(this, [_a], void 0, function* ([key, value]) {\n          return [key, yield ref.transformInput(value)];\n        }));\n        const results = yield Promise.all(promises);\n        return Object.fromEntries(results);\n      }\n      // Return the input as is if it's neither an object nor a file/blob/data URI\n      return input;\n    })\n  };\n  return ref;\n}","map":{"version":3,"names":["exports","createStorageClient","config_1","require","request_1","utils_1","getExtensionFromContentType","contentType","_","fileType","split","_a","initiateUpload","file","config","filename","name","Date","now","dispatchRequest","method","targetUrl","getRestApiUrl","input","content_type","file_name","initiateMultipartUpload","partUploadRetries","uploadUrl_1","chunk_1","config_2","uploadUrl","chunk","tries","Error","fetch","responseHandler","response","body","error","multipartUpload","type","upload_url","file_url","url","chunkSize","chunks","Math","ceil","size","parsedUrl","URL","responses","i","start","end","min","slice","partNumber","partUploadUrl","origin","pathname","search","push","completeUrl","headers","JSON","stringify","parts","map","mpart","etag","ref","upload","__awaiter","transformInput","Array","isArray","Promise","all","item","Blob","isPlainObject","inputObject","promises","Object","entries","key","value","results","fromEntries"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/libs/client/src/storage.ts"],"sourcesContent":["import { getRestApiUrl, RequiredConfig } from \"./config\";\nimport { dispatchRequest } from \"./request\";\nimport { isPlainObject } from \"./utils\";\n/**\n * File support for the client. This interface establishes the contract for\n * uploading files to the server and transforming the input to replace file\n * objects with URLs.\n */\nexport interface StorageClient {\n  /**\n   * Upload a file to the server. Returns the URL of the uploaded file.\n   * @param file the file to upload\n   * @param options optional parameters, such as custom file name\n   * @returns the URL of the uploaded file\n   */\n  upload: (file: Blob) => Promise<string>;\n\n  /**\n   * Transform the input to replace file objects with URLs. This is used\n   * to transform the input before sending it to the server and ensures\n   * that the server receives URLs instead of file objects.\n   *\n   * @param input the input to transform.\n   * @returns the transformed input.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  transformInput: (input: Record<string, any>) => Promise<Record<string, any>>;\n}\n\ntype InitiateUploadResult = {\n  file_url: string;\n  upload_url: string;\n};\n\ntype InitiateUploadData = {\n  file_name: string;\n  content_type: string | null;\n};\n\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType: string): string {\n  const [_, fileType] = contentType.split(\"/\");\n  return fileType.split(/[-;]/)[0] ?? \"bin\";\n}\n\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nasync function initiateUpload(\n  file: Blob,\n  config: RequiredConfig,\n  contentType: string,\n): Promise<InitiateUploadResult> {\n  const filename =\n    file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n\n  return await dispatchRequest<InitiateUploadData, InitiateUploadResult>({\n    method: \"POST\",\n    // NOTE: We want to test V3 without making it the default at the API level\n    targetUrl: `${getRestApiUrl()}/storage/upload/initiate?storage_type=fal-cdn-v3`,\n    input: {\n      content_type: contentType,\n      file_name: filename,\n    },\n    config,\n  });\n}\n\n/**\n * Initiate the multipart upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nasync function initiateMultipartUpload(\n  file: Blob,\n  config: RequiredConfig,\n  contentType: string,\n): Promise<InitiateUploadResult> {\n  const filename =\n    file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n\n  return await dispatchRequest<InitiateUploadData, InitiateUploadResult>({\n    method: \"POST\",\n    targetUrl: `${getRestApiUrl()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,\n    input: {\n      content_type: contentType,\n      file_name: filename,\n    },\n    config,\n  });\n}\n\ntype MultipartObject = {\n  partNumber: number;\n  etag: string;\n};\n\nasync function partUploadRetries(\n  uploadUrl: string,\n  chunk: Blob,\n  config: RequiredConfig,\n  tries = 3,\n): Promise<MultipartObject> {\n  if (tries === 0) {\n    throw new Error(\"Part upload failed, retries exhausted\");\n  }\n\n  const { fetch, responseHandler } = config;\n\n  try {\n    const response = await fetch(uploadUrl, {\n      method: \"PUT\",\n      body: chunk,\n    });\n\n    return (await responseHandler(response)) as MultipartObject;\n  } catch (error) {\n    return await partUploadRetries(uploadUrl, chunk, config, tries - 1);\n  }\n}\n\nasync function multipartUpload(\n  file: Blob,\n  config: RequiredConfig,\n): Promise<string> {\n  const { fetch, responseHandler } = config;\n  const contentType = file.type || \"application/octet-stream\";\n  const { upload_url: uploadUrl, file_url: url } =\n    await initiateMultipartUpload(file, config, contentType);\n\n  // Break the file into 10MB chunks\n  const chunkSize = 10 * 1024 * 1024;\n  const chunks = Math.ceil(file.size / chunkSize);\n\n  const parsedUrl = new URL(uploadUrl);\n\n  const responses: MultipartObject[] = [];\n\n  for (let i = 0; i < chunks; i++) {\n    const start = i * chunkSize;\n    const end = Math.min(start + chunkSize, file.size);\n\n    const chunk = file.slice(start, end);\n\n    const partNumber = i + 1;\n    // {uploadUrl}/{part_number}?uploadUrlParams=...\n    const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;\n\n    responses.push(await partUploadRetries(partUploadUrl, chunk, config));\n  }\n\n  // Complete the upload\n  const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;\n  const response = await fetch(completeUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      parts: responses.map((mpart) => ({\n        partNumber: mpart.partNumber,\n        etag: mpart.etag,\n      })),\n    }),\n  });\n  await responseHandler(response);\n\n  return url;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype KeyValuePair = [string, any];\n\ntype StorageClientDependencies = {\n  config: RequiredConfig;\n};\n\nexport function createStorageClient({\n  config,\n}: StorageClientDependencies): StorageClient {\n  const ref: StorageClient = {\n    upload: async (file: Blob) => {\n      // Check for 90+ MB file size to do multipart upload\n      if (file.size > 90 * 1024 * 1024) {\n        return await multipartUpload(file, config);\n      }\n\n      const contentType = file.type || \"application/octet-stream\";\n\n      const { fetch, responseHandler } = config;\n      const { upload_url: uploadUrl, file_url: url } = await initiateUpload(\n        file,\n        config,\n        contentType,\n      );\n      const response = await fetch(uploadUrl, {\n        method: \"PUT\",\n        body: file,\n        headers: {\n          \"Content-Type\": file.type || \"application/octet-stream\",\n        },\n      });\n      await responseHandler(response);\n      return url;\n    },\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    transformInput: async (input: any): Promise<any> => {\n      if (Array.isArray(input)) {\n        return Promise.all(input.map((item) => ref.transformInput(item)));\n      } else if (input instanceof Blob) {\n        return await ref.upload(input);\n      } else if (isPlainObject(input)) {\n        const inputObject = input as Record<string, any>;\n        const promises = Object.entries(inputObject).map(\n          async ([key, value]): Promise<KeyValuePair> => {\n            return [key, await ref.transformInput(value)];\n          },\n        );\n        const results = await Promise.all(promises);\n        return Object.fromEntries(results);\n      }\n      // Return the input as is if it's neither an object nor a file/blob/data URI\n      return input;\n    },\n  };\n  return ref;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}