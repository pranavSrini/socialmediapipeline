{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TOKEN_EXPIRATION_SECONDS = void 0;\nexports.getTemporaryAuthToken = getTemporaryAuthToken;\nconst config_1 = require(\"./config\");\nconst request_1 = require(\"./request\");\nconst utils_1 = require(\"./utils\");\nexports.TOKEN_EXPIRATION_SECONDS = 120;\n/**\n * Get a token to connect to the realtime endpoint.\n */\nfunction getTemporaryAuthToken(app, config) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const appId = (0, utils_1.parseEndpointId)(app);\n    const token = yield (0, request_1.dispatchRequest)({\n      method: \"POST\",\n      targetUrl: `${(0, config_1.getRestApiUrl)()}/tokens/`,\n      config,\n      input: {\n        allowed_apps: [appId.alias],\n        token_expiration: exports.TOKEN_EXPIRATION_SECONDS\n      }\n    });\n    // keep this in case the response was wrapped (old versions of the proxy do that)\n    // should be safe to remove in the future\n    if (typeof token !== \"string\" && token[\"detail\"]) {\n      return token[\"detail\"];\n    }\n    return token;\n  });\n}","map":{"version":3,"names":["exports","getTemporaryAuthToken","config_1","require","request_1","utils_1","TOKEN_EXPIRATION_SECONDS","app","config","appId","parseEndpointId","token","dispatchRequest","method","targetUrl","getRestApiUrl","input","allowed_apps","alias","token_expiration"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/libs/client/src/auth.ts"],"sourcesContent":["import { getRestApiUrl, RequiredConfig } from \"./config\";\nimport { dispatchRequest } from \"./request\";\nimport { parseEndpointId } from \"./utils\";\n\nexport const TOKEN_EXPIRATION_SECONDS = 120;\n\n/**\n * Get a token to connect to the realtime endpoint.\n */\nexport async function getTemporaryAuthToken(\n  app: string,\n  config: RequiredConfig,\n): Promise<string> {\n  const appId = parseEndpointId(app);\n  const token: string | object = await dispatchRequest<any, string>({\n    method: \"POST\",\n    targetUrl: `${getRestApiUrl()}/tokens/`,\n    config,\n    input: {\n      allowed_apps: [appId.alias],\n      token_expiration: TOKEN_EXPIRATION_SECONDS,\n    },\n  });\n  // keep this in case the response was wrapped (old versions of the proxy do that)\n  // should be safe to remove in the future\n  if (typeof token !== \"string\" && token[\"detail\"]) {\n    return token[\"detail\"];\n  }\n  return token;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASAA,OAAA,CAAAC,qBAAA,GAAAA,qBAAA;AATA,MAAAC,QAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAEaH,OAAA,CAAAM,wBAAwB,GAAG,GAAG;AAE3C;;;AAGA,SAAsBL,qBAAqBA,CACzCM,GAAW,EACXC,MAAsB;;IAEtB,MAAMC,KAAK,GAAG,IAAAJ,OAAA,CAAAK,eAAe,EAACH,GAAG,CAAC;IAClC,MAAMI,KAAK,GAAoB,MAAM,IAAAP,SAAA,CAAAQ,eAAe,EAAc;MAChEC,MAAM,EAAE,MAAM;MACdC,SAAS,EAAE,GAAG,IAAAZ,QAAA,CAAAa,aAAa,GAAE,UAAU;MACvCP,MAAM;MACNQ,KAAK,EAAE;QACLC,YAAY,EAAE,CAACR,KAAK,CAACS,KAAK,CAAC;QAC3BC,gBAAgB,EAAEnB,OAAA,CAAAM;;KAErB,CAAC;IACF;IACA;IACA,IAAI,OAAOK,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAAC,QAAQ,CAAC,EAAE;MAChD,OAAOA,KAAK,CAAC,QAAQ,CAAC;IACxB;IACA,OAAOA,KAAK;EACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}