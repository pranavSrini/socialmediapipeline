{"ast":null,"code":"import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\nexport class CachedKeyDecoder {\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.hit = 0;\n    this.miss = 0;\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n  canBeCached(byteLength) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n  find(bytes, inputOffset, byteLength) {\n    const records = this.caches[byteLength - 1];\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n  store(bytes, value) {\n    const records = this.caches[bytes.length - 1];\n    const record = {\n      bytes,\n      str: value\n    };\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[Math.random() * records.length | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n  decode(bytes, inputOffset, byteLength) {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}","map":{"version":3,"names":["utf8DecodeJs","DEFAULT_MAX_KEY_LENGTH","DEFAULT_MAX_LENGTH_PER_KEY","CachedKeyDecoder","constructor","maxKeyLength","maxLengthPerKey","hit","miss","caches","i","push","canBeCached","byteLength","find","bytes","inputOffset","records","FIND_CHUNK","record","recordBytes","j","str","store","value","length","Math","random","decode","cachedValue","slicedCopyOfBytes","Uint8Array","prototype","slice","call"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/node_modules/@msgpack/msgpack/src/CachedKeyDecoder.ts"],"sourcesContent":["import { utf8DecodeJs } from \"./utils/utf8.ts\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n  private readonly maxKeyLength: number;\n  private readonly maxLengthPerKey: number;\n\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,kBAAkB;AAE/C,MAAMC,sBAAsB,GAAG,EAAE;AACjC,MAAMC,0BAA0B,GAAG,EAAE;AAWrC,OAAM,MAAOC,gBAAgB;EAO3BC,YAAYC,YAAY,GAAGJ,sBAAsB,EAAEK,eAAe,GAAGJ,0BAA0B;IAN/F,KAAAK,GAAG,GAAG,CAAC;IACP,KAAAC,IAAI,GAAG,CAAC;IAMN,IAAI,CAACH,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,eAAe,GAAGA,eAAe;IAEtC;IACA;IACA,IAAI,CAACG,MAAM,GAAG,EAAE;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACL,YAAY,EAAEK,CAAC,EAAE,EAAE;MAC1C,IAAI,CAACD,MAAM,CAACE,IAAI,CAAC,EAAE,CAAC;IACtB;EACF;EAEOC,WAAWA,CAACC,UAAkB;IACnC,OAAOA,UAAU,GAAG,CAAC,IAAIA,UAAU,IAAI,IAAI,CAACR,YAAY;EAC1D;EAEQS,IAAIA,CAACC,KAAiB,EAAEC,WAAmB,EAAEH,UAAkB;IACrE,MAAMI,OAAO,GAAG,IAAI,CAACR,MAAM,CAACI,UAAU,GAAG,CAAC,CAAE;IAE5CK,UAAU,EAAE,KAAK,MAAMC,MAAM,IAAIF,OAAO,EAAE;MACxC,MAAMG,WAAW,GAAGD,MAAM,CAACJ,KAAK;MAEhC,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,UAAU,EAAEQ,CAAC,EAAE,EAAE;QACnC,IAAID,WAAW,CAACC,CAAC,CAAC,KAAKN,KAAK,CAACC,WAAW,GAAGK,CAAC,CAAC,EAAE;UAC7C,SAASH,UAAU;QACrB;MACF;MACA,OAAOC,MAAM,CAACG,GAAG;IACnB;IACA,OAAO,IAAI;EACb;EAEQC,KAAKA,CAACR,KAAiB,EAAES,KAAa;IAC5C,MAAMP,OAAO,GAAG,IAAI,CAACR,MAAM,CAACM,KAAK,CAACU,MAAM,GAAG,CAAC,CAAE;IAC9C,MAAMN,MAAM,GAAmB;MAAEJ,KAAK;MAAEO,GAAG,EAAEE;IAAK,CAAE;IAEpD,IAAIP,OAAO,CAACQ,MAAM,IAAI,IAAI,CAACnB,eAAe,EAAE;MAC1C;MACA;MACAW,OAAO,CAAES,IAAI,CAACC,MAAM,EAAE,GAAGV,OAAO,CAACQ,MAAM,GAAI,CAAC,CAAC,GAAGN,MAAM;IACxD,CAAC,MAAM;MACLF,OAAO,CAACN,IAAI,CAACQ,MAAM,CAAC;IACtB;EACF;EAEOS,MAAMA,CAACb,KAAiB,EAAEC,WAAmB,EAAEH,UAAkB;IACtE,MAAMgB,WAAW,GAAG,IAAI,CAACf,IAAI,CAACC,KAAK,EAAEC,WAAW,EAAEH,UAAU,CAAC;IAC7D,IAAIgB,WAAW,IAAI,IAAI,EAAE;MACvB,IAAI,CAACtB,GAAG,EAAE;MACV,OAAOsB,WAAW;IACpB;IACA,IAAI,CAACrB,IAAI,EAAE;IAEX,MAAMc,GAAG,GAAGtB,YAAY,CAACe,KAAK,EAAEC,WAAW,EAAEH,UAAU,CAAC;IACxD;IACA,MAAMiB,iBAAiB,GAAGC,UAAU,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACnB,KAAK,EAAEC,WAAW,EAAEA,WAAW,GAAGH,UAAU,CAAC;IACvG,IAAI,CAACU,KAAK,CAACO,iBAAiB,EAAER,GAAG,CAAC;IAClC,OAAOA,GAAG;EACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}