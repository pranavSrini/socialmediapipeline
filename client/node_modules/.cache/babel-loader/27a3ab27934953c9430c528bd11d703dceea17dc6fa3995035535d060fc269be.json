{"ast":null,"code":"const newline = /\\r?\\n/;\nconst onoCall = /\\bono[ @]/;\n/**\n * Is the property lazily computed?\n */\nexport function isLazyStack(stackProp) {\n  return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === \"function\");\n}\n/**\n * Is the stack property writable?\n */\nexport function isWritableStack(stackProp) {\n  return Boolean(\n  // If there is no stack property, then it's writable, since assigning it will create it\n  !stackProp || stackProp.writable || typeof stackProp.set === \"function\");\n}\n/**\n * Appends the original `Error.stack` property to the new Error's stack.\n */\nexport function joinStacks(newError, originalError) {\n  let newStack = popStack(newError.stack);\n  let originalStack = originalError ? originalError.stack : undefined;\n  if (newStack && originalStack) {\n    return newStack + \"\\n\\n\" + originalStack;\n  } else {\n    return newStack || originalStack;\n  }\n}\n/**\n * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.\n */\nexport function lazyJoinStacks(lazyStack, newError, originalError) {\n  if (originalError) {\n    Object.defineProperty(newError, \"stack\", {\n      get: () => {\n        let newStack = lazyStack.get.apply(newError);\n        return joinStacks({\n          stack: newStack\n        }, originalError);\n      },\n      enumerable: false,\n      configurable: true\n    });\n  } else {\n    lazyPopStack(newError, lazyStack);\n  }\n}\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n */\nfunction popStack(stack) {\n  if (stack) {\n    let lines = stack.split(newline);\n    // Find the Ono call(s) in the stack, and remove them\n    let onoStart;\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      if (onoCall.test(line)) {\n        if (onoStart === undefined) {\n          // We found the first Ono call in the stack trace.\n          // There may be other subsequent Ono calls as well.\n          onoStart = i;\n        }\n      } else if (onoStart !== undefined) {\n        // We found the first non-Ono call after one or more Ono calls.\n        // So remove the Ono call lines from the stack trace\n        lines.splice(onoStart, i - onoStart);\n        break;\n      }\n    }\n    if (lines.length > 0) {\n      return lines.join(\"\\n\");\n    }\n  }\n  // If we get here, then the stack doesn't contain a call to `ono`.\n  // This may be due to minification or some optimization of the JS engine.\n  // So just return the stack as-is.\n  return stack;\n}\n/**\n * Calls `popStack` lazily, when the `Error.stack` property is accessed.\n */\nfunction lazyPopStack(error, lazyStack) {\n  Object.defineProperty(error, \"stack\", {\n    get: () => popStack(lazyStack.get.apply(error)),\n    enumerable: false,\n    configurable: true\n  });\n}","map":{"version":3,"names":["newline","onoCall","isLazyStack","stackProp","Boolean","configurable","get","isWritableStack","writable","set","joinStacks","newError","originalError","newStack","popStack","stack","originalStack","undefined","lazyJoinStacks","lazyStack","Object","defineProperty","apply","enumerable","lazyPopStack","lines","split","onoStart","i","length","line","test","splice","join","error"],"sources":["../src/stack.ts"],"sourcesContent":[null],"mappings":"AAEA,MAAMA,OAAO,GAAG,OAAO;AACvB,MAAMC,OAAO,GAAG,WAAW;AAc3B;;;AAGA,OAAM,SAAUC,WAAWA,CAACC,SAAyC;EACnE,OAAOC,OAAO,CACZD,SAAS,IACTA,SAAS,CAACE,YAAY,IACtB,OAAOF,SAAS,CAACG,GAAG,KAAK,UAAU,CACpC;AACH;AAEA;;;AAGA,OAAM,SAAUC,eAAeA,CAACJ,SAAyC;EACvE,OAAOC,OAAO;EACZ;EACA,CAACD,SAAS,IACVA,SAAS,CAACK,QAAQ,IAClB,OAAOL,SAAS,CAACM,GAAG,KAAK,UAAU,CACpC;AACH;AAEA;;;AAGA,OAAM,SAAUC,UAAUA,CAACC,QAAmB,EAAEC,aAAyB;EACvE,IAAIC,QAAQ,GAAGC,QAAQ,CAACH,QAAQ,CAACI,KAAK,CAAC;EACvC,IAAIC,aAAa,GAAGJ,aAAa,GAAGA,aAAa,CAACG,KAAK,GAAGE,SAAS;EAEnE,IAAIJ,QAAQ,IAAIG,aAAa,EAAE;IAC7B,OAAOH,QAAQ,GAAG,MAAM,GAAGG,aAAa;GACzC,MACI;IACH,OAAOH,QAAQ,IAAIG,aAAa;;AAEpC;AAEA;;;AAGA,OAAM,SAAUE,cAAcA,CAACC,SAAoB,EAAER,QAAmB,EAAEC,aAAyB;EACjG,IAAIA,aAAa,EAAE;IACjBQ,MAAM,CAACC,cAAc,CAACV,QAAQ,EAAE,OAAO,EAAE;MACvCL,GAAG,EAAEA,CAAA,KAAK;QACR,IAAIO,QAAQ,GAAGM,SAAS,CAACb,GAAG,CAACgB,KAAK,CAACX,QAAQ,CAAC;QAC5C,OAAOD,UAAU,CAAC;UAAEK,KAAK,EAAEF;QAAQ,CAAE,EAAED,aAAa,CAAC;MACvD,CAAC;MACDW,UAAU,EAAE,KAAK;MACjBlB,YAAY,EAAE;KACf,CAAC;GACH,MACI;IACHmB,YAAY,CAACb,QAAQ,EAAEQ,SAAS,CAAC;;AAErC;AAEA;;;AAGA,SAASL,QAAQA,CAACC,KAAyB;EACzC,IAAIA,KAAK,EAAE;IACT,IAAIU,KAAK,GAAGV,KAAK,CAACW,KAAK,CAAC1B,OAAO,CAAC;IAEhC;IACA,IAAI2B,QAAQ;IACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,IAAIE,IAAI,GAAGL,KAAK,CAACG,CAAC,CAAC;MAEnB,IAAI3B,OAAO,CAAC8B,IAAI,CAACD,IAAI,CAAC,EAAE;QACtB,IAAIH,QAAQ,KAAKV,SAAS,EAAE;UAC1B;UACA;UACAU,QAAQ,GAAGC,CAAC;;OAEf,MACI,IAAID,QAAQ,KAAKV,SAAS,EAAE;QAC/B;QACA;QACAQ,KAAK,CAACO,MAAM,CAACL,QAAQ,EAAEC,CAAC,GAAGD,QAAQ,CAAC;QACpC;;;IAIJ,IAAIF,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;MACpB,OAAOJ,KAAK,CAACQ,IAAI,CAAC,IAAI,CAAC;;;EAI3B;EACA;EACA;EACA,OAAOlB,KAAK;AACd;AAEA;;;AAGA,SAASS,YAAYA,CAACU,KAAgB,EAAEf,SAAoB;EAC1DC,MAAM,CAACC,cAAc,CAACa,KAAK,EAAE,OAAO,EAAE;IACpC5B,GAAG,EAAEA,CAAA,KAAMQ,QAAQ,CAACK,SAAS,CAACb,GAAG,CAACgB,KAAK,CAACY,KAAK,CAAC,CAAC;IAC/CX,UAAU,EAAE,KAAK;IACjBlB,YAAY,EAAE;GACf,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}