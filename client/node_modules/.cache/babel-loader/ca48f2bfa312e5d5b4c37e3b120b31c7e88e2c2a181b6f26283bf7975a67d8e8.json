{"ast":null,"code":"const isWindows = /^win/.test(process.platform);\nconst forwardSlashPattern = /\\//g;\nconst protocolPattern = /^(\\w{2,}):\\/\\//i;\nconst url = module.exports;\nconst jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\n\n/* eslint-disable prettier/prettier */\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns = [/\\?/g, '%3F', /#/g, '%23'];\n\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns = [/%23/g, '#', /%24/g, '$', /%26/g, '&', /%2C/g, ',', /%40/g, '@'];\n/* eslint-enable prettier/prettier */\n\nexports.parse = require('url').parse;\nexports.resolve = require('url').resolve;\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\nexports.cwd = function cwd() {\n  if (process.browser) {\n    // eslint-disable-next-line no-restricted-globals\n    return location.href;\n  }\n  const path = process.cwd();\n  const lastChar = path.slice(-1);\n  if (lastChar === '/' || lastChar === '\\\\') {\n    return path;\n  }\n  return `${path}/`;\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\nexports.getProtocol = function getProtocol(path) {\n  const match = protocolPattern.exec(path);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getExtension = function getExtension(path) {\n  const lastDot = path.lastIndexOf('.');\n  if (lastDot >= 0) {\n    return url.stripQuery(path.substr(lastDot).toLowerCase());\n  }\n  return '';\n};\n\n/**\n * Removes the query, if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripQuery = function stripQuery(path) {\n  const queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    // eslint-disable-next-line no-param-reassign\n    path = path.substr(0, queryIndex);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getHash = function getHash(path) {\n  const hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripHash = function stripHash(path) {\n  const hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    return path.substr(0, hashIndex);\n  }\n  return path;\n};\n\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isHttp = function isHttp(path) {\n  const protocol = url.getProtocol(path);\n  if (protocol === 'http' || protocol === 'https') {\n    return true;\n  } else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  }\n\n  // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n  return false;\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isFileSystemPath = function isFileSystemPath(path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n  const protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === 'file';\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\n/* eslint-disable no-param-reassign */\nexports.fromFileSystemPath = function fromFileSystemPath(path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n  return path;\n};\n/* eslint-enable no-param-reassign */\n\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\n/* eslint-disable no-param-reassign */\nexports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substr(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substr(8) : path.substr(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindows && path[1] === '/') {\n      path = `${path[0]}:${path.substr(1)}`;\n    }\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = `file:///${path}`;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : `/${path}`;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, '\\\\');\n\n    // Capitalize the drive letter\n    if (path.substr(1, 2) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n  return path;\n};\n/* eslint-enable no-param-reassign */\n\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param {string}  pointer\n * @returns {Array<number | string>}\n */\nexports.safePointerToPath = function safePointerToPath(pointer) {\n  if (pointer.length <= 1 || pointer[0] !== '#' || pointer[1] !== '/') {\n    return [];\n  }\n  return pointer.slice(2).split('/').map(value => {\n    return decodeURIComponent(value).replace(jsonPointerSlash, '/').replace(jsonPointerTilde, '~');\n  });\n};","map":{"version":3,"names":["isWindows","test","process","platform","forwardSlashPattern","protocolPattern","url","module","exports","jsonPointerSlash","jsonPointerTilde","urlEncodePatterns","urlDecodePatterns","parse","require","resolve","cwd","browser","location","href","path","lastChar","slice","getProtocol","match","exec","toLowerCase","getExtension","lastDot","lastIndexOf","stripQuery","substr","queryIndex","indexOf","getHash","hashIndex","stripHash","isHttp","protocol","undefined","isFileSystemPath","fromFileSystemPath","replace","encodeURI","i","length","toFileSystemPath","keepFileProtocol","decodeURI","isFileUrl","toUpperCase","safePointerToPath","pointer","split","map","value","decodeURIComponent"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/util/url.js"],"sourcesContent":["const isWindows = /^win/.test(process.platform);\nconst forwardSlashPattern = /\\//g;\nconst protocolPattern = /^(\\w{2,}):\\/\\//i;\nconst url = module.exports;\nconst jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\n\n/* eslint-disable prettier/prettier */\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns = [\n  /\\?/g, '%3F',\n  /#/g, '%23',\n];\n\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns = [\n  /%23/g, '#',\n  /%24/g, '$',\n  /%26/g, '&',\n  /%2C/g, ',',\n  /%40/g, '@',\n];\n/* eslint-enable prettier/prettier */\n\nexports.parse = require('url').parse;\nexports.resolve = require('url').resolve;\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\nexports.cwd = function cwd() {\n  if (process.browser) {\n    // eslint-disable-next-line no-restricted-globals\n    return location.href;\n  }\n\n  const path = process.cwd();\n\n  const lastChar = path.slice(-1);\n  if (lastChar === '/' || lastChar === '\\\\') {\n    return path;\n  }\n\n  return `${path}/`;\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\nexports.getProtocol = function getProtocol(path) {\n  const match = protocolPattern.exec(path);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getExtension = function getExtension(path) {\n  const lastDot = path.lastIndexOf('.');\n  if (lastDot >= 0) {\n    return url.stripQuery(path.substr(lastDot).toLowerCase());\n  }\n  return '';\n};\n\n/**\n * Removes the query, if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripQuery = function stripQuery(path) {\n  const queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    // eslint-disable-next-line no-param-reassign\n    path = path.substr(0, queryIndex);\n  }\n  return path;\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getHash = function getHash(path) {\n  const hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n  return '#';\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripHash = function stripHash(path) {\n  const hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    return path.substr(0, hashIndex);\n  }\n  return path;\n};\n\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isHttp = function isHttp(path) {\n  const protocol = url.getProtocol(path);\n  if (protocol === 'http' || protocol === 'https') {\n    return true;\n  } else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  }\n\n  // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n  return false;\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isFileSystemPath = function isFileSystemPath(path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  const protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === 'file';\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\n/* eslint-disable no-param-reassign */\nexports.fromFileSystemPath = function fromFileSystemPath(path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, '/');\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n\n  return path;\n};\n/* eslint-enable no-param-reassign */\n\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\n/* eslint-disable no-param-reassign */\nexports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substr(0, 7).toLowerCase() === 'file://';\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === '/' ? path.substr(8) : path.substr(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindows && path[1] === '/') {\n      path = `${path[0]}:${path.substr(1)}`;\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = `file:///${path}`;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : `/${path}`;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, '\\\\');\n\n    // Capitalize the drive letter\n    if (path.substr(1, 2) === ':\\\\') {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n};\n/* eslint-enable no-param-reassign */\n\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param {string}  pointer\n * @returns {Array<number | string>}\n */\nexports.safePointerToPath = function safePointerToPath(pointer) {\n  if (pointer.length <= 1 || pointer[0] !== '#' || pointer[1] !== '/') {\n    return [];\n  }\n\n  return pointer\n    .slice(2)\n    .split('/')\n    .map(value => {\n      return decodeURIComponent(value).replace(jsonPointerSlash, '/').replace(jsonPointerTilde, '~');\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}