{"ast":null,"code":"/* eslint-disable no-param-reassign */\nconst binaryParser = require('./parsers/binary');\nconst jsonParser = require('./parsers/json');\nconst textParser = require('./parsers/text');\nconst yamlParser = require('./parsers/yaml');\nconst fileResolver = require('./resolvers/file');\nconst httpResolver = require('./resolvers/http');\nmodule.exports = $RefParserOptions;\n\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param {object|$RefParserOptions} [options] - Overridden options\n * @constructor\n */\nfunction $RefParserOptions(options) {\n  merge(this, $RefParserOptions.defaults);\n  merge(this, options);\n}\n$RefParserOptions.defaults = {\n  /**\n   * Determines how different types of files will be parsed.\n   *\n   * You can add additional parsers of your own, replace an existing one with\n   * your own implementation, or disable any parser by setting it to false.\n   */\n  parse: {\n    json: jsonParser,\n    yaml: yamlParser,\n    text: textParser,\n    binary: binaryParser\n  },\n  /**\n   * Determines how JSON References will be resolved.\n   *\n   * You can add additional resolvers of your own, replace an existing one with\n   * your own implementation, or disable any resolver by setting it to false.\n   */\n  resolve: {\n    file: fileResolver,\n    http: httpResolver,\n    /**\n     * Determines whether external $ref pointers will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external $ref pointers will simply be ignored.\n     *\n     * @type {boolean}\n     */\n    external: true\n  },\n  /**\n   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n   * causes it to keep processing as much as possible and then throw a single error that contains all errors\n   * that were encountered.\n   */\n  continueOnError: false,\n  /**\n   * Determines the types of JSON references that are allowed.\n   */\n  dereference: {\n    /**\n     * Dereference circular (recursive) JSON references?\n     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n     * If \"ignore\", then circular references will not be dereferenced.\n     *\n     * @type {boolean|string}\n     */\n    circular: true\n  }\n};\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param {object} target - The object that we're populating\n * @param {?object} source - The options that are being merged\n * @returns {object}\n */\nfunction merge(target, source) {\n  if (isMergeable(source)) {\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const sourceSetting = source[key];\n      const targetSetting = target[key];\n      if (isMergeable(sourceSetting)) {\n        // It's a nested object, so merge it recursively\n        target[key] = merge(targetSetting || {}, sourceSetting);\n      } else if (sourceSetting !== undefined) {\n        // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n        target[key] = sourceSetting;\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param   {*}  val\n * @returns {Boolean}\n */\nfunction isMergeable(val) {\n  return val && typeof val === 'object' && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}","map":{"version":3,"names":["binaryParser","require","jsonParser","textParser","yamlParser","fileResolver","httpResolver","module","exports","$RefParserOptions","options","merge","defaults","parse","json","yaml","text","binary","resolve","file","http","external","continueOnError","dereference","circular","target","source","isMergeable","keys","Object","i","length","key","sourceSetting","targetSetting","undefined","val","Array","isArray","RegExp","Date"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/options.js"],"sourcesContent":["/* eslint-disable no-param-reassign */\nconst binaryParser = require('./parsers/binary');\nconst jsonParser = require('./parsers/json');\nconst textParser = require('./parsers/text');\nconst yamlParser = require('./parsers/yaml');\nconst fileResolver = require('./resolvers/file');\nconst httpResolver = require('./resolvers/http');\n\nmodule.exports = $RefParserOptions;\n\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param {object|$RefParserOptions} [options] - Overridden options\n * @constructor\n */\nfunction $RefParserOptions(options) {\n  merge(this, $RefParserOptions.defaults);\n  merge(this, options);\n}\n\n$RefParserOptions.defaults = {\n  /**\n   * Determines how different types of files will be parsed.\n   *\n   * You can add additional parsers of your own, replace an existing one with\n   * your own implementation, or disable any parser by setting it to false.\n   */\n  parse: {\n    json: jsonParser,\n    yaml: yamlParser,\n    text: textParser,\n    binary: binaryParser,\n  },\n\n  /**\n   * Determines how JSON References will be resolved.\n   *\n   * You can add additional resolvers of your own, replace an existing one with\n   * your own implementation, or disable any resolver by setting it to false.\n   */\n  resolve: {\n    file: fileResolver,\n    http: httpResolver,\n\n    /**\n     * Determines whether external $ref pointers will be resolved.\n     * If this option is disabled, then none of above resolvers will be called.\n     * Instead, external $ref pointers will simply be ignored.\n     *\n     * @type {boolean}\n     */\n    external: true,\n  },\n\n  /**\n   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n   * causes it to keep processing as much as possible and then throw a single error that contains all errors\n   * that were encountered.\n   */\n  continueOnError: false,\n\n  /**\n   * Determines the types of JSON references that are allowed.\n   */\n  dereference: {\n    /**\n     * Dereference circular (recursive) JSON references?\n     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n     * If \"ignore\", then circular references will not be dereferenced.\n     *\n     * @type {boolean|string}\n     */\n    circular: true,\n  },\n};\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param {object} target - The object that we're populating\n * @param {?object} source - The options that are being merged\n * @returns {object}\n */\nfunction merge(target, source) {\n  if (isMergeable(source)) {\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const sourceSetting = source[key];\n      const targetSetting = target[key];\n\n      if (isMergeable(sourceSetting)) {\n        // It's a nested object, so merge it recursively\n        target[key] = merge(targetSetting || {}, sourceSetting);\n      } else if (sourceSetting !== undefined) {\n        // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n        target[key] = sourceSetting;\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param   {*}  val\n * @returns {Boolean}\n */\nfunction isMergeable(val) {\n  return val && typeof val === 'object' && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}\n"],"mappings":"AAAA;AACA,MAAMA,YAAY,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAChD,MAAMC,UAAU,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC5C,MAAME,UAAU,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAC5C,MAAMG,UAAU,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAC5C,MAAMI,YAAY,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;AAChD,MAAMK,YAAY,GAAGL,OAAO,CAAC,kBAAkB,CAAC;AAEhDM,MAAM,CAACC,OAAO,GAAGC,iBAAiB;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,iBAAiBA,CAACC,OAAO,EAAE;EAClCC,KAAK,CAAC,IAAI,EAAEF,iBAAiB,CAACG,QAAQ,CAAC;EACvCD,KAAK,CAAC,IAAI,EAAED,OAAO,CAAC;AACtB;AAEAD,iBAAiB,CAACG,QAAQ,GAAG;EAC3B;AACF;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE;IACLC,IAAI,EAAEZ,UAAU;IAChBa,IAAI,EAAEX,UAAU;IAChBY,IAAI,EAAEb,UAAU;IAChBc,MAAM,EAAEjB;EACV,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEkB,OAAO,EAAE;IACPC,IAAI,EAAEd,YAAY;IAClBe,IAAI,EAAEd,YAAY;IAElB;AACJ;AACA;AACA;AACA;AACA;AACA;IACIe,QAAQ,EAAE;EACZ,CAAC;EAED;AACF;AACA;AACA;AACA;EACEC,eAAe,EAAE,KAAK;EAEtB;AACF;AACA;EACEC,WAAW,EAAE;IACX;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,QAAQ,EAAE;EACZ;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,KAAKA,CAACc,MAAM,EAAEC,MAAM,EAAE;EAC7B,IAAIC,WAAW,CAACD,MAAM,CAAC,EAAE;IACvB,MAAME,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACF,MAAM,CAAC;IAChC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,MAAME,GAAG,GAAGJ,IAAI,CAACE,CAAC,CAAC;MACnB,MAAMG,aAAa,GAAGP,MAAM,CAACM,GAAG,CAAC;MACjC,MAAME,aAAa,GAAGT,MAAM,CAACO,GAAG,CAAC;MAEjC,IAAIL,WAAW,CAACM,aAAa,CAAC,EAAE;QAC9B;QACAR,MAAM,CAACO,GAAG,CAAC,GAAGrB,KAAK,CAACuB,aAAa,IAAI,CAAC,CAAC,EAAED,aAAa,CAAC;MACzD,CAAC,MAAM,IAAIA,aAAa,KAAKE,SAAS,EAAE;QACtC;QACAV,MAAM,CAACO,GAAG,CAAC,GAAGC,aAAa;MAC7B;IACF;EACF;EAEA,OAAOR,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,WAAWA,CAACS,GAAG,EAAE;EACxB,OAAOA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,IAAI,EAAEA,GAAG,YAAYG,MAAM,CAAC,IAAI,EAAEH,GAAG,YAAYI,IAAI,CAAC;AACpH","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}