{"ast":null,"code":"const http = require('http');\nconst https = require('https');\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst {\n  ResolverError\n} = require('../util/errors');\nconst url = require('../util/url');\n\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\nfunction get(u, httpOptions) {\n  return new Promise((resolve, reject) => {\n    // console.log('GET', u.href);\n\n    const protocol = u.protocol === 'https:' ? https : http;\n    const req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n    if (typeof req.setTimeout === 'function') {\n      req.setTimeout(httpOptions.timeout);\n    }\n    req.on('timeout', () => {\n      req.abort();\n    });\n    req.on('error', reject);\n    req.once('response', res => {\n      res.body = Buffer.alloc(0);\n      res.on('data', data => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n      res.on('error', reject);\n      res.on('end', () => {\n        resolve(res);\n      });\n    });\n  });\n}\n\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nfunction download(u, httpOptions, redirects) {\n  return new Promise((resolve, reject) => {\n    u = url.parse(u); // eslint-disable-line no-param-reassign\n    redirects = redirects || []; // eslint-disable-line no-param-reassign\n    redirects.push(u.href);\n    get(u, httpOptions).then(res => {\n      if (res.statusCode >= 400) {\n        throw ono({\n          status: res.statusCode\n        }, `HTTP ERROR ${res.statusCode}`);\n      } else if (res.statusCode >= 300) {\n        if (redirects.length > httpOptions.redirects) {\n          reject(new ResolverError(ono({\n            status: res.statusCode\n          }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(' \\n  ')}`)));\n        } else if (!res.headers.location) {\n          throw ono({\n            status: res.statusCode\n          }, `HTTP ${res.statusCode} redirect with no location header`);\n        } else {\n          // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n          const redirectTo = url.resolve(u, res.headers.location);\n          download(redirectTo, httpOptions, redirects).then(resolve, reject);\n        }\n      } else {\n        resolve(res.body || Buffer.alloc(0));\n      }\n    }).catch(err => {\n      reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n    });\n  });\n}\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000,\n  // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isHttp(file.url);\n  },\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    const u = url.parse(file.url);\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      // eslint-disable-next-line no-restricted-globals\n      u.protocol = url.parse(location.href).protocol;\n    }\n    return download(u, this);\n  }\n};","map":{"version":3,"names":["http","require","https","ono","ResolverError","url","get","u","httpOptions","Promise","resolve","reject","protocol","req","hostname","port","path","auth","headers","withCredentials","setTimeout","timeout","on","abort","once","res","body","Buffer","alloc","data","concat","from","download","redirects","parse","push","href","then","statusCode","status","length","join","location","redirectTo","catch","err","module","exports","order","canRead","file","isHttp","read","process","browser"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/client/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/resolvers/http.js"],"sourcesContent":["const http = require('http');\nconst https = require('https');\n\nconst { ono } = require('@jsdevtools/ono');\n\nconst { ResolverError } = require('../util/errors');\nconst url = require('../util/url');\n\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\nfunction get(u, httpOptions) {\n  return new Promise((resolve, reject) => {\n    // console.log('GET', u.href);\n\n    const protocol = u.protocol === 'https:' ? https : http;\n    const req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials,\n    });\n\n    if (typeof req.setTimeout === 'function') {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on('timeout', () => {\n      req.abort();\n    });\n\n    req.on('error', reject);\n\n    req.once('response', res => {\n      res.body = Buffer.alloc(0);\n\n      res.on('data', data => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n\n      res.on('error', reject);\n\n      res.on('end', () => {\n        resolve(res);\n      });\n    });\n  });\n}\n\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nfunction download(u, httpOptions, redirects) {\n  return new Promise((resolve, reject) => {\n    u = url.parse(u); // eslint-disable-line no-param-reassign\n    redirects = redirects || []; // eslint-disable-line no-param-reassign\n    redirects.push(u.href);\n\n    get(u, httpOptions)\n      .then(res => {\n        if (res.statusCode >= 400) {\n          throw ono({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);\n        } else if (res.statusCode >= 300) {\n          if (redirects.length > httpOptions.redirects) {\n            reject(\n              new ResolverError(\n                ono(\n                  { status: res.statusCode },\n                  `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(' \\n  ')}`\n                )\n              )\n            );\n          } else if (!res.headers.location) {\n            throw ono({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);\n          } else {\n            // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n            const redirectTo = url.resolve(u, res.headers.location);\n            download(redirectTo, httpOptions, redirects).then(resolve, reject);\n          }\n        } else {\n          resolve(res.body || Buffer.alloc(0));\n        }\n      })\n      .catch(err => {\n        reject(new ResolverError(ono(err, `Error downloading ${u.href}`), u.href));\n      });\n  });\n}\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000, // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    const u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      // eslint-disable-next-line no-restricted-globals\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}