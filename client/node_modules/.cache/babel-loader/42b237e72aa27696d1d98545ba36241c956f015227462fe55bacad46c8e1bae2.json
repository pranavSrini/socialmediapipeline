{"ast":null,"code":"const fs = require('fs');\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst {\n  ResolverError\n} = require('../util/errors');\nconst url = require('../util/url');\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 100,\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isFileSystemPath(file.url);\n  },\n  /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    return new Promise((resolve, reject) => {\n      let path;\n      try {\n        path = url.toFileSystemPath(file.url);\n      } catch (err) {\n        reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));\n      }\n\n      // console.log('Opening file: %s', path);\n\n      try {\n        fs.readFile(path, (err, data) => {\n          if (err) {\n            reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n          } else {\n            resolve(data);\n          }\n        });\n      } catch (err) {\n        reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n      }\n    });\n  }\n};","map":{"version":3,"names":["fs","require","ono","ResolverError","url","module","exports","order","canRead","file","isFileSystemPath","read","Promise","resolve","reject","path","toFileSystemPath","err","uri","readFile","data"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/json-schema-ref-parser/lib/resolvers/file.js"],"sourcesContent":["const fs = require('fs');\n\nconst { ono } = require('@jsdevtools/ono');\n\nconst { ResolverError } = require('../util/errors');\nconst url = require('../util/url');\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isFileSystemPath(file.url);\n  },\n\n  /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    return new Promise((resolve, reject) => {\n      let path;\n      try {\n        path = url.toFileSystemPath(file.url);\n      } catch (err) {\n        reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));\n      }\n\n      // console.log('Opening file: %s', path);\n\n      try {\n        fs.readFile(path, (err, data) => {\n          if (err) {\n            reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n          } else {\n            resolve(data);\n          }\n        });\n      } catch (err) {\n        reject(new ResolverError(ono(err, `Error opening file \"${path}\"`), path));\n      }\n    });\n  },\n};\n"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AAExB,MAAM;EAAEC;AAAI,CAAC,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAE1C,MAAM;EAAEE;AAAc,CAAC,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AACnD,MAAMG,GAAG,GAAGH,OAAO,CAAC,aAAa,CAAC;AAElCI,MAAM,CAACC,OAAO,GAAG;EACf;AACF;AACA;AACA;AACA;EACEC,KAAK,EAAE,GAAG;EAEV;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAACC,IAAI,EAAE;IACZ,OAAOL,GAAG,CAACM,gBAAgB,CAACD,IAAI,CAACL,GAAG,CAAC;EACvC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,IAAIA,CAACF,IAAI,EAAE;IACT,OAAO,IAAIG,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAIC,IAAI;MACR,IAAI;QACFA,IAAI,GAAGX,GAAG,CAACY,gBAAgB,CAACP,IAAI,CAACL,GAAG,CAAC;MACvC,CAAC,CAAC,OAAOa,GAAG,EAAE;QACZH,MAAM,CAAC,IAAIX,aAAa,CAACD,GAAG,CAACgB,GAAG,CAACD,GAAG,EAAE,kBAAkBR,IAAI,CAACL,GAAG,EAAE,CAAC,EAAEK,IAAI,CAACL,GAAG,CAAC,CAAC;MACjF;;MAEA;;MAEA,IAAI;QACFJ,EAAE,CAACmB,QAAQ,CAACJ,IAAI,EAAE,CAACE,GAAG,EAAEG,IAAI,KAAK;UAC/B,IAAIH,GAAG,EAAE;YACPH,MAAM,CAAC,IAAIX,aAAa,CAACD,GAAG,CAACe,GAAG,EAAE,uBAAuBF,IAAI,GAAG,CAAC,EAAEA,IAAI,CAAC,CAAC;UAC3E,CAAC,MAAM;YACLF,OAAO,CAACO,IAAI,CAAC;UACf;QACF,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOH,GAAG,EAAE;QACZH,MAAM,CAAC,IAAIX,aAAa,CAACD,GAAG,CAACe,GAAG,EAAE,uBAAuBF,IAAI,GAAG,CAAC,EAAEA,IAAI,CAAC,CAAC;MAC3E;IACF,CAAC,CAAC;EACJ;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}