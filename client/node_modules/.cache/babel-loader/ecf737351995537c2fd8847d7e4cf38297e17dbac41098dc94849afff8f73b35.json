{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nvar fs_1 = __importDefault(require(\"fs\"));\nvar path_1 = __importDefault(require(\"path\"));\nvar stream_1 = __importDefault(require(\"stream\"));\nvar caseless_1 = __importDefault(require(\"caseless\"));\nvar parser_1 = __importDefault(require(\"datauri/parser\"));\nvar sync_1 = __importDefault(require(\"datauri/sync\"));\nvar get_stream_1 = __importDefault(require(\"get-stream\"));\nvar merge_1 = __importDefault(require(\"lodash/merge\"));\nvar remove_undefined_objects_1 = __importDefault(require(\"remove-undefined-objects\"));\nvar getJSONSchemaDefaults_1 = __importDefault(require(\"./getJSONSchemaDefaults\"));\n// These headers are normally only defined by the OpenAPI definition but we allow the user to\n// manually supply them in their `metadata` parameter if they wish.\nvar specialHeaders = ['accept', 'authorization'];\n/**\n * Extract all available parameters from an operations Parameter Object into a digestable array\n * that we can use to apply to the request.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameterObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameterObject}\n */\nfunction digestParameters(parameters) {\n  return parameters.reduce(function (prev, param) {\n    var _a;\n    if ('$ref' in param || 'allOf' in param || 'anyOf' in param || 'oneOf' in param) {\n      throw new Error(\"The OpenAPI document for this operation wasn't dereferenced before processing.\");\n    } else if (param.name in prev) {\n      throw new Error(\"The operation you are using has the same parameter, \".concat(param.name, \", spread across multiple entry points. We unfortunately can't handle this right now.\"));\n    }\n    return Object.assign(prev, (_a = {}, _a[param.name] = param, _a));\n  }, {});\n}\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\nfunction isEmpty(obj) {\n  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;\n}\nfunction isObject(thing) {\n  if (thing instanceof stream_1[\"default\"].Readable) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\nfunction isPrimitive(obj) {\n  return obj === null || typeof obj === 'number' || typeof obj === 'string';\n}\nfunction merge(src, target) {\n  if (Array.isArray(target)) {\n    // @todo we need to add support for merging array defaults with array body/metadata arguments\n    return target;\n  } else if (!isObject(target)) {\n    return target;\n  }\n  return (0, merge_1[\"default\"])(src, target);\n}\n/**\n * Ingest a file path or readable stream into a common object that we can later use to process it\n * into a parameters object for making an API request.\n *\n */\nfunction processFile(paramName, file) {\n  var _this = this;\n  if (typeof file === 'string') {\n    // In order to support relative pathed files, we need to attempt to resolve them.\n    var resolvedFile_1 = path_1[\"default\"].resolve(file);\n    return new Promise(function (resolve, reject) {\n      fs_1[\"default\"].stat(resolvedFile_1, function (err) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var fileMetadata, payloadFilename;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (err) {\n                  if (err.code === 'ENOENT') {\n                    // It's less than ideal for us to handle files that don't exist like this but because\n                    // `file` is a string it might actually be the full text contents of the file and not\n                    // actually a path.\n                    //\n                    // We also can't really regex to see if `file` *looks*` like a path because one should be\n                    // able to pass in a relative `owlbert.png` (instead of `./owlbert.png`) and though that\n                    // doesn't *look* like a path, it is one that should still work.\n                    return [2 /*return*/, resolve(undefined)];\n                  }\n                  return [2 /*return*/, reject(err)];\n                }\n                return [4 /*yield*/, (0, sync_1[\"default\"])(resolvedFile_1)];\n              case 1:\n                fileMetadata = _a.sent();\n                payloadFilename = encodeURIComponent(path_1[\"default\"].basename(resolvedFile_1));\n                return [2 /*return*/, resolve({\n                  paramName: paramName,\n                  base64: fileMetadata.content.replace(';base64', \";name=\".concat(payloadFilename, \";base64\")),\n                  filename: payloadFilename,\n                  buffer: fileMetadata.buffer\n                })];\n            }\n          });\n        });\n      });\n    });\n  } else if (file instanceof stream_1[\"default\"].Readable) {\n    return get_stream_1[\"default\"].buffer(file).then(function (buffer) {\n      var filePath = file.path;\n      var parser = new parser_1[\"default\"]();\n      var base64 = parser.format(filePath, buffer).content;\n      var payloadFilename = encodeURIComponent(path_1[\"default\"].basename(filePath));\n      return {\n        paramName: paramName,\n        base64: base64.replace(';base64', \";name=\".concat(payloadFilename, \";base64\")),\n        filename: payloadFilename,\n        buffer: buffer\n      };\n    });\n  }\n  return Promise.reject(new TypeError(paramName ? \"The data supplied for the `\".concat(paramName, \"` request body parameter is not a file handler that we support.\") : 'The data supplied for the request body payload is not a file handler that we support.'));\n}\n/**\n * With potentially supplied body and/or metadata we need to run through them against a given API\n * operation to see what's what and prepare any available parameters to be used in an API request\n * with `@readme/oas-to-har`.\n *\n */\nfunction prepareParams(operation, body, metadata) {\n  var _a, _b, _c, _d;\n  return __awaiter(this, void 0, void 0, function () {\n    var metadataIntersected, digestedParameters, jsonSchema, throwNoParamsError, bodyParams_1, jsonSchemaDefaults, params, headerParams_1, intersection, payloadJsonSchema, conversions_1;\n    return __generator(this, function (_e) {\n      switch (_e.label) {\n        case 0:\n          metadataIntersected = false;\n          digestedParameters = digestParameters(operation.getParameters());\n          jsonSchema = operation.getParametersAsJSONSchema();\n          /**\n           * It might be common for somebody to run `sdk.findPetsByStatus({ status: 'available' }, {})`, in\n           * which case we want to filter out the second (metadata) parameter and treat the first parameter\n           * as the metadata instead. If we don't do this, their supplied `status` metadata will be treated\n           * as a body parameter, and because there's no `status` body parameter, and no supplied metadata\n           * (because it's an empty object), the request won't send a payload.\n           *\n           * @see {@link https://github.com/readmeio/api/issues/449}\n           */\n          // eslint-disable-next-line no-param-reassign\n          metadata = (0, remove_undefined_objects_1[\"default\"])(metadata);\n          if (!jsonSchema && (body !== undefined || metadata !== undefined)) {\n            throwNoParamsError = true;\n            // If this operation doesn't have any parameters for us to transform to JSON Schema but they've\n            // sent us either an `Accept` or `Authorization` header (or both) we should let them do that.\n            // We should, however, only do this check for the `body` parameter as if they've sent this\n            // request both `body` and `metadata` we can reject it outright as the operation won't have any\n            // body data.\n            if (body !== undefined) {\n              if (typeof body === 'object' && body !== null && !Array.isArray(body)) {\n                if (Object.keys(body).length <= 2) {\n                  bodyParams_1 = (0, caseless_1[\"default\"])(body);\n                  if (specialHeaders.some(function (header) {\n                    return bodyParams_1.has(header);\n                  })) {\n                    throwNoParamsError = false;\n                  }\n                }\n              }\n            }\n            if (throwNoParamsError) {\n              throw new Error(\"You supplied metadata and/or body data for this operation but it doesn't have any documented parameters or request payloads. If you think this is an error please contact support for the API you're using.\");\n            }\n          }\n          jsonSchemaDefaults = jsonSchema ? (0, getJSONSchemaDefaults_1[\"default\"])(jsonSchema) : {};\n          params = jsonSchemaDefaults;\n          // If a body argument was supplied we need to do a bit of work to see if it's actually a body\n          // argument or metadata because the library lets you supply either a body, metadata, or body with\n          // metadata.\n          if (typeof body !== 'undefined') {\n            if (Array.isArray(body) || isPrimitive(body)) {\n              // If the body param is an array or a primitive then we know it's absolutely a body because\n              // metadata can only ever be undefined or an object.\n              params.body = merge(params.body, body);\n            } else if (typeof metadata === 'undefined') {\n              headerParams_1 = (0, caseless_1[\"default\"])({});\n              Object.entries(digestedParameters).forEach(function (_a) {\n                var paramName = _a[0],\n                  param = _a[1];\n                // Headers are sent case-insensitive so we need to make sure that we're properly\n                // matching them when detecting what our incoming payload looks like.\n                if (param[\"in\"] === 'header') {\n                  headerParams_1.set(paramName, '');\n                }\n              });\n              // `Accept` and `Authorization` headers can't be defined as normal parameters but we should\n              // always allow the user to supply them if they wish.\n              specialHeaders.forEach(function (header) {\n                if (!headerParams_1.has(header)) {\n                  headerParams_1.set(header, '');\n                }\n              });\n              intersection = Object.keys(body).filter(function (value) {\n                if (Object.keys(digestedParameters).includes(value)) {\n                  return true;\n                } else if (headerParams_1.has(value)) {\n                  return true;\n                }\n                return false;\n              }).length;\n              if (intersection && intersection / Object.keys(body).length > 0.25) {\n                /* eslint-disable no-param-reassign */\n                // If more than 25% of the body intersects with the parameters that we've got on hand,\n                // then we should treat it as a metadata object and organize into parameters.\n                metadataIntersected = true;\n                metadata = merge(params.body, body);\n                body = undefined;\n                /* eslint-enable no-param-reassign */\n              } else {\n                // For all other cases, we should just treat the supplied body as a body.\n                params.body = merge(params.body, body);\n              }\n            } else {\n              // Body and metadata were both supplied.\n              params.body = merge(params.body, body);\n            }\n          }\n          if (!!operation.hasRequestBody()) return [3 /*break*/, 1];\n          // If this operation doesn't have any documented request body then we shouldn't be sending\n          // anything.\n          delete params.body;\n          return [3 /*break*/, 3];\n        case 1:\n          if (!('body' in params)) params.body = {};\n          payloadJsonSchema = jsonSchema.find(function (js) {\n            return js.type === 'body';\n          });\n          if (!payloadJsonSchema) return [3 /*break*/, 3];\n          if (!params.files) params.files = {};\n          conversions_1 = [];\n          // @todo add support for `type: array`, `oneOf` and `anyOf`\n          if ((_a = payloadJsonSchema.schema) === null || _a === void 0 ? void 0 : _a.properties) {\n            Object.entries((_b = payloadJsonSchema.schema) === null || _b === void 0 ? void 0 : _b.properties).filter(function (_a) {\n              var schema = _a[1];\n              return (schema === null || schema === void 0 ? void 0 : schema.format) === 'binary';\n            }).filter(function (_a) {\n              var prop = _a[0];\n              return Object.keys(params.body).includes(prop);\n            }).forEach(function (_a) {\n              var prop = _a[0];\n              conversions_1.push(processFile(prop, params.body[prop]));\n            });\n          } else if (((_c = payloadJsonSchema.schema) === null || _c === void 0 ? void 0 : _c.type) === 'string') {\n            if (((_d = payloadJsonSchema.schema) === null || _d === void 0 ? void 0 : _d.format) === 'binary') {\n              conversions_1.push(processFile(undefined, params.body));\n            }\n          }\n          return [4 /*yield*/, Promise.all(conversions_1).then(function (fileMetadata) {\n            return fileMetadata.filter(Boolean);\n          }).then(function (fm) {\n            fm.forEach(function (fileMetadata) {\n              if (!fileMetadata) {\n                // If we don't have any metadata here it's because the file we have is likely\n                // the full string content of the file so since we don't have any filenames to\n                // work with we shouldn't do any additional handling to the `body` or `files`\n                // parameters.\n                return;\n              }\n              if (fileMetadata.paramName) {\n                params.body[fileMetadata.paramName] = fileMetadata.base64;\n              } else {\n                params.body = fileMetadata.base64;\n              }\n              params.files[fileMetadata.filename] = fileMetadata.buffer;\n            });\n          })];\n        case 2:\n          _e.sent();\n          _e.label = 3;\n        case 3:\n          // Form data should be placed within `formData` instead of `body` for it to properly get picked\n          // up by `fetch-har`.\n          if (operation.isFormUrlEncoded()) {\n            params.formData = merge(params.formData, params.body);\n            delete params.body;\n          }\n          // Only spend time trying to organize metadata into parameters if we were able to digest\n          // parameters out of the operation schema. If we couldn't digest anything, but metadata was\n          // supplied then we wouldn't know how to send it in the request!\n          if (typeof metadata !== 'undefined') {\n            if (!('cookie' in params)) params.cookie = {};\n            if (!('header' in params)) params.header = {};\n            if (!('path' in params)) params.path = {};\n            if (!('query' in params)) params.query = {};\n            Object.entries(digestedParameters).forEach(function (_a) {\n              var paramName = _a[0],\n                param = _a[1];\n              var value;\n              var metadataHeaderParam;\n              if (typeof metadata === 'object' && !isEmpty(metadata)) {\n                if (paramName in metadata) {\n                  value = metadata[paramName];\n                  metadataHeaderParam = paramName;\n                } else if (param[\"in\"] === 'header') {\n                  // Headers are sent case-insensitive so we need to make sure that we're properly\n                  // matching them when detecting what our incoming payload looks like.\n                  metadataHeaderParam = Object.keys(metadata).find(function (k) {\n                    return k.toLowerCase() === paramName.toLowerCase();\n                  });\n                  value = metadata[metadataHeaderParam];\n                }\n              }\n              if (value === undefined) {\n                return;\n              }\n              /* eslint-disable no-param-reassign */\n              switch (param[\"in\"]) {\n                case 'path':\n                  params.path[paramName] = value;\n                  delete metadata[paramName];\n                  break;\n                case 'query':\n                  params.query[paramName] = value;\n                  delete metadata[paramName];\n                  break;\n                case 'header':\n                  params.header[paramName.toLowerCase()] = value;\n                  delete metadata[metadataHeaderParam];\n                  break;\n                case 'cookie':\n                  params.cookie[paramName] = value;\n                  delete metadata[paramName];\n                  break;\n                default: // no-op\n              }\n              /* eslint-enable no-param-reassign */\n              // Because a user might have sent just a metadata object, we want to make sure that we filter\n              // out anything that they sent that is a parameter from also being sent as part of a form\n              // data payload for `x-www-form-urlencoded` requests.\n              if (metadataIntersected && operation.isFormUrlEncoded()) {\n                if (paramName in params.formData) {\n                  delete params.formData[paramName];\n                }\n              }\n            });\n            // If there's any leftover metadata that hasn't been moved into form data for this request we\n            // need to move it or else it'll get tossed.\n            if (!isEmpty(metadata)) {\n              if (typeof metadata === 'object') {\n                // If the user supplied an `accept` or `authorization` header themselves we should allow it\n                // through. Normally these headers are automatically handled by `@readme/oas-to-har` but in\n                // the event that maybe the user wants to return XML for an API that normally returns JSON\n                // or specify a custom auth header (maybe we can't handle their auth case right) this is the\n                // only way with this library that they can do that.\n                specialHeaders.forEach(function (headerName) {\n                  var headerParam = Object.keys(metadata).find(function (m) {\n                    return m.toLowerCase() === headerName;\n                  });\n                  if (headerParam) {\n                    params.header[headerName] = metadata[headerParam];\n                    // eslint-disable-next-line no-param-reassign\n                    delete metadata[headerParam];\n                  }\n                });\n              }\n              if (operation.isFormUrlEncoded()) {\n                params.formData = merge(params.formData, metadata);\n              } else {\n                // Any other remaining unused metadata will be unused because we don't know where to place\n                // it in the request.\n              }\n            }\n          }\n          ['body', 'cookie', 'files', 'formData', 'header', 'path', 'query'].forEach(function (type) {\n            if (type in params && isEmpty(params[type])) {\n              delete params[type];\n            }\n          });\n          return [2 /*return*/, params];\n      }\n    });\n  });\n}\nexports[\"default\"] = prepareParams;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__importDefault","mod","__esModule","exports","fs_1","require","path_1","stream_1","caseless_1","parser_1","sync_1","get_stream_1","merge_1","remove_undefined_objects_1","getJSONSchemaDefaults_1","specialHeaders","digestParameters","parameters","reduce","prev","param","_a","Error","name","concat","Object","assign","isEmpty","obj","Array","includes","constructor","entries","isObject","thing","Readable","isArray","isPrimitive","merge","src","target","processFile","paramName","file","_this","resolvedFile_1","stat","err","fileMetadata","payloadFilename","code","undefined","encodeURIComponent","basename","base64","content","replace","filename","buffer","filePath","path","parser","format","prepareParams","operation","metadata","_b","_c","_d","metadataIntersected","digestedParameters","jsonSchema","throwNoParamsError","bodyParams_1","jsonSchemaDefaults","params","headerParams_1","intersection","payloadJsonSchema","conversions_1","_e","getParameters","getParametersAsJSONSchema","keys","some","header","has","forEach","set","filter","hasRequestBody","find","js","type","files","schema","properties","prop","all","Boolean","fm","isFormUrlEncoded","formData","cookie","query","metadataHeaderParam","k","toLowerCase","headerName","headerParam","m"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/api/dist/core/prepareParams.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nvar fs_1 = __importDefault(require(\"fs\"));\nvar path_1 = __importDefault(require(\"path\"));\nvar stream_1 = __importDefault(require(\"stream\"));\nvar caseless_1 = __importDefault(require(\"caseless\"));\nvar parser_1 = __importDefault(require(\"datauri/parser\"));\nvar sync_1 = __importDefault(require(\"datauri/sync\"));\nvar get_stream_1 = __importDefault(require(\"get-stream\"));\nvar merge_1 = __importDefault(require(\"lodash/merge\"));\nvar remove_undefined_objects_1 = __importDefault(require(\"remove-undefined-objects\"));\nvar getJSONSchemaDefaults_1 = __importDefault(require(\"./getJSONSchemaDefaults\"));\n// These headers are normally only defined by the OpenAPI definition but we allow the user to\n// manually supply them in their `metadata` parameter if they wish.\nvar specialHeaders = ['accept', 'authorization'];\n/**\n * Extract all available parameters from an operations Parameter Object into a digestable array\n * that we can use to apply to the request.\n *\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameterObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameterObject}\n */\nfunction digestParameters(parameters) {\n    return parameters.reduce(function (prev, param) {\n        var _a;\n        if ('$ref' in param || 'allOf' in param || 'anyOf' in param || 'oneOf' in param) {\n            throw new Error(\"The OpenAPI document for this operation wasn't dereferenced before processing.\");\n        }\n        else if (param.name in prev) {\n            throw new Error(\"The operation you are using has the same parameter, \".concat(param.name, \", spread across multiple entry points. We unfortunately can't handle this right now.\"));\n        }\n        return Object.assign(prev, (_a = {}, _a[param.name] = param, _a));\n    }, {});\n}\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\nfunction isEmpty(obj) {\n    return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;\n}\nfunction isObject(thing) {\n    if (thing instanceof stream_1[\"default\"].Readable) {\n        return false;\n    }\n    return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\nfunction isPrimitive(obj) {\n    return obj === null || typeof obj === 'number' || typeof obj === 'string';\n}\nfunction merge(src, target) {\n    if (Array.isArray(target)) {\n        // @todo we need to add support for merging array defaults with array body/metadata arguments\n        return target;\n    }\n    else if (!isObject(target)) {\n        return target;\n    }\n    return (0, merge_1[\"default\"])(src, target);\n}\n/**\n * Ingest a file path or readable stream into a common object that we can later use to process it\n * into a parameters object for making an API request.\n *\n */\nfunction processFile(paramName, file) {\n    var _this = this;\n    if (typeof file === 'string') {\n        // In order to support relative pathed files, we need to attempt to resolve them.\n        var resolvedFile_1 = path_1[\"default\"].resolve(file);\n        return new Promise(function (resolve, reject) {\n            fs_1[\"default\"].stat(resolvedFile_1, function (err) { return __awaiter(_this, void 0, void 0, function () {\n                var fileMetadata, payloadFilename;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (err) {\n                                if (err.code === 'ENOENT') {\n                                    // It's less than ideal for us to handle files that don't exist like this but because\n                                    // `file` is a string it might actually be the full text contents of the file and not\n                                    // actually a path.\n                                    //\n                                    // We also can't really regex to see if `file` *looks*` like a path because one should be\n                                    // able to pass in a relative `owlbert.png` (instead of `./owlbert.png`) and though that\n                                    // doesn't *look* like a path, it is one that should still work.\n                                    return [2 /*return*/, resolve(undefined)];\n                                }\n                                return [2 /*return*/, reject(err)];\n                            }\n                            return [4 /*yield*/, (0, sync_1[\"default\"])(resolvedFile_1)];\n                        case 1:\n                            fileMetadata = _a.sent();\n                            payloadFilename = encodeURIComponent(path_1[\"default\"].basename(resolvedFile_1));\n                            return [2 /*return*/, resolve({\n                                    paramName: paramName,\n                                    base64: fileMetadata.content.replace(';base64', \";name=\".concat(payloadFilename, \";base64\")),\n                                    filename: payloadFilename,\n                                    buffer: fileMetadata.buffer\n                                })];\n                    }\n                });\n            }); });\n        });\n    }\n    else if (file instanceof stream_1[\"default\"].Readable) {\n        return get_stream_1[\"default\"].buffer(file).then(function (buffer) {\n            var filePath = file.path;\n            var parser = new parser_1[\"default\"]();\n            var base64 = parser.format(filePath, buffer).content;\n            var payloadFilename = encodeURIComponent(path_1[\"default\"].basename(filePath));\n            return {\n                paramName: paramName,\n                base64: base64.replace(';base64', \";name=\".concat(payloadFilename, \";base64\")),\n                filename: payloadFilename,\n                buffer: buffer\n            };\n        });\n    }\n    return Promise.reject(new TypeError(paramName\n        ? \"The data supplied for the `\".concat(paramName, \"` request body parameter is not a file handler that we support.\")\n        : 'The data supplied for the request body payload is not a file handler that we support.'));\n}\n/**\n * With potentially supplied body and/or metadata we need to run through them against a given API\n * operation to see what's what and prepare any available parameters to be used in an API request\n * with `@readme/oas-to-har`.\n *\n */\nfunction prepareParams(operation, body, metadata) {\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function () {\n        var metadataIntersected, digestedParameters, jsonSchema, throwNoParamsError, bodyParams_1, jsonSchemaDefaults, params, headerParams_1, intersection, payloadJsonSchema, conversions_1;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    metadataIntersected = false;\n                    digestedParameters = digestParameters(operation.getParameters());\n                    jsonSchema = operation.getParametersAsJSONSchema();\n                    /**\n                     * It might be common for somebody to run `sdk.findPetsByStatus({ status: 'available' }, {})`, in\n                     * which case we want to filter out the second (metadata) parameter and treat the first parameter\n                     * as the metadata instead. If we don't do this, their supplied `status` metadata will be treated\n                     * as a body parameter, and because there's no `status` body parameter, and no supplied metadata\n                     * (because it's an empty object), the request won't send a payload.\n                     *\n                     * @see {@link https://github.com/readmeio/api/issues/449}\n                     */\n                    // eslint-disable-next-line no-param-reassign\n                    metadata = (0, remove_undefined_objects_1[\"default\"])(metadata);\n                    if (!jsonSchema && (body !== undefined || metadata !== undefined)) {\n                        throwNoParamsError = true;\n                        // If this operation doesn't have any parameters for us to transform to JSON Schema but they've\n                        // sent us either an `Accept` or `Authorization` header (or both) we should let them do that.\n                        // We should, however, only do this check for the `body` parameter as if they've sent this\n                        // request both `body` and `metadata` we can reject it outright as the operation won't have any\n                        // body data.\n                        if (body !== undefined) {\n                            if (typeof body === 'object' && body !== null && !Array.isArray(body)) {\n                                if (Object.keys(body).length <= 2) {\n                                    bodyParams_1 = (0, caseless_1[\"default\"])(body);\n                                    if (specialHeaders.some(function (header) { return bodyParams_1.has(header); })) {\n                                        throwNoParamsError = false;\n                                    }\n                                }\n                            }\n                        }\n                        if (throwNoParamsError) {\n                            throw new Error(\"You supplied metadata and/or body data for this operation but it doesn't have any documented parameters or request payloads. If you think this is an error please contact support for the API you're using.\");\n                        }\n                    }\n                    jsonSchemaDefaults = jsonSchema ? (0, getJSONSchemaDefaults_1[\"default\"])(jsonSchema) : {};\n                    params = jsonSchemaDefaults;\n                    // If a body argument was supplied we need to do a bit of work to see if it's actually a body\n                    // argument or metadata because the library lets you supply either a body, metadata, or body with\n                    // metadata.\n                    if (typeof body !== 'undefined') {\n                        if (Array.isArray(body) || isPrimitive(body)) {\n                            // If the body param is an array or a primitive then we know it's absolutely a body because\n                            // metadata can only ever be undefined or an object.\n                            params.body = merge(params.body, body);\n                        }\n                        else if (typeof metadata === 'undefined') {\n                            headerParams_1 = (0, caseless_1[\"default\"])({});\n                            Object.entries(digestedParameters).forEach(function (_a) {\n                                var paramName = _a[0], param = _a[1];\n                                // Headers are sent case-insensitive so we need to make sure that we're properly\n                                // matching them when detecting what our incoming payload looks like.\n                                if (param[\"in\"] === 'header') {\n                                    headerParams_1.set(paramName, '');\n                                }\n                            });\n                            // `Accept` and `Authorization` headers can't be defined as normal parameters but we should\n                            // always allow the user to supply them if they wish.\n                            specialHeaders.forEach(function (header) {\n                                if (!headerParams_1.has(header)) {\n                                    headerParams_1.set(header, '');\n                                }\n                            });\n                            intersection = Object.keys(body).filter(function (value) {\n                                if (Object.keys(digestedParameters).includes(value)) {\n                                    return true;\n                                }\n                                else if (headerParams_1.has(value)) {\n                                    return true;\n                                }\n                                return false;\n                            }).length;\n                            if (intersection && intersection / Object.keys(body).length > 0.25) {\n                                /* eslint-disable no-param-reassign */\n                                // If more than 25% of the body intersects with the parameters that we've got on hand,\n                                // then we should treat it as a metadata object and organize into parameters.\n                                metadataIntersected = true;\n                                metadata = merge(params.body, body);\n                                body = undefined;\n                                /* eslint-enable no-param-reassign */\n                            }\n                            else {\n                                // For all other cases, we should just treat the supplied body as a body.\n                                params.body = merge(params.body, body);\n                            }\n                        }\n                        else {\n                            // Body and metadata were both supplied.\n                            params.body = merge(params.body, body);\n                        }\n                    }\n                    if (!!operation.hasRequestBody()) return [3 /*break*/, 1];\n                    // If this operation doesn't have any documented request body then we shouldn't be sending\n                    // anything.\n                    delete params.body;\n                    return [3 /*break*/, 3];\n                case 1:\n                    if (!('body' in params))\n                        params.body = {};\n                    payloadJsonSchema = jsonSchema.find(function (js) { return js.type === 'body'; });\n                    if (!payloadJsonSchema) return [3 /*break*/, 3];\n                    if (!params.files)\n                        params.files = {};\n                    conversions_1 = [];\n                    // @todo add support for `type: array`, `oneOf` and `anyOf`\n                    if ((_a = payloadJsonSchema.schema) === null || _a === void 0 ? void 0 : _a.properties) {\n                        Object.entries((_b = payloadJsonSchema.schema) === null || _b === void 0 ? void 0 : _b.properties)\n                            .filter(function (_a) {\n                            var schema = _a[1];\n                            return (schema === null || schema === void 0 ? void 0 : schema.format) === 'binary';\n                        })\n                            .filter(function (_a) {\n                            var prop = _a[0];\n                            return Object.keys(params.body).includes(prop);\n                        })\n                            .forEach(function (_a) {\n                            var prop = _a[0];\n                            conversions_1.push(processFile(prop, params.body[prop]));\n                        });\n                    }\n                    else if (((_c = payloadJsonSchema.schema) === null || _c === void 0 ? void 0 : _c.type) === 'string') {\n                        if (((_d = payloadJsonSchema.schema) === null || _d === void 0 ? void 0 : _d.format) === 'binary') {\n                            conversions_1.push(processFile(undefined, params.body));\n                        }\n                    }\n                    return [4 /*yield*/, Promise.all(conversions_1)\n                            .then(function (fileMetadata) { return fileMetadata.filter(Boolean); })\n                            .then(function (fm) {\n                            fm.forEach(function (fileMetadata) {\n                                if (!fileMetadata) {\n                                    // If we don't have any metadata here it's because the file we have is likely\n                                    // the full string content of the file so since we don't have any filenames to\n                                    // work with we shouldn't do any additional handling to the `body` or `files`\n                                    // parameters.\n                                    return;\n                                }\n                                if (fileMetadata.paramName) {\n                                    params.body[fileMetadata.paramName] = fileMetadata.base64;\n                                }\n                                else {\n                                    params.body = fileMetadata.base64;\n                                }\n                                params.files[fileMetadata.filename] = fileMetadata.buffer;\n                            });\n                        })];\n                case 2:\n                    _e.sent();\n                    _e.label = 3;\n                case 3:\n                    // Form data should be placed within `formData` instead of `body` for it to properly get picked\n                    // up by `fetch-har`.\n                    if (operation.isFormUrlEncoded()) {\n                        params.formData = merge(params.formData, params.body);\n                        delete params.body;\n                    }\n                    // Only spend time trying to organize metadata into parameters if we were able to digest\n                    // parameters out of the operation schema. If we couldn't digest anything, but metadata was\n                    // supplied then we wouldn't know how to send it in the request!\n                    if (typeof metadata !== 'undefined') {\n                        if (!('cookie' in params))\n                            params.cookie = {};\n                        if (!('header' in params))\n                            params.header = {};\n                        if (!('path' in params))\n                            params.path = {};\n                        if (!('query' in params))\n                            params.query = {};\n                        Object.entries(digestedParameters).forEach(function (_a) {\n                            var paramName = _a[0], param = _a[1];\n                            var value;\n                            var metadataHeaderParam;\n                            if (typeof metadata === 'object' && !isEmpty(metadata)) {\n                                if (paramName in metadata) {\n                                    value = metadata[paramName];\n                                    metadataHeaderParam = paramName;\n                                }\n                                else if (param[\"in\"] === 'header') {\n                                    // Headers are sent case-insensitive so we need to make sure that we're properly\n                                    // matching them when detecting what our incoming payload looks like.\n                                    metadataHeaderParam = Object.keys(metadata).find(function (k) { return k.toLowerCase() === paramName.toLowerCase(); });\n                                    value = metadata[metadataHeaderParam];\n                                }\n                            }\n                            if (value === undefined) {\n                                return;\n                            }\n                            /* eslint-disable no-param-reassign */\n                            switch (param[\"in\"]) {\n                                case 'path':\n                                    params.path[paramName] = value;\n                                    delete metadata[paramName];\n                                    break;\n                                case 'query':\n                                    params.query[paramName] = value;\n                                    delete metadata[paramName];\n                                    break;\n                                case 'header':\n                                    params.header[paramName.toLowerCase()] = value;\n                                    delete metadata[metadataHeaderParam];\n                                    break;\n                                case 'cookie':\n                                    params.cookie[paramName] = value;\n                                    delete metadata[paramName];\n                                    break;\n                                default: // no-op\n                            }\n                            /* eslint-enable no-param-reassign */\n                            // Because a user might have sent just a metadata object, we want to make sure that we filter\n                            // out anything that they sent that is a parameter from also being sent as part of a form\n                            // data payload for `x-www-form-urlencoded` requests.\n                            if (metadataIntersected && operation.isFormUrlEncoded()) {\n                                if (paramName in params.formData) {\n                                    delete params.formData[paramName];\n                                }\n                            }\n                        });\n                        // If there's any leftover metadata that hasn't been moved into form data for this request we\n                        // need to move it or else it'll get tossed.\n                        if (!isEmpty(metadata)) {\n                            if (typeof metadata === 'object') {\n                                // If the user supplied an `accept` or `authorization` header themselves we should allow it\n                                // through. Normally these headers are automatically handled by `@readme/oas-to-har` but in\n                                // the event that maybe the user wants to return XML for an API that normally returns JSON\n                                // or specify a custom auth header (maybe we can't handle their auth case right) this is the\n                                // only way with this library that they can do that.\n                                specialHeaders.forEach(function (headerName) {\n                                    var headerParam = Object.keys(metadata).find(function (m) { return m.toLowerCase() === headerName; });\n                                    if (headerParam) {\n                                        params.header[headerName] = metadata[headerParam];\n                                        // eslint-disable-next-line no-param-reassign\n                                        delete metadata[headerParam];\n                                    }\n                                });\n                            }\n                            if (operation.isFormUrlEncoded()) {\n                                params.formData = merge(params.formData, metadata);\n                            }\n                            else {\n                                // Any other remaining unused metadata will be unused because we don't know where to place\n                                // it in the request.\n                            }\n                        }\n                    }\n                    ['body', 'cookie', 'files', 'formData', 'header', 'path', 'query'].forEach(function (type) {\n                        if (type in params && isEmpty(params[type])) {\n                            delete params[type];\n                        }\n                    });\n                    return [2 /*return*/, params];\n            }\n        });\n    });\n}\nexports[\"default\"] = prepareParams;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}