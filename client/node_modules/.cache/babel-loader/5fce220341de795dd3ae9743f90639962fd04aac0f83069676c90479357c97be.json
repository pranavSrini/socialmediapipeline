{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nexports.__esModule = true;\nvar data_urls_1 = require(\"@readme/data-urls\");\nvar extensions = __importStar(require(\"@readme/oas-extensions\"));\nvar oas_1 = require(\"oas\");\nvar rmoas_types_1 = require(\"oas/dist/rmoas.types\");\nvar remove_undefined_objects_1 = __importDefault(require(\"remove-undefined-objects\"));\nvar configure_security_1 = __importDefault(require(\"./lib/configure-security\"));\nvar style_formatting_1 = __importDefault(require(\"./lib/style-formatting\"));\nvar jsonSchemaTypes = oas_1.utils.jsonSchemaTypes,\n  matchesMimeType = oas_1.utils.matchesMimeType;\nfunction formatter(values, param, type, onlyIfExists) {\n  if (onlyIfExists === void 0) {\n    onlyIfExists = false;\n  }\n  if (param.style) {\n    var value_1 = values[type][param.name];\n    // Note: Technically we could send everything through the format style and choose the proper\n    // default for each `in` type (e.g. query defaults to form).\n    return (0, style_formatting_1[\"default\"])(value_1, param);\n  }\n  var value;\n  // Handle missing values\n  if (typeof values[type][param.name] !== 'undefined') {\n    value = values[type][param.name];\n  } else if (onlyIfExists && !param.required) {\n    value = undefined;\n  } else if (param.required && param.schema && !(0, rmoas_types_1.isRef)(param.schema) && param.schema[\"default\"]) {\n    value = param.schema[\"default\"];\n  } else if (type === 'path') {\n    // If we don't have any values for the path parameter, just use the name of the parameter as the\n    // value so we don't try try to build a URL to something like `https://example.com/undefined`.\n    return param.name;\n  }\n  // Handle file uploads. Specifically arrays of file uploads which need to be formatted very\n  // specifically.\n  if (param.schema && !(0, rmoas_types_1.isRef)(param.schema) && param.schema.type === 'array' && param.schema.items && !(0, rmoas_types_1.isRef)(param.schema.items) && param.schema.items.format === 'binary') {\n    if (Array.isArray(value)) {\n      // If this is array of binary data then we shouldn't do anything because we'll prepare them\n      // separately in the HAR in order to preserve `fileName` and `contentType` data within\n      // `postData.params`. If we don't then the HAR we generate for this data will be invalid.\n      return value;\n    }\n    return JSON.stringify(value);\n  }\n  if (value !== undefined) {\n    // Query params should always be formatted, even if they don't have a `style` serialization\n    // configured.\n    if (type === 'query') {\n      return (0, style_formatting_1[\"default\"])(value, param);\n    }\n    return value;\n  }\n  return undefined;\n}\nfunction multipartBodyToFormatterParams(multipartBody, oasMediaTypeObject) {\n  var schema = oasMediaTypeObject.schema;\n  var encoding = oasMediaTypeObject.encoding;\n  if (typeof multipartBody === 'object' && multipartBody !== null) {\n    return Object.keys(multipartBody).map(function (key) {\n      // If we have an incoming parameter, but it's not in the schema ignore it.\n      if (!schema.properties[key]) {\n        return false;\n      }\n      var paramEncoding = encoding ? encoding[key] : undefined;\n      return {\n        name: key,\n        // If the style isn't defined, use the default\n        style: paramEncoding ? paramEncoding.style : undefined,\n        // If explode isn't defined, use the default\n        explode: paramEncoding ? paramEncoding.explode : undefined,\n        required: schema.required && typeof schema.required === 'boolean' && Boolean(schema.required) || Array.isArray(schema.required) && schema.required.includes(key),\n        schema: schema.properties[key],\n        \"in\": 'body'\n      };\n    }).filter(Boolean);\n  }\n  // Pretty sure that we'll never have anything but an object for multipart bodies, so returning\n  // empty array if we get anything else.\n  return [];\n}\nvar defaultFormDataTypes = Object.keys(jsonSchemaTypes).reduce(function (prev, curr) {\n  var _a;\n  return Object.assign(prev, (_a = {}, _a[curr] = {}, _a));\n}, {});\nfunction getResponseContentType(content) {\n  var types = Object.keys(content) || [];\n  // If this response content has multiple types available we should always prefer the one that's\n  // JSON-compatible. If they don't have one that is we'll return the first available, otherwise\n  // if they don't have **any** repsonse content types present we'll assume it's JSON.\n  if (types && types.length) {\n    var jsonType = types.find(function (t) {\n      return matchesMimeType.json(t);\n    });\n    if (jsonType) {\n      return jsonType;\n    }\n    return types[0];\n  }\n  return 'application/json';\n}\nfunction isPrimitive(val) {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\nfunction stringify(json) {\n  return JSON.stringify((0, remove_undefined_objects_1[\"default\"])(typeof json.RAW_BODY !== 'undefined' ? json.RAW_BODY : json));\n}\nfunction stringifyParameter(param) {\n  if (param === null || isPrimitive(param)) {\n    return param;\n  } else if (Array.isArray(param) && param.every(isPrimitive)) {\n    return String(param);\n  }\n  return JSON.stringify(param);\n}\nfunction appendHarValue(harParam, name, value, addtlData) {\n  if (addtlData === void 0) {\n    addtlData = {};\n  }\n  if (typeof value === 'undefined') return;\n  if (Array.isArray(value)) {\n    // If the formatter gives us an array, we're expected to add each array value as a new\n    // parameter item with the same parameter name\n    value.forEach(function (singleValue) {\n      appendHarValue(harParam, name, singleValue);\n    });\n  } else if (typeof value === 'object' && value !== null) {\n    // If the formatter gives us an object, we're expected to add each property value as a new\n    // parameter item, each with the name of the property\n    Object.keys(value).forEach(function (key) {\n      appendHarValue(harParam, key, value[key]);\n    });\n  } else {\n    // If the formatter gives us a non-array, non-object, we add it as is\n    harParam.push(__assign(__assign({}, addtlData), {\n      name: name,\n      value: String(value)\n    }));\n  }\n}\nfunction encodeBodyForHAR(body) {\n  if (isPrimitive(body)) {\n    return body;\n  } else if (typeof body === 'object' && body !== null && !Array.isArray(body) && typeof body.RAW_BODY !== 'undefined') {\n    // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload as a\n    // raw string. https://docs.readme.com/docs/raw-body-content\n    if (isPrimitive(body.RAW_BODY)) {\n      return body.RAW_BODY;\n    }\n    return stringify(body.RAW_BODY);\n  }\n  return stringify(body);\n}\nfunction oasToHar(oas, operationSchema, values, auth, opts) {\n  var _a;\n  if (values === void 0) {\n    values = {};\n  }\n  if (auth === void 0) {\n    auth = {};\n  }\n  if (opts === void 0) {\n    opts = {\n      // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in\n      // order to funnel requests through our CORS-friendly proxy.\n      proxyUrl: false\n    };\n  }\n  var operation;\n  if (!operationSchema || typeof operationSchema.getParameters !== 'function') {\n    /**\n     * If `operationSchema` was supplied as a plain object instead of an instance of `Operation`\n     * then we should create a new instance of it. We're doing it with a check on `getParameters`\n     * instead of checking `instanceof Operation` because JS is very weird when it comes to\n     * checking `instanceof` against classes. One instance of `Operation` may not always match up\n     * with another if they're being loaded between two different libraries.\n     *\n     * It's weird. This is easier.\n     */\n    operation = new oas_1.Operation(oas, (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.path) || '', (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.method) || '', operationSchema || {\n      path: '',\n      method: ''\n    });\n  } else {\n    operation = operationSchema;\n  }\n  var apiDefinition = oas.getDefinition();\n  var formData = __assign(__assign(__assign({}, defaultFormDataTypes), {\n    server: {\n      selected: 0,\n      variables: oas.defaultVariables(0)\n    }\n  }), values);\n  // If the incoming `server.variables` is missing variables let's pad it out with defaults.\n  formData.server.variables = __assign(__assign({}, oas.defaultVariables(formData.server.selected)), formData.server.variables ? formData.server.variables : {});\n  var har = {\n    cookies: [],\n    headers: [],\n    headersSize: 0,\n    queryString: [],\n    // @ts-expect-error This is fine because we're fleshing `postData` out further down.\n    postData: {},\n    bodySize: 0,\n    method: operation.method.toUpperCase(),\n    url: \"\".concat(oas.url(formData.server.selected, formData.server.variables)).concat(operation.path).replace(/\\s/g, '%20'),\n    httpVersion: 'HTTP/1.1'\n  };\n  if (opts.proxyUrl) {\n    if (extensions.getExtension(extensions.PROXY_ENABLED, oas, operation)) {\n      har.url = \"https://try.readme.io/\".concat(har.url);\n    }\n  }\n  var parameters = operation.getParameters();\n  har.url = har.url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, function (full, key) {\n    if (!operation || !parameters) return key; // No path params at all\n    // Find the path parameter or set a default value if it does not exist\n    var parameter = parameters.find(function (param) {\n      return param.name === key;\n    }) || {\n      name: key\n    };\n    // The library that handles our style processing already encodes uri elements. For everything\n    // else we need to handle it here.\n    if (!('style' in parameter) || !parameter.style) {\n      return encodeURIComponent(formatter(formData, parameter, 'path'));\n    }\n    return formatter(formData, parameter, 'path');\n  });\n  var queryStrings = parameters && parameters.filter(function (param) {\n    return param[\"in\"] === 'query';\n  });\n  if (queryStrings && queryStrings.length) {\n    queryStrings.forEach(function (queryString) {\n      var value = formatter(formData, queryString, 'query', true);\n      appendHarValue(har.queryString, queryString.name, value);\n    });\n  }\n  // Do we have any `cookie` parameters on the operation?\n  var cookies = parameters && parameters.filter(function (param) {\n    return param[\"in\"] === 'cookie';\n  });\n  if (cookies && cookies.length) {\n    cookies.forEach(function (cookie) {\n      var value = formatter(formData, cookie, 'cookie', true);\n      appendHarValue(har.cookies, cookie.name, value);\n    });\n  }\n  // Does this response have any documented content types?\n  if (operation.schema.responses) {\n    Object.keys(operation.schema.responses).some(function (response) {\n      if ((0, rmoas_types_1.isRef)(operation.schema.responses[response])) return false;\n      var content = operation.schema.responses[response].content;\n      if (!content) return false;\n      // If there's no `accept` header present we should add one so their eventual code snippet\n      // follows best practices.\n      if (Object.keys(formData.header).find(function (h) {\n        return h.toLowerCase() === 'accept';\n      })) return true;\n      har.headers.push({\n        name: 'accept',\n        value: getResponseContentType(content)\n      });\n      return true;\n    });\n  }\n  // Do we have any `header` parameters on the operation?\n  var hasContentType = false;\n  var contentType = operation.getContentType();\n  var headers = parameters && parameters.filter(function (param) {\n    return param[\"in\"] === 'header';\n  });\n  if (headers && headers.length) {\n    headers.forEach(function (header) {\n      var value = formatter(formData, header, 'header', true);\n      if (typeof value === 'undefined') return;\n      if (header.name.toLowerCase() === 'content-type') {\n        hasContentType = true;\n        contentType = String(value);\n      }\n      appendHarValue(har.headers, header.name, value);\n    });\n  }\n  // Are there `x-headers` static headers configured for this OAS?\n  var userDefinedHeaders = extensions.getExtension(extensions.HEADERS, oas, operation);\n  if (userDefinedHeaders) {\n    userDefinedHeaders.forEach(function (header) {\n      if (typeof header.key === 'string' && header.key.toLowerCase() === 'content-type') {\n        hasContentType = true;\n        contentType = String(header.value);\n      }\n      har.headers.push({\n        name: String(header.key),\n        value: String(header.value)\n      });\n    });\n  }\n  if (formData.header) {\n    // Do we have an `accept` header set up in the form data, but it hasn't been added yet?\n    var acceptHeader = Object.keys(formData.header).find(function (h) {\n      return h.toLowerCase() === 'accept';\n    });\n    if (acceptHeader && !har.headers.find(function (hdr) {\n      return hdr.name.toLowerCase() === 'accept';\n    })) {\n      har.headers.push({\n        name: 'accept',\n        value: String(formData.header[acceptHeader])\n      });\n    }\n    // Do we have a manually-defined `authorization` header set up in the form data?\n    var authorizationHeader = Object.keys(formData.header).find(function (h) {\n      return h.toLowerCase() === 'authorization';\n    });\n    if (authorizationHeader && !har.headers.find(function (hdr) {\n      return hdr.name.toLowerCase() === 'authorization';\n    })) {\n      har.headers.push({\n        name: 'authorization',\n        value: String(formData.header[authorizationHeader])\n      });\n    }\n  }\n  var requestBody;\n  if (operation.hasRequestBody()) {\n    // @ts-expect-error TODO `requestBody` coming back as `false | MediaTypeObject | [string, MediaTypeObject]` seems like a problem\n    _a = __read(operation.getRequestBody(), 2), requestBody = _a[1];\n  }\n  if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {\n    var requestBodySchema_1 = requestBody.schema;\n    if (operation.isFormUrlEncoded()) {\n      if (Object.keys(formData.formData).length) {\n        var cleanFormData_1 = (0, remove_undefined_objects_1[\"default\"])(JSON.parse(JSON.stringify(formData.formData)));\n        if (cleanFormData_1 !== undefined) {\n          har.postData.params = [];\n          har.postData.mimeType = 'application/x-www-form-urlencoded';\n          Object.keys(cleanFormData_1).forEach(function (name) {\n            har.postData.params.push({\n              name: name,\n              value: stringifyParameter(cleanFormData_1[name])\n            });\n          });\n        }\n      }\n    } else if ('body' in formData && formData.body !== undefined && (isPrimitive(formData.body) || Object.keys(formData.body).length)) {\n      var isMultipart = operation.isMultipart();\n      var isJSON = operation.isJson();\n      if (isMultipart || isJSON) {\n        try {\n          var cleanBody_1 = (0, remove_undefined_objects_1[\"default\"])(JSON.parse(JSON.stringify(formData.body)));\n          if (isMultipart) {\n            har.postData.mimeType = 'multipart/form-data';\n            har.postData.params = [];\n            /**\n             * Discover all `{ type: string, format: binary }` properties, or arrays containing the\n             * same, within the request body. If there are any, then that means that we're dealing\n             * with a `multipart/form-data` request and need to treat the payload as\n             * `postData.params` and supply filenames and content types for the files (if they're\n             * available).\n             *\n             * @example `{ type: string, format: binary }`\n             * @example `{ type: array, items: { type: string, format: binary } }`\n             */\n            var binaryTypes_1 = Object.keys(requestBodySchema_1.properties).filter(function (key) {\n              var propData = requestBodySchema_1.properties[key];\n              if (propData.format === 'binary') {\n                return true;\n              } else if (propData.type === 'array' && propData.items && typeof propData.items === 'object' && propData.items !== null && propData.items.format === 'binary') {\n                return true;\n              }\n              return false;\n            });\n            if (cleanBody_1 !== undefined) {\n              var multipartParams_1 = multipartBodyToFormatterParams(formData.body, operation.schema.requestBody.content['multipart/form-data']);\n              Object.keys(cleanBody_1).forEach(function (name) {\n                var param = multipartParams_1.find(function (multipartParam) {\n                  return multipartParam.name === name;\n                });\n                // If we're dealing with a binary type, and the value is a valid data URL we should\n                // parse out any available filename and content type to send along with the\n                // parameter to interpreters like `fetch-har` can make sense of it and send a usable\n                // payload.\n                var addtlData = {};\n                var value = formatter(formData, param, 'body', true);\n                if (!Array.isArray(value)) {\n                  value = [value];\n                }\n                value.forEach(function (val) {\n                  if (binaryTypes_1.includes(name)) {\n                    var parsed = (0, data_urls_1.parse)(val);\n                    if (parsed) {\n                      addtlData.fileName = 'name' in parsed ? parsed.name : 'unknown';\n                      if ('contentType' in parsed) {\n                        addtlData.contentType = parsed.contentType;\n                      }\n                    }\n                  }\n                  appendHarValue(har.postData.params, name, val, addtlData);\n                });\n              });\n            }\n          } else {\n            har.postData.mimeType = contentType;\n            /**\n             * Handle arbitrary JSON input via a string.\n             *\n             * In OAS you usually find this in an `application/json` content type with a schema\n             * `type=string, format=json`. In the UI this is represented by an arbitrary text input.\n             *\n             * This ensures we remove any newlines or tabs and use a clean JSON block in the\n             * example.\n             */\n            if (requestBody.schema.type === 'string') {\n              har.postData.text = JSON.stringify(JSON.parse(cleanBody_1));\n            } else {\n              /**\n               * Handle formatted JSON objects that have properties that accept arbitrary JSON.\n               *\n               * Find all `{ type: string, format: json }` properties in the schema because we need\n               * to manually `JSON.parse` them before submit, otherwise they'll be escaped instead\n               * of actual objects. We also only want values that the user has entered, so we drop\n               * any `undefined` `cleanBody` keys.\n               */\n              var jsonTypes = Object.keys(requestBodySchema_1.properties).filter(function (key) {\n                var propData = requestBodySchema_1.properties[key];\n                return propData.format === 'json' && cleanBody_1[key] !== undefined;\n              });\n              if (jsonTypes.length) {\n                try {\n                  jsonTypes.forEach(function (prop) {\n                    try {\n                      cleanBody_1[prop] = JSON.parse(cleanBody_1[prop]);\n                    } catch (e) {\n                      // leave the prop as a string value\n                    }\n                  });\n                  // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload\n                  // as a raw string. https://docs.readme.com/docs/raw-body-content\n                  if (typeof cleanBody_1.RAW_BODY !== 'undefined') {\n                    cleanBody_1 = cleanBody_1.RAW_BODY;\n                  }\n                  har.postData.text = JSON.stringify(cleanBody_1);\n                } catch (e) {\n                  har.postData.text = stringify(formData.body);\n                }\n              } else {\n                har.postData.text = encodeBodyForHAR(formData.body);\n              }\n            }\n          }\n        } catch (e) {\n          // If anything above fails for whatever reason, assume that whatever we had is invalid\n          // JSON and just treat it as raw text.\n          har.postData.text = stringify(formData.body);\n        }\n      } else {\n        har.postData.mimeType = contentType;\n        har.postData.text = encodeBodyForHAR(formData.body);\n      }\n    }\n  }\n  // Add a `content-type` header if there are any body values setup above or if there is a schema\n  // defined, but only do so if we don't already have a `content-type` present as it's impossible\n  // for a request to have multiple.\n  if ((har.postData.text || requestBody && requestBody.schema && Object.keys(requestBody.schema).length) && !hasContentType) {\n    har.headers.push({\n      name: 'content-type',\n      value: contentType\n    });\n  }\n  var securityRequirements = operation.getSecurity();\n  if (securityRequirements && securityRequirements.length) {\n    // TODO pass these values through the formatter?\n    securityRequirements.forEach(function (schemes) {\n      Object.keys(schemes).forEach(function (security) {\n        var securityValue = (0, configure_security_1[\"default\"])(apiDefinition, auth, security);\n        if (!securityValue) {\n          return;\n        }\n        // If this is an `authorization` header and we've already added one (maybe one was manually\n        // specified), then we shouldn't add another.\n        if (securityValue.value.name === 'authorization') {\n          if (har[securityValue.type].find(function (v) {\n            return v.name === securityValue.value.name;\n          })) {\n            return;\n          }\n        }\n        // If we've already added this **specific** security value then don't add it again.\n        if (har[securityValue.type].find(function (v) {\n          return v.name === securityValue.value.name && v.value === securityValue.value.value;\n        })) {\n          return;\n        }\n        har[securityValue.type].push(securityValue.value);\n      });\n    });\n  }\n  // If we didn't end up filling the `postData` object then we don't need it.\n  if (Object.keys(har.postData).length === 0) {\n    delete har.postData;\n  }\n  return {\n    log: {\n      entries: [{\n        request: har\n      }]\n    }\n  };\n}\nexports[\"default\"] = oasToHar;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","__read","Symbol","iterator","r","ar","e","next","done","push","error","__importDefault","exports","data_urls_1","require","extensions","oas_1","rmoas_types_1","remove_undefined_objects_1","configure_security_1","style_formatting_1","jsonSchemaTypes","utils","matchesMimeType","formatter","values","param","type","onlyIfExists","style","value_1","name","required","schema","isRef","items","format","Array","isArray","JSON","stringify","multipartBodyToFormatterParams","multipartBody","oasMediaTypeObject","encoding","keys","map","key","properties","paramEncoding","explode","Boolean","includes","filter","defaultFormDataTypes","reduce","prev","curr","_a","getResponseContentType","content","types","jsonType","find","json","isPrimitive","val","RAW_BODY","stringifyParameter","every","String","appendHarValue","harParam","addtlData","forEach","singleValue","encodeBodyForHAR","body","oasToHar","oas","operationSchema","auth","opts","proxyUrl","operation","getParameters","Operation","path","method","apiDefinition","getDefinition","formData","server","selected","variables","defaultVariables","har","cookies","headers","headersSize","queryString","postData","bodySize","toUpperCase","url","concat","replace","httpVersion","getExtension","PROXY_ENABLED","parameters","full","parameter","encodeURIComponent","queryStrings","cookie","responses","some","response","header","h","toLowerCase","hasContentType","contentType","getContentType","userDefinedHeaders","HEADERS","acceptHeader","hdr","authorizationHeader","requestBody","hasRequestBody","getRequestBody","requestBodySchema_1","isFormUrlEncoded","cleanFormData_1","parse","params","mimeType","isMultipart","isJSON","isJson","cleanBody_1","binaryTypes_1","propData","multipartParams_1","multipartParam","parsed","fileName","text","jsonTypes","prop","securityRequirements","getSecurity","schemes","security","securityValue","log","entries","request"],"sources":["/Users/pranavsrinivasan/Documents/VSCode/aividgen/server/.api/apis/aivideoapi/node_modules/@readme/oas-to-har/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nexports.__esModule = true;\nvar data_urls_1 = require(\"@readme/data-urls\");\nvar extensions = __importStar(require(\"@readme/oas-extensions\"));\nvar oas_1 = require(\"oas\");\nvar rmoas_types_1 = require(\"oas/dist/rmoas.types\");\nvar remove_undefined_objects_1 = __importDefault(require(\"remove-undefined-objects\"));\nvar configure_security_1 = __importDefault(require(\"./lib/configure-security\"));\nvar style_formatting_1 = __importDefault(require(\"./lib/style-formatting\"));\nvar jsonSchemaTypes = oas_1.utils.jsonSchemaTypes, matchesMimeType = oas_1.utils.matchesMimeType;\nfunction formatter(values, param, type, onlyIfExists) {\n    if (onlyIfExists === void 0) { onlyIfExists = false; }\n    if (param.style) {\n        var value_1 = values[type][param.name];\n        // Note: Technically we could send everything through the format style and choose the proper\n        // default for each `in` type (e.g. query defaults to form).\n        return (0, style_formatting_1[\"default\"])(value_1, param);\n    }\n    var value;\n    // Handle missing values\n    if (typeof values[type][param.name] !== 'undefined') {\n        value = values[type][param.name];\n    }\n    else if (onlyIfExists && !param.required) {\n        value = undefined;\n    }\n    else if (param.required && param.schema && !(0, rmoas_types_1.isRef)(param.schema) && param.schema[\"default\"]) {\n        value = param.schema[\"default\"];\n    }\n    else if (type === 'path') {\n        // If we don't have any values for the path parameter, just use the name of the parameter as the\n        // value so we don't try try to build a URL to something like `https://example.com/undefined`.\n        return param.name;\n    }\n    // Handle file uploads. Specifically arrays of file uploads which need to be formatted very\n    // specifically.\n    if (param.schema &&\n        !(0, rmoas_types_1.isRef)(param.schema) &&\n        param.schema.type === 'array' &&\n        param.schema.items &&\n        !(0, rmoas_types_1.isRef)(param.schema.items) &&\n        param.schema.items.format === 'binary') {\n        if (Array.isArray(value)) {\n            // If this is array of binary data then we shouldn't do anything because we'll prepare them\n            // separately in the HAR in order to preserve `fileName` and `contentType` data within\n            // `postData.params`. If we don't then the HAR we generate for this data will be invalid.\n            return value;\n        }\n        return JSON.stringify(value);\n    }\n    if (value !== undefined) {\n        // Query params should always be formatted, even if they don't have a `style` serialization\n        // configured.\n        if (type === 'query') {\n            return (0, style_formatting_1[\"default\"])(value, param);\n        }\n        return value;\n    }\n    return undefined;\n}\nfunction multipartBodyToFormatterParams(multipartBody, oasMediaTypeObject) {\n    var schema = oasMediaTypeObject.schema;\n    var encoding = oasMediaTypeObject.encoding;\n    if (typeof multipartBody === 'object' && multipartBody !== null) {\n        return Object.keys(multipartBody)\n            .map(function (key) {\n            // If we have an incoming parameter, but it's not in the schema ignore it.\n            if (!schema.properties[key]) {\n                return false;\n            }\n            var paramEncoding = encoding ? encoding[key] : undefined;\n            return {\n                name: key,\n                // If the style isn't defined, use the default\n                style: paramEncoding ? paramEncoding.style : undefined,\n                // If explode isn't defined, use the default\n                explode: paramEncoding ? paramEncoding.explode : undefined,\n                required: (schema.required && typeof schema.required === 'boolean' && Boolean(schema.required)) ||\n                    (Array.isArray(schema.required) && schema.required.includes(key)),\n                schema: schema.properties[key],\n                \"in\": 'body'\n            };\n        })\n            .filter(Boolean);\n    }\n    // Pretty sure that we'll never have anything but an object for multipart bodies, so returning\n    // empty array if we get anything else.\n    return [];\n}\nvar defaultFormDataTypes = Object.keys(jsonSchemaTypes).reduce(function (prev, curr) {\n    var _a;\n    return Object.assign(prev, (_a = {}, _a[curr] = {}, _a));\n}, {});\nfunction getResponseContentType(content) {\n    var types = Object.keys(content) || [];\n    // If this response content has multiple types available we should always prefer the one that's\n    // JSON-compatible. If they don't have one that is we'll return the first available, otherwise\n    // if they don't have **any** repsonse content types present we'll assume it's JSON.\n    if (types && types.length) {\n        var jsonType = types.find(function (t) { return matchesMimeType.json(t); });\n        if (jsonType) {\n            return jsonType;\n        }\n        return types[0];\n    }\n    return 'application/json';\n}\nfunction isPrimitive(val) {\n    return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\nfunction stringify(json) {\n    return JSON.stringify((0, remove_undefined_objects_1[\"default\"])(typeof json.RAW_BODY !== 'undefined' ? json.RAW_BODY : json));\n}\nfunction stringifyParameter(param) {\n    if (param === null || isPrimitive(param)) {\n        return param;\n    }\n    else if (Array.isArray(param) && param.every(isPrimitive)) {\n        return String(param);\n    }\n    return JSON.stringify(param);\n}\nfunction appendHarValue(harParam, name, value, addtlData) {\n    if (addtlData === void 0) { addtlData = {}; }\n    if (typeof value === 'undefined')\n        return;\n    if (Array.isArray(value)) {\n        // If the formatter gives us an array, we're expected to add each array value as a new\n        // parameter item with the same parameter name\n        value.forEach(function (singleValue) {\n            appendHarValue(harParam, name, singleValue);\n        });\n    }\n    else if (typeof value === 'object' && value !== null) {\n        // If the formatter gives us an object, we're expected to add each property value as a new\n        // parameter item, each with the name of the property\n        Object.keys(value).forEach(function (key) {\n            appendHarValue(harParam, key, value[key]);\n        });\n    }\n    else {\n        // If the formatter gives us a non-array, non-object, we add it as is\n        harParam.push(__assign(__assign({}, addtlData), { name: name, value: String(value) }));\n    }\n}\nfunction encodeBodyForHAR(body) {\n    if (isPrimitive(body)) {\n        return body;\n    }\n    else if (typeof body === 'object' &&\n        body !== null &&\n        !Array.isArray(body) &&\n        typeof body.RAW_BODY !== 'undefined') {\n        // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload as a\n        // raw string. https://docs.readme.com/docs/raw-body-content\n        if (isPrimitive(body.RAW_BODY)) {\n            return body.RAW_BODY;\n        }\n        return stringify(body.RAW_BODY);\n    }\n    return stringify(body);\n}\nfunction oasToHar(oas, operationSchema, values, auth, opts) {\n    var _a;\n    if (values === void 0) { values = {}; }\n    if (auth === void 0) { auth = {}; }\n    if (opts === void 0) { opts = {\n        // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in\n        // order to funnel requests through our CORS-friendly proxy.\n        proxyUrl: false\n    }; }\n    var operation;\n    if (!operationSchema || typeof operationSchema.getParameters !== 'function') {\n        /**\n         * If `operationSchema` was supplied as a plain object instead of an instance of `Operation`\n         * then we should create a new instance of it. We're doing it with a check on `getParameters`\n         * instead of checking `instanceof Operation` because JS is very weird when it comes to\n         * checking `instanceof` against classes. One instance of `Operation` may not always match up\n         * with another if they're being loaded between two different libraries.\n         *\n         * It's weird. This is easier.\n         */\n        operation = new oas_1.Operation(oas, (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.path) || '', (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.method) || '', operationSchema || { path: '', method: '' });\n    }\n    else {\n        operation = operationSchema;\n    }\n    var apiDefinition = oas.getDefinition();\n    var formData = __assign(__assign(__assign({}, defaultFormDataTypes), { server: {\n            selected: 0,\n            variables: oas.defaultVariables(0)\n        } }), values);\n    // If the incoming `server.variables` is missing variables let's pad it out with defaults.\n    formData.server.variables = __assign(__assign({}, oas.defaultVariables(formData.server.selected)), (formData.server.variables ? formData.server.variables : {}));\n    var har = {\n        cookies: [],\n        headers: [],\n        headersSize: 0,\n        queryString: [],\n        // @ts-expect-error This is fine because we're fleshing `postData` out further down.\n        postData: {},\n        bodySize: 0,\n        method: operation.method.toUpperCase(),\n        url: \"\".concat(oas.url(formData.server.selected, formData.server.variables)).concat(operation.path).replace(/\\s/g, '%20'),\n        httpVersion: 'HTTP/1.1'\n    };\n    if (opts.proxyUrl) {\n        if (extensions.getExtension(extensions.PROXY_ENABLED, oas, operation)) {\n            har.url = \"https://try.readme.io/\".concat(har.url);\n        }\n    }\n    var parameters = operation.getParameters();\n    har.url = har.url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, function (full, key) {\n        if (!operation || !parameters)\n            return key; // No path params at all\n        // Find the path parameter or set a default value if it does not exist\n        var parameter = parameters.find(function (param) { return param.name === key; }) || { name: key };\n        // The library that handles our style processing already encodes uri elements. For everything\n        // else we need to handle it here.\n        if (!('style' in parameter) || !parameter.style) {\n            return encodeURIComponent(formatter(formData, parameter, 'path'));\n        }\n        return formatter(formData, parameter, 'path');\n    });\n    var queryStrings = parameters && parameters.filter(function (param) { return param[\"in\"] === 'query'; });\n    if (queryStrings && queryStrings.length) {\n        queryStrings.forEach(function (queryString) {\n            var value = formatter(formData, queryString, 'query', true);\n            appendHarValue(har.queryString, queryString.name, value);\n        });\n    }\n    // Do we have any `cookie` parameters on the operation?\n    var cookies = parameters && parameters.filter(function (param) { return param[\"in\"] === 'cookie'; });\n    if (cookies && cookies.length) {\n        cookies.forEach(function (cookie) {\n            var value = formatter(formData, cookie, 'cookie', true);\n            appendHarValue(har.cookies, cookie.name, value);\n        });\n    }\n    // Does this response have any documented content types?\n    if (operation.schema.responses) {\n        Object.keys(operation.schema.responses).some(function (response) {\n            if ((0, rmoas_types_1.isRef)(operation.schema.responses[response]))\n                return false;\n            var content = operation.schema.responses[response].content;\n            if (!content)\n                return false;\n            // If there's no `accept` header present we should add one so their eventual code snippet\n            // follows best practices.\n            if (Object.keys(formData.header).find(function (h) { return h.toLowerCase() === 'accept'; }))\n                return true;\n            har.headers.push({\n                name: 'accept',\n                value: getResponseContentType(content)\n            });\n            return true;\n        });\n    }\n    // Do we have any `header` parameters on the operation?\n    var hasContentType = false;\n    var contentType = operation.getContentType();\n    var headers = parameters && parameters.filter(function (param) { return param[\"in\"] === 'header'; });\n    if (headers && headers.length) {\n        headers.forEach(function (header) {\n            var value = formatter(formData, header, 'header', true);\n            if (typeof value === 'undefined')\n                return;\n            if (header.name.toLowerCase() === 'content-type') {\n                hasContentType = true;\n                contentType = String(value);\n            }\n            appendHarValue(har.headers, header.name, value);\n        });\n    }\n    // Are there `x-headers` static headers configured for this OAS?\n    var userDefinedHeaders = extensions.getExtension(extensions.HEADERS, oas, operation);\n    if (userDefinedHeaders) {\n        userDefinedHeaders.forEach(function (header) {\n            if (typeof header.key === 'string' && header.key.toLowerCase() === 'content-type') {\n                hasContentType = true;\n                contentType = String(header.value);\n            }\n            har.headers.push({\n                name: String(header.key),\n                value: String(header.value)\n            });\n        });\n    }\n    if (formData.header) {\n        // Do we have an `accept` header set up in the form data, but it hasn't been added yet?\n        var acceptHeader = Object.keys(formData.header).find(function (h) { return h.toLowerCase() === 'accept'; });\n        if (acceptHeader && !har.headers.find(function (hdr) { return hdr.name.toLowerCase() === 'accept'; })) {\n            har.headers.push({\n                name: 'accept',\n                value: String(formData.header[acceptHeader])\n            });\n        }\n        // Do we have a manually-defined `authorization` header set up in the form data?\n        var authorizationHeader = Object.keys(formData.header).find(function (h) { return h.toLowerCase() === 'authorization'; });\n        if (authorizationHeader && !har.headers.find(function (hdr) { return hdr.name.toLowerCase() === 'authorization'; })) {\n            har.headers.push({\n                name: 'authorization',\n                value: String(formData.header[authorizationHeader])\n            });\n        }\n    }\n    var requestBody;\n    if (operation.hasRequestBody()) {\n        // @ts-expect-error TODO `requestBody` coming back as `false | MediaTypeObject | [string, MediaTypeObject]` seems like a problem\n        _a = __read(operation.getRequestBody(), 2), requestBody = _a[1];\n    }\n    if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {\n        var requestBodySchema_1 = requestBody.schema;\n        if (operation.isFormUrlEncoded()) {\n            if (Object.keys(formData.formData).length) {\n                var cleanFormData_1 = (0, remove_undefined_objects_1[\"default\"])(JSON.parse(JSON.stringify(formData.formData)));\n                if (cleanFormData_1 !== undefined) {\n                    har.postData.params = [];\n                    har.postData.mimeType = 'application/x-www-form-urlencoded';\n                    Object.keys(cleanFormData_1).forEach(function (name) {\n                        har.postData.params.push({\n                            name: name,\n                            value: stringifyParameter(cleanFormData_1[name])\n                        });\n                    });\n                }\n            }\n        }\n        else if ('body' in formData &&\n            formData.body !== undefined &&\n            (isPrimitive(formData.body) || Object.keys(formData.body).length)) {\n            var isMultipart = operation.isMultipart();\n            var isJSON = operation.isJson();\n            if (isMultipart || isJSON) {\n                try {\n                    var cleanBody_1 = (0, remove_undefined_objects_1[\"default\"])(JSON.parse(JSON.stringify(formData.body)));\n                    if (isMultipart) {\n                        har.postData.mimeType = 'multipart/form-data';\n                        har.postData.params = [];\n                        /**\n                         * Discover all `{ type: string, format: binary }` properties, or arrays containing the\n                         * same, within the request body. If there are any, then that means that we're dealing\n                         * with a `multipart/form-data` request and need to treat the payload as\n                         * `postData.params` and supply filenames and content types for the files (if they're\n                         * available).\n                         *\n                         * @example `{ type: string, format: binary }`\n                         * @example `{ type: array, items: { type: string, format: binary } }`\n                         */\n                        var binaryTypes_1 = Object.keys(requestBodySchema_1.properties).filter(function (key) {\n                            var propData = requestBodySchema_1.properties[key];\n                            if (propData.format === 'binary') {\n                                return true;\n                            }\n                            else if (propData.type === 'array' &&\n                                propData.items &&\n                                typeof propData.items === 'object' &&\n                                propData.items !== null &&\n                                propData.items.format === 'binary') {\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (cleanBody_1 !== undefined) {\n                            var multipartParams_1 = multipartBodyToFormatterParams(formData.body, operation.schema.requestBody.content['multipart/form-data']);\n                            Object.keys(cleanBody_1).forEach(function (name) {\n                                var param = multipartParams_1.find(function (multipartParam) { return multipartParam.name === name; });\n                                // If we're dealing with a binary type, and the value is a valid data URL we should\n                                // parse out any available filename and content type to send along with the\n                                // parameter to interpreters like `fetch-har` can make sense of it and send a usable\n                                // payload.\n                                var addtlData = {};\n                                var value = formatter(formData, param, 'body', true);\n                                if (!Array.isArray(value)) {\n                                    value = [value];\n                                }\n                                value.forEach(function (val) {\n                                    if (binaryTypes_1.includes(name)) {\n                                        var parsed = (0, data_urls_1.parse)(val);\n                                        if (parsed) {\n                                            addtlData.fileName = 'name' in parsed ? parsed.name : 'unknown';\n                                            if ('contentType' in parsed) {\n                                                addtlData.contentType = parsed.contentType;\n                                            }\n                                        }\n                                    }\n                                    appendHarValue(har.postData.params, name, val, addtlData);\n                                });\n                            });\n                        }\n                    }\n                    else {\n                        har.postData.mimeType = contentType;\n                        /**\n                         * Handle arbitrary JSON input via a string.\n                         *\n                         * In OAS you usually find this in an `application/json` content type with a schema\n                         * `type=string, format=json`. In the UI this is represented by an arbitrary text input.\n                         *\n                         * This ensures we remove any newlines or tabs and use a clean JSON block in the\n                         * example.\n                         */\n                        if (requestBody.schema.type === 'string') {\n                            har.postData.text = JSON.stringify(JSON.parse(cleanBody_1));\n                        }\n                        else {\n                            /**\n                             * Handle formatted JSON objects that have properties that accept arbitrary JSON.\n                             *\n                             * Find all `{ type: string, format: json }` properties in the schema because we need\n                             * to manually `JSON.parse` them before submit, otherwise they'll be escaped instead\n                             * of actual objects. We also only want values that the user has entered, so we drop\n                             * any `undefined` `cleanBody` keys.\n                             */\n                            var jsonTypes = Object.keys(requestBodySchema_1.properties).filter(function (key) {\n                                var propData = requestBodySchema_1.properties[key];\n                                return propData.format === 'json' && cleanBody_1[key] !== undefined;\n                            });\n                            if (jsonTypes.length) {\n                                try {\n                                    jsonTypes.forEach(function (prop) {\n                                        try {\n                                            cleanBody_1[prop] = JSON.parse(cleanBody_1[prop]);\n                                        }\n                                        catch (e) {\n                                            // leave the prop as a string value\n                                        }\n                                    });\n                                    // `RAW_BODY` is a ReadMe-specific thing where we'll interpret the entire payload\n                                    // as a raw string. https://docs.readme.com/docs/raw-body-content\n                                    if (typeof cleanBody_1.RAW_BODY !== 'undefined') {\n                                        cleanBody_1 = cleanBody_1.RAW_BODY;\n                                    }\n                                    har.postData.text = JSON.stringify(cleanBody_1);\n                                }\n                                catch (e) {\n                                    har.postData.text = stringify(formData.body);\n                                }\n                            }\n                            else {\n                                har.postData.text = encodeBodyForHAR(formData.body);\n                            }\n                        }\n                    }\n                }\n                catch (e) {\n                    // If anything above fails for whatever reason, assume that whatever we had is invalid\n                    // JSON and just treat it as raw text.\n                    har.postData.text = stringify(formData.body);\n                }\n            }\n            else {\n                har.postData.mimeType = contentType;\n                har.postData.text = encodeBodyForHAR(formData.body);\n            }\n        }\n    }\n    // Add a `content-type` header if there are any body values setup above or if there is a schema\n    // defined, but only do so if we don't already have a `content-type` present as it's impossible\n    // for a request to have multiple.\n    if ((har.postData.text || (requestBody && requestBody.schema && Object.keys(requestBody.schema).length)) &&\n        !hasContentType) {\n        har.headers.push({\n            name: 'content-type',\n            value: contentType\n        });\n    }\n    var securityRequirements = operation.getSecurity();\n    if (securityRequirements && securityRequirements.length) {\n        // TODO pass these values through the formatter?\n        securityRequirements.forEach(function (schemes) {\n            Object.keys(schemes).forEach(function (security) {\n                var securityValue = (0, configure_security_1[\"default\"])(apiDefinition, auth, security);\n                if (!securityValue) {\n                    return;\n                }\n                // If this is an `authorization` header and we've already added one (maybe one was manually\n                // specified), then we shouldn't add another.\n                if (securityValue.value.name === 'authorization') {\n                    if (har[securityValue.type].find(function (v) { return v.name === securityValue.value.name; })) {\n                        return;\n                    }\n                }\n                // If we've already added this **specific** security value then don't add it again.\n                if (har[securityValue.type].find(function (v) { return v.name === securityValue.value.name && v.value === securityValue.value.value; })) {\n                    return;\n                }\n                har[securityValue.type].push(securityValue.value);\n            });\n        });\n    }\n    // If we didn't end up filling the `postData` object then we don't need it.\n    if (Object.keys(har.postData).length === 0) {\n        delete har.postData;\n    }\n    return {\n        log: {\n            entries: [\n                {\n                    request: har\n                },\n            ]\n        }\n    };\n}\nexports[\"default\"] = oasToHar;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,YAAY;EAClDA,QAAQ,GAAGC,MAAM,CAACC,MAAM,IAAI,UAASC,CAAC,EAAE;IACpC,KAAK,IAAIC,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACjDD,CAAC,GAAGG,SAAS,CAACF,CAAC,CAAC;MAChB,KAAK,IAAII,CAAC,IAAIL,CAAC,EAAE,IAAIH,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,CAAC,EAAEK,CAAC,CAAC,EAC3DN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IACnB;IACA,OAAON,CAAC;EACZ,CAAC;EACD,OAAOH,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEN,SAAS,CAAC;AAC1C,CAAC;AACD,IAAIO,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,KAAMb,MAAM,CAACc,MAAM,GAAI,UAASC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EAC5F,IAAIA,EAAE,KAAKC,SAAS,EAAED,EAAE,GAAGD,CAAC;EAC5B,IAAIG,IAAI,GAAGpB,MAAM,CAACqB,wBAAwB,CAACL,CAAC,EAAEC,CAAC,CAAC;EAChD,IAAI,CAACG,IAAI,KAAK,KAAK,IAAIA,IAAI,GAAG,CAACJ,CAAC,CAACM,UAAU,GAAGF,IAAI,CAACG,QAAQ,IAAIH,IAAI,CAACI,YAAY,CAAC,EAAE;IACjFJ,IAAI,GAAG;MAAEK,UAAU,EAAE,IAAI;MAAEC,GAAG,EAAE,SAAAA,CAAA,EAAW;QAAE,OAAOV,CAAC,CAACC,CAAC,CAAC;MAAE;IAAE,CAAC;EAC/D;EACAjB,MAAM,CAAC2B,cAAc,CAACZ,CAAC,EAAEG,EAAE,EAAEE,IAAI,CAAC;AACtC,CAAC,GAAK,UAASL,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EACxB,IAAIA,EAAE,KAAKC,SAAS,EAAED,EAAE,GAAGD,CAAC;EAC5BF,CAAC,CAACG,EAAE,CAAC,GAAGF,CAAC,CAACC,CAAC,CAAC;AAChB,CAAE,CAAC;AACH,IAAIW,kBAAkB,GAAI,IAAI,IAAI,IAAI,CAACA,kBAAkB,KAAM5B,MAAM,CAACc,MAAM,GAAI,UAASC,CAAC,EAAEc,CAAC,EAAE;EAC3F7B,MAAM,CAAC2B,cAAc,CAACZ,CAAC,EAAE,SAAS,EAAE;IAAEU,UAAU,EAAE,IAAI;IAAEK,KAAK,EAAED;EAAE,CAAC,CAAC;AACvE,CAAC,GAAI,UAASd,CAAC,EAAEc,CAAC,EAAE;EAChBd,CAAC,CAAC,SAAS,CAAC,GAAGc,CAAC;AACpB,CAAC,CAAC;AACF,IAAIE,YAAY,GAAI,IAAI,IAAI,IAAI,CAACA,YAAY,IAAK,UAAUC,GAAG,EAAE;EAC7D,IAAIA,GAAG,IAAIA,GAAG,CAACV,UAAU,EAAE,OAAOU,GAAG;EACrC,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,IAAID,GAAG,IAAI,IAAI,EAAE,KAAK,IAAIf,CAAC,IAAIe,GAAG,EAAE,IAAIf,CAAC,KAAK,SAAS,IAAIjB,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACqB,GAAG,EAAEf,CAAC,CAAC,EAAEJ,eAAe,CAACoB,MAAM,EAAED,GAAG,EAAEf,CAAC,CAAC;EACxIW,kBAAkB,CAACK,MAAM,EAAED,GAAG,CAAC;EAC/B,OAAOC,MAAM;AACjB,CAAC;AACD,IAAIC,MAAM,GAAI,IAAI,IAAI,IAAI,CAACA,MAAM,IAAK,UAAUnB,CAAC,EAAEV,CAAC,EAAE;EAClD,IAAIW,CAAC,GAAG,OAAOmB,MAAM,KAAK,UAAU,IAAIpB,CAAC,CAACoB,MAAM,CAACC,QAAQ,CAAC;EAC1D,IAAI,CAACpB,CAAC,EAAE,OAAOD,CAAC;EAChB,IAAIX,CAAC,GAAGY,CAAC,CAACL,IAAI,CAACI,CAAC,CAAC;IAAEsB,CAAC;IAAEC,EAAE,GAAG,EAAE;IAAEC,CAAC;EAChC,IAAI;IACA,OAAO,CAAClC,CAAC,KAAK,KAAK,CAAC,IAAIA,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,CAACgC,CAAC,GAAGjC,CAAC,CAACoC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAEH,EAAE,CAACI,IAAI,CAACL,CAAC,CAACP,KAAK,CAAC;EAC9E,CAAC,CACD,OAAOa,KAAK,EAAE;IAAEJ,CAAC,GAAG;MAAEI,KAAK,EAAEA;IAAM,CAAC;EAAE,CAAC,SAC/B;IACJ,IAAI;MACA,IAAIN,CAAC,IAAI,CAACA,CAAC,CAACI,IAAI,KAAKzB,CAAC,GAAGZ,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAEY,CAAC,CAACL,IAAI,CAACP,CAAC,CAAC;IACpD,CAAC,SACO;MAAE,IAAImC,CAAC,EAAE,MAAMA,CAAC,CAACI,KAAK;IAAE;EACpC;EACA,OAAOL,EAAE;AACb,CAAC;AACD,IAAIM,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUZ,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACV,UAAU,GAAIU,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDa,OAAO,CAACvB,UAAU,GAAG,IAAI;AACzB,IAAIwB,WAAW,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAC9C,IAAIC,UAAU,GAAGjB,YAAY,CAACgB,OAAO,CAAC,wBAAwB,CAAC,CAAC;AAChE,IAAIE,KAAK,GAAGF,OAAO,CAAC,KAAK,CAAC;AAC1B,IAAIG,aAAa,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AACnD,IAAII,0BAA0B,GAAGP,eAAe,CAACG,OAAO,CAAC,0BAA0B,CAAC,CAAC;AACrF,IAAIK,oBAAoB,GAAGR,eAAe,CAACG,OAAO,CAAC,0BAA0B,CAAC,CAAC;AAC/E,IAAIM,kBAAkB,GAAGT,eAAe,CAACG,OAAO,CAAC,wBAAwB,CAAC,CAAC;AAC3E,IAAIO,eAAe,GAAGL,KAAK,CAACM,KAAK,CAACD,eAAe;EAAEE,eAAe,GAAGP,KAAK,CAACM,KAAK,CAACC,eAAe;AAChG,SAASC,SAASA,CAACC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAEC,YAAY,EAAE;EAClD,IAAIA,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,KAAK;EAAE;EACrD,IAAIF,KAAK,CAACG,KAAK,EAAE;IACb,IAAIC,OAAO,GAAGL,MAAM,CAACE,IAAI,CAAC,CAACD,KAAK,CAACK,IAAI,CAAC;IACtC;IACA;IACA,OAAO,CAAC,CAAC,EAAEX,kBAAkB,CAAC,SAAS,CAAC,EAAEU,OAAO,EAAEJ,KAAK,CAAC;EAC7D;EACA,IAAI7B,KAAK;EACT;EACA,IAAI,OAAO4B,MAAM,CAACE,IAAI,CAAC,CAACD,KAAK,CAACK,IAAI,CAAC,KAAK,WAAW,EAAE;IACjDlC,KAAK,GAAG4B,MAAM,CAACE,IAAI,CAAC,CAACD,KAAK,CAACK,IAAI,CAAC;EACpC,CAAC,MACI,IAAIH,YAAY,IAAI,CAACF,KAAK,CAACM,QAAQ,EAAE;IACtCnC,KAAK,GAAGX,SAAS;EACrB,CAAC,MACI,IAAIwC,KAAK,CAACM,QAAQ,IAAIN,KAAK,CAACO,MAAM,IAAI,CAAC,CAAC,CAAC,EAAEhB,aAAa,CAACiB,KAAK,EAAER,KAAK,CAACO,MAAM,CAAC,IAAIP,KAAK,CAACO,MAAM,CAAC,SAAS,CAAC,EAAE;IAC3GpC,KAAK,GAAG6B,KAAK,CAACO,MAAM,CAAC,SAAS,CAAC;EACnC,CAAC,MACI,IAAIN,IAAI,KAAK,MAAM,EAAE;IACtB;IACA;IACA,OAAOD,KAAK,CAACK,IAAI;EACrB;EACA;EACA;EACA,IAAIL,KAAK,CAACO,MAAM,IACZ,CAAC,CAAC,CAAC,EAAEhB,aAAa,CAACiB,KAAK,EAAER,KAAK,CAACO,MAAM,CAAC,IACvCP,KAAK,CAACO,MAAM,CAACN,IAAI,KAAK,OAAO,IAC7BD,KAAK,CAACO,MAAM,CAACE,KAAK,IAClB,CAAC,CAAC,CAAC,EAAElB,aAAa,CAACiB,KAAK,EAAER,KAAK,CAACO,MAAM,CAACE,KAAK,CAAC,IAC7CT,KAAK,CAACO,MAAM,CAACE,KAAK,CAACC,MAAM,KAAK,QAAQ,EAAE;IACxC,IAAIC,KAAK,CAACC,OAAO,CAACzC,KAAK,CAAC,EAAE;MACtB;MACA;MACA;MACA,OAAOA,KAAK;IAChB;IACA,OAAO0C,IAAI,CAACC,SAAS,CAAC3C,KAAK,CAAC;EAChC;EACA,IAAIA,KAAK,KAAKX,SAAS,EAAE;IACrB;IACA;IACA,IAAIyC,IAAI,KAAK,OAAO,EAAE;MAClB,OAAO,CAAC,CAAC,EAAEP,kBAAkB,CAAC,SAAS,CAAC,EAAEvB,KAAK,EAAE6B,KAAK,CAAC;IAC3D;IACA,OAAO7B,KAAK;EAChB;EACA,OAAOX,SAAS;AACpB;AACA,SAASuD,8BAA8BA,CAACC,aAAa,EAAEC,kBAAkB,EAAE;EACvE,IAAIV,MAAM,GAAGU,kBAAkB,CAACV,MAAM;EACtC,IAAIW,QAAQ,GAAGD,kBAAkB,CAACC,QAAQ;EAC1C,IAAI,OAAOF,aAAa,KAAK,QAAQ,IAAIA,aAAa,KAAK,IAAI,EAAE;IAC7D,OAAO3E,MAAM,CAAC8E,IAAI,CAACH,aAAa,CAAC,CAC5BI,GAAG,CAAC,UAAUC,GAAG,EAAE;MACpB;MACA,IAAI,CAACd,MAAM,CAACe,UAAU,CAACD,GAAG,CAAC,EAAE;QACzB,OAAO,KAAK;MAChB;MACA,IAAIE,aAAa,GAAGL,QAAQ,GAAGA,QAAQ,CAACG,GAAG,CAAC,GAAG7D,SAAS;MACxD,OAAO;QACH6C,IAAI,EAAEgB,GAAG;QACT;QACAlB,KAAK,EAAEoB,aAAa,GAAGA,aAAa,CAACpB,KAAK,GAAG3C,SAAS;QACtD;QACAgE,OAAO,EAAED,aAAa,GAAGA,aAAa,CAACC,OAAO,GAAGhE,SAAS;QAC1D8C,QAAQ,EAAGC,MAAM,CAACD,QAAQ,IAAI,OAAOC,MAAM,CAACD,QAAQ,KAAK,SAAS,IAAImB,OAAO,CAAClB,MAAM,CAACD,QAAQ,CAAC,IACzFK,KAAK,CAACC,OAAO,CAACL,MAAM,CAACD,QAAQ,CAAC,IAAIC,MAAM,CAACD,QAAQ,CAACoB,QAAQ,CAACL,GAAG,CAAE;QACrEd,MAAM,EAAEA,MAAM,CAACe,UAAU,CAACD,GAAG,CAAC;QAC9B,IAAI,EAAE;MACV,CAAC;IACL,CAAC,CAAC,CACGM,MAAM,CAACF,OAAO,CAAC;EACxB;EACA;EACA;EACA,OAAO,EAAE;AACb;AACA,IAAIG,oBAAoB,GAAGvF,MAAM,CAAC8E,IAAI,CAACxB,eAAe,CAAC,CAACkC,MAAM,CAAC,UAAUC,IAAI,EAAEC,IAAI,EAAE;EACjF,IAAIC,EAAE;EACN,OAAO3F,MAAM,CAACC,MAAM,CAACwF,IAAI,GAAGE,EAAE,GAAG,CAAC,CAAC,EAAEA,EAAE,CAACD,IAAI,CAAC,GAAG,CAAC,CAAC,EAAEC,EAAE,CAAC,CAAC;AAC5D,CAAC,EAAE,CAAC,CAAC,CAAC;AACN,SAASC,sBAAsBA,CAACC,OAAO,EAAE;EACrC,IAAIC,KAAK,GAAG9F,MAAM,CAAC8E,IAAI,CAACe,OAAO,CAAC,IAAI,EAAE;EACtC;EACA;EACA;EACA,IAAIC,KAAK,IAAIA,KAAK,CAACvF,MAAM,EAAE;IACvB,IAAIwF,QAAQ,GAAGD,KAAK,CAACE,IAAI,CAAC,UAAU9F,CAAC,EAAE;MAAE,OAAOsD,eAAe,CAACyC,IAAI,CAAC/F,CAAC,CAAC;IAAE,CAAC,CAAC;IAC3E,IAAI6F,QAAQ,EAAE;MACV,OAAOA,QAAQ;IACnB;IACA,OAAOD,KAAK,CAAC,CAAC,CAAC;EACnB;EACA,OAAO,kBAAkB;AAC7B;AACA,SAASI,WAAWA,CAACC,GAAG,EAAE;EACtB,OAAO,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,SAAS;AACzF;AACA,SAAS1B,SAASA,CAACwB,IAAI,EAAE;EACrB,OAAOzB,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC,EAAEtB,0BAA0B,CAAC,SAAS,CAAC,EAAE,OAAO8C,IAAI,CAACG,QAAQ,KAAK,WAAW,GAAGH,IAAI,CAACG,QAAQ,GAAGH,IAAI,CAAC,CAAC;AAClI;AACA,SAASI,kBAAkBA,CAAC1C,KAAK,EAAE;EAC/B,IAAIA,KAAK,KAAK,IAAI,IAAIuC,WAAW,CAACvC,KAAK,CAAC,EAAE;IACtC,OAAOA,KAAK;EAChB,CAAC,MACI,IAAIW,KAAK,CAACC,OAAO,CAACZ,KAAK,CAAC,IAAIA,KAAK,CAAC2C,KAAK,CAACJ,WAAW,CAAC,EAAE;IACvD,OAAOK,MAAM,CAAC5C,KAAK,CAAC;EACxB;EACA,OAAOa,IAAI,CAACC,SAAS,CAACd,KAAK,CAAC;AAChC;AACA,SAAS6C,cAAcA,CAACC,QAAQ,EAAEzC,IAAI,EAAElC,KAAK,EAAE4E,SAAS,EAAE;EACtD,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,CAAC,CAAC;EAAE;EAC5C,IAAI,OAAO5E,KAAK,KAAK,WAAW,EAC5B;EACJ,IAAIwC,KAAK,CAACC,OAAO,CAACzC,KAAK,CAAC,EAAE;IACtB;IACA;IACAA,KAAK,CAAC6E,OAAO,CAAC,UAAUC,WAAW,EAAE;MACjCJ,cAAc,CAACC,QAAQ,EAAEzC,IAAI,EAAE4C,WAAW,CAAC;IAC/C,CAAC,CAAC;EACN,CAAC,MACI,IAAI,OAAO9E,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;IAClD;IACA;IACA9B,MAAM,CAAC8E,IAAI,CAAChD,KAAK,CAAC,CAAC6E,OAAO,CAAC,UAAU3B,GAAG,EAAE;MACtCwB,cAAc,CAACC,QAAQ,EAAEzB,GAAG,EAAElD,KAAK,CAACkD,GAAG,CAAC,CAAC;IAC7C,CAAC,CAAC;EACN,CAAC,MACI;IACD;IACAyB,QAAQ,CAAC/D,IAAI,CAAC3C,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAE2G,SAAS,CAAC,EAAE;MAAE1C,IAAI,EAAEA,IAAI;MAAElC,KAAK,EAAEyE,MAAM,CAACzE,KAAK;IAAE,CAAC,CAAC,CAAC;EAC1F;AACJ;AACA,SAAS+E,gBAAgBA,CAACC,IAAI,EAAE;EAC5B,IAAIZ,WAAW,CAACY,IAAI,CAAC,EAAE;IACnB,OAAOA,IAAI;EACf,CAAC,MACI,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAC7BA,IAAI,KAAK,IAAI,IACb,CAACxC,KAAK,CAACC,OAAO,CAACuC,IAAI,CAAC,IACpB,OAAOA,IAAI,CAACV,QAAQ,KAAK,WAAW,EAAE;IACtC;IACA;IACA,IAAIF,WAAW,CAACY,IAAI,CAACV,QAAQ,CAAC,EAAE;MAC5B,OAAOU,IAAI,CAACV,QAAQ;IACxB;IACA,OAAO3B,SAAS,CAACqC,IAAI,CAACV,QAAQ,CAAC;EACnC;EACA,OAAO3B,SAAS,CAACqC,IAAI,CAAC;AAC1B;AACA,SAASC,QAAQA,CAACC,GAAG,EAAEC,eAAe,EAAEvD,MAAM,EAAEwD,IAAI,EAAEC,IAAI,EAAE;EACxD,IAAIxB,EAAE;EACN,IAAIjC,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,CAAC,CAAC;EAAE;EACtC,IAAIwD,IAAI,KAAK,KAAK,CAAC,EAAE;IAAEA,IAAI,GAAG,CAAC,CAAC;EAAE;EAClC,IAAIC,IAAI,KAAK,KAAK,CAAC,EAAE;IAAEA,IAAI,GAAG;MAC1B;MACA;MACAC,QAAQ,EAAE;IACd,CAAC;EAAE;EACH,IAAIC,SAAS;EACb,IAAI,CAACJ,eAAe,IAAI,OAAOA,eAAe,CAACK,aAAa,KAAK,UAAU,EAAE;IACzE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQD,SAAS,GAAG,IAAIpE,KAAK,CAACsE,SAAS,CAACP,GAAG,EAAE,CAACC,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACO,IAAI,KAAK,EAAE,EAAE,CAACP,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACQ,MAAM,KAAK,EAAE,EAAER,eAAe,IAAI;MAAEO,IAAI,EAAE,EAAE;MAAEC,MAAM,EAAE;IAAG,CAAC,CAAC;EACvR,CAAC,MACI;IACDJ,SAAS,GAAGJ,eAAe;EAC/B;EACA,IAAIS,aAAa,GAAGV,GAAG,CAACW,aAAa,CAAC,CAAC;EACvC,IAAIC,QAAQ,GAAG7H,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEwF,oBAAoB,CAAC,EAAE;IAAEsC,MAAM,EAAE;MACvEC,QAAQ,EAAE,CAAC;MACXC,SAAS,EAAEf,GAAG,CAACgB,gBAAgB,CAAC,CAAC;IACrC;EAAE,CAAC,CAAC,EAAEtE,MAAM,CAAC;EACjB;EACAkE,QAAQ,CAACC,MAAM,CAACE,SAAS,GAAGhI,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEiH,GAAG,CAACgB,gBAAgB,CAACJ,QAAQ,CAACC,MAAM,CAACC,QAAQ,CAAC,CAAC,EAAGF,QAAQ,CAACC,MAAM,CAACE,SAAS,GAAGH,QAAQ,CAACC,MAAM,CAACE,SAAS,GAAG,CAAC,CAAE,CAAC;EAChK,IAAIE,GAAG,GAAG;IACNC,OAAO,EAAE,EAAE;IACXC,OAAO,EAAE,EAAE;IACXC,WAAW,EAAE,CAAC;IACdC,WAAW,EAAE,EAAE;IACf;IACAC,QAAQ,EAAE,CAAC,CAAC;IACZC,QAAQ,EAAE,CAAC;IACXd,MAAM,EAAEJ,SAAS,CAACI,MAAM,CAACe,WAAW,CAAC,CAAC;IACtCC,GAAG,EAAE,EAAE,CAACC,MAAM,CAAC1B,GAAG,CAACyB,GAAG,CAACb,QAAQ,CAACC,MAAM,CAACC,QAAQ,EAAEF,QAAQ,CAACC,MAAM,CAACE,SAAS,CAAC,CAAC,CAACW,MAAM,CAACrB,SAAS,CAACG,IAAI,CAAC,CAACmB,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;IACzHC,WAAW,EAAE;EACjB,CAAC;EACD,IAAIzB,IAAI,CAACC,QAAQ,EAAE;IACf,IAAIpE,UAAU,CAAC6F,YAAY,CAAC7F,UAAU,CAAC8F,aAAa,EAAE9B,GAAG,EAAEK,SAAS,CAAC,EAAE;MACnEY,GAAG,CAACQ,GAAG,GAAG,wBAAwB,CAACC,MAAM,CAACT,GAAG,CAACQ,GAAG,CAAC;IACtD;EACJ;EACA,IAAIM,UAAU,GAAG1B,SAAS,CAACC,aAAa,CAAC,CAAC;EAC1CW,GAAG,CAACQ,GAAG,GAAGR,GAAG,CAACQ,GAAG,CAACE,OAAO,CAAC,wBAAwB,EAAE,UAAUK,IAAI,EAAEhE,GAAG,EAAE;IACrE,IAAI,CAACqC,SAAS,IAAI,CAAC0B,UAAU,EACzB,OAAO/D,GAAG,CAAC,CAAC;IAChB;IACA,IAAIiE,SAAS,GAAGF,UAAU,CAAC/C,IAAI,CAAC,UAAUrC,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACK,IAAI,KAAKgB,GAAG;IAAE,CAAC,CAAC,IAAI;MAAEhB,IAAI,EAAEgB;IAAI,CAAC;IACjG;IACA;IACA,IAAI,EAAE,OAAO,IAAIiE,SAAS,CAAC,IAAI,CAACA,SAAS,CAACnF,KAAK,EAAE;MAC7C,OAAOoF,kBAAkB,CAACzF,SAAS,CAACmE,QAAQ,EAAEqB,SAAS,EAAE,MAAM,CAAC,CAAC;IACrE;IACA,OAAOxF,SAAS,CAACmE,QAAQ,EAAEqB,SAAS,EAAE,MAAM,CAAC;EACjD,CAAC,CAAC;EACF,IAAIE,YAAY,GAAGJ,UAAU,IAAIA,UAAU,CAACzD,MAAM,CAAC,UAAU3B,KAAK,EAAE;IAAE,OAAOA,KAAK,CAAC,IAAI,CAAC,KAAK,OAAO;EAAE,CAAC,CAAC;EACxG,IAAIwF,YAAY,IAAIA,YAAY,CAAC5I,MAAM,EAAE;IACrC4I,YAAY,CAACxC,OAAO,CAAC,UAAU0B,WAAW,EAAE;MACxC,IAAIvG,KAAK,GAAG2B,SAAS,CAACmE,QAAQ,EAAES,WAAW,EAAE,OAAO,EAAE,IAAI,CAAC;MAC3D7B,cAAc,CAACyB,GAAG,CAACI,WAAW,EAAEA,WAAW,CAACrE,IAAI,EAAElC,KAAK,CAAC;IAC5D,CAAC,CAAC;EACN;EACA;EACA,IAAIoG,OAAO,GAAGa,UAAU,IAAIA,UAAU,CAACzD,MAAM,CAAC,UAAU3B,KAAK,EAAE;IAAE,OAAOA,KAAK,CAAC,IAAI,CAAC,KAAK,QAAQ;EAAE,CAAC,CAAC;EACpG,IAAIuE,OAAO,IAAIA,OAAO,CAAC3H,MAAM,EAAE;IAC3B2H,OAAO,CAACvB,OAAO,CAAC,UAAUyC,MAAM,EAAE;MAC9B,IAAItH,KAAK,GAAG2B,SAAS,CAACmE,QAAQ,EAAEwB,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC;MACvD5C,cAAc,CAACyB,GAAG,CAACC,OAAO,EAAEkB,MAAM,CAACpF,IAAI,EAAElC,KAAK,CAAC;IACnD,CAAC,CAAC;EACN;EACA;EACA,IAAIuF,SAAS,CAACnD,MAAM,CAACmF,SAAS,EAAE;IAC5BrJ,MAAM,CAAC8E,IAAI,CAACuC,SAAS,CAACnD,MAAM,CAACmF,SAAS,CAAC,CAACC,IAAI,CAAC,UAAUC,QAAQ,EAAE;MAC7D,IAAI,CAAC,CAAC,EAAErG,aAAa,CAACiB,KAAK,EAAEkD,SAAS,CAACnD,MAAM,CAACmF,SAAS,CAACE,QAAQ,CAAC,CAAC,EAC9D,OAAO,KAAK;MAChB,IAAI1D,OAAO,GAAGwB,SAAS,CAACnD,MAAM,CAACmF,SAAS,CAACE,QAAQ,CAAC,CAAC1D,OAAO;MAC1D,IAAI,CAACA,OAAO,EACR,OAAO,KAAK;MAChB;MACA;MACA,IAAI7F,MAAM,CAAC8E,IAAI,CAAC8C,QAAQ,CAAC4B,MAAM,CAAC,CAACxD,IAAI,CAAC,UAAUyD,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACC,WAAW,CAAC,CAAC,KAAK,QAAQ;MAAE,CAAC,CAAC,EACxF,OAAO,IAAI;MACfzB,GAAG,CAACE,OAAO,CAACzF,IAAI,CAAC;QACbsB,IAAI,EAAE,QAAQ;QACdlC,KAAK,EAAE8D,sBAAsB,CAACC,OAAO;MACzC,CAAC,CAAC;MACF,OAAO,IAAI;IACf,CAAC,CAAC;EACN;EACA;EACA,IAAI8D,cAAc,GAAG,KAAK;EAC1B,IAAIC,WAAW,GAAGvC,SAAS,CAACwC,cAAc,CAAC,CAAC;EAC5C,IAAI1B,OAAO,GAAGY,UAAU,IAAIA,UAAU,CAACzD,MAAM,CAAC,UAAU3B,KAAK,EAAE;IAAE,OAAOA,KAAK,CAAC,IAAI,CAAC,KAAK,QAAQ;EAAE,CAAC,CAAC;EACpG,IAAIwE,OAAO,IAAIA,OAAO,CAAC5H,MAAM,EAAE;IAC3B4H,OAAO,CAACxB,OAAO,CAAC,UAAU6C,MAAM,EAAE;MAC9B,IAAI1H,KAAK,GAAG2B,SAAS,CAACmE,QAAQ,EAAE4B,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC;MACvD,IAAI,OAAO1H,KAAK,KAAK,WAAW,EAC5B;MACJ,IAAI0H,MAAM,CAACxF,IAAI,CAAC0F,WAAW,CAAC,CAAC,KAAK,cAAc,EAAE;QAC9CC,cAAc,GAAG,IAAI;QACrBC,WAAW,GAAGrD,MAAM,CAACzE,KAAK,CAAC;MAC/B;MACA0E,cAAc,CAACyB,GAAG,CAACE,OAAO,EAAEqB,MAAM,CAACxF,IAAI,EAAElC,KAAK,CAAC;IACnD,CAAC,CAAC;EACN;EACA;EACA,IAAIgI,kBAAkB,GAAG9G,UAAU,CAAC6F,YAAY,CAAC7F,UAAU,CAAC+G,OAAO,EAAE/C,GAAG,EAAEK,SAAS,CAAC;EACpF,IAAIyC,kBAAkB,EAAE;IACpBA,kBAAkB,CAACnD,OAAO,CAAC,UAAU6C,MAAM,EAAE;MACzC,IAAI,OAAOA,MAAM,CAACxE,GAAG,KAAK,QAAQ,IAAIwE,MAAM,CAACxE,GAAG,CAAC0E,WAAW,CAAC,CAAC,KAAK,cAAc,EAAE;QAC/EC,cAAc,GAAG,IAAI;QACrBC,WAAW,GAAGrD,MAAM,CAACiD,MAAM,CAAC1H,KAAK,CAAC;MACtC;MACAmG,GAAG,CAACE,OAAO,CAACzF,IAAI,CAAC;QACbsB,IAAI,EAAEuC,MAAM,CAACiD,MAAM,CAACxE,GAAG,CAAC;QACxBlD,KAAK,EAAEyE,MAAM,CAACiD,MAAM,CAAC1H,KAAK;MAC9B,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA,IAAI8F,QAAQ,CAAC4B,MAAM,EAAE;IACjB;IACA,IAAIQ,YAAY,GAAGhK,MAAM,CAAC8E,IAAI,CAAC8C,QAAQ,CAAC4B,MAAM,CAAC,CAACxD,IAAI,CAAC,UAAUyD,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACC,WAAW,CAAC,CAAC,KAAK,QAAQ;IAAE,CAAC,CAAC;IAC3G,IAAIM,YAAY,IAAI,CAAC/B,GAAG,CAACE,OAAO,CAACnC,IAAI,CAAC,UAAUiE,GAAG,EAAE;MAAE,OAAOA,GAAG,CAACjG,IAAI,CAAC0F,WAAW,CAAC,CAAC,KAAK,QAAQ;IAAE,CAAC,CAAC,EAAE;MACnGzB,GAAG,CAACE,OAAO,CAACzF,IAAI,CAAC;QACbsB,IAAI,EAAE,QAAQ;QACdlC,KAAK,EAAEyE,MAAM,CAACqB,QAAQ,CAAC4B,MAAM,CAACQ,YAAY,CAAC;MAC/C,CAAC,CAAC;IACN;IACA;IACA,IAAIE,mBAAmB,GAAGlK,MAAM,CAAC8E,IAAI,CAAC8C,QAAQ,CAAC4B,MAAM,CAAC,CAACxD,IAAI,CAAC,UAAUyD,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACC,WAAW,CAAC,CAAC,KAAK,eAAe;IAAE,CAAC,CAAC;IACzH,IAAIQ,mBAAmB,IAAI,CAACjC,GAAG,CAACE,OAAO,CAACnC,IAAI,CAAC,UAAUiE,GAAG,EAAE;MAAE,OAAOA,GAAG,CAACjG,IAAI,CAAC0F,WAAW,CAAC,CAAC,KAAK,eAAe;IAAE,CAAC,CAAC,EAAE;MACjHzB,GAAG,CAACE,OAAO,CAACzF,IAAI,CAAC;QACbsB,IAAI,EAAE,eAAe;QACrBlC,KAAK,EAAEyE,MAAM,CAACqB,QAAQ,CAAC4B,MAAM,CAACU,mBAAmB,CAAC;MACtD,CAAC,CAAC;IACN;EACJ;EACA,IAAIC,WAAW;EACf,IAAI9C,SAAS,CAAC+C,cAAc,CAAC,CAAC,EAAE;IAC5B;IACAzE,EAAE,GAAGzD,MAAM,CAACmF,SAAS,CAACgD,cAAc,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEF,WAAW,GAAGxE,EAAE,CAAC,CAAC,CAAC;EACnE;EACA,IAAIwE,WAAW,IAAIA,WAAW,CAACjG,MAAM,IAAIlE,MAAM,CAAC8E,IAAI,CAACqF,WAAW,CAACjG,MAAM,CAAC,CAAC3D,MAAM,EAAE;IAC7E,IAAI+J,mBAAmB,GAAGH,WAAW,CAACjG,MAAM;IAC5C,IAAImD,SAAS,CAACkD,gBAAgB,CAAC,CAAC,EAAE;MAC9B,IAAIvK,MAAM,CAAC8E,IAAI,CAAC8C,QAAQ,CAACA,QAAQ,CAAC,CAACrH,MAAM,EAAE;QACvC,IAAIiK,eAAe,GAAG,CAAC,CAAC,EAAErH,0BAA0B,CAAC,SAAS,CAAC,EAAEqB,IAAI,CAACiG,KAAK,CAACjG,IAAI,CAACC,SAAS,CAACmD,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC;QAC/G,IAAI4C,eAAe,KAAKrJ,SAAS,EAAE;UAC/B8G,GAAG,CAACK,QAAQ,CAACoC,MAAM,GAAG,EAAE;UACxBzC,GAAG,CAACK,QAAQ,CAACqC,QAAQ,GAAG,mCAAmC;UAC3D3K,MAAM,CAAC8E,IAAI,CAAC0F,eAAe,CAAC,CAAC7D,OAAO,CAAC,UAAU3C,IAAI,EAAE;YACjDiE,GAAG,CAACK,QAAQ,CAACoC,MAAM,CAAChI,IAAI,CAAC;cACrBsB,IAAI,EAAEA,IAAI;cACVlC,KAAK,EAAEuE,kBAAkB,CAACmE,eAAe,CAACxG,IAAI,CAAC;YACnD,CAAC,CAAC;UACN,CAAC,CAAC;QACN;MACJ;IACJ,CAAC,MACI,IAAI,MAAM,IAAI4D,QAAQ,IACvBA,QAAQ,CAACd,IAAI,KAAK3F,SAAS,KAC1B+E,WAAW,CAAC0B,QAAQ,CAACd,IAAI,CAAC,IAAI9G,MAAM,CAAC8E,IAAI,CAAC8C,QAAQ,CAACd,IAAI,CAAC,CAACvG,MAAM,CAAC,EAAE;MACnE,IAAIqK,WAAW,GAAGvD,SAAS,CAACuD,WAAW,CAAC,CAAC;MACzC,IAAIC,MAAM,GAAGxD,SAAS,CAACyD,MAAM,CAAC,CAAC;MAC/B,IAAIF,WAAW,IAAIC,MAAM,EAAE;QACvB,IAAI;UACA,IAAIE,WAAW,GAAG,CAAC,CAAC,EAAE5H,0BAA0B,CAAC,SAAS,CAAC,EAAEqB,IAAI,CAACiG,KAAK,CAACjG,IAAI,CAACC,SAAS,CAACmD,QAAQ,CAACd,IAAI,CAAC,CAAC,CAAC;UACvG,IAAI8D,WAAW,EAAE;YACb3C,GAAG,CAACK,QAAQ,CAACqC,QAAQ,GAAG,qBAAqB;YAC7C1C,GAAG,CAACK,QAAQ,CAACoC,MAAM,GAAG,EAAE;YACxB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;YACwB,IAAIM,aAAa,GAAGhL,MAAM,CAAC8E,IAAI,CAACwF,mBAAmB,CAACrF,UAAU,CAAC,CAACK,MAAM,CAAC,UAAUN,GAAG,EAAE;cAClF,IAAIiG,QAAQ,GAAGX,mBAAmB,CAACrF,UAAU,CAACD,GAAG,CAAC;cAClD,IAAIiG,QAAQ,CAAC5G,MAAM,KAAK,QAAQ,EAAE;gBAC9B,OAAO,IAAI;cACf,CAAC,MACI,IAAI4G,QAAQ,CAACrH,IAAI,KAAK,OAAO,IAC9BqH,QAAQ,CAAC7G,KAAK,IACd,OAAO6G,QAAQ,CAAC7G,KAAK,KAAK,QAAQ,IAClC6G,QAAQ,CAAC7G,KAAK,KAAK,IAAI,IACvB6G,QAAQ,CAAC7G,KAAK,CAACC,MAAM,KAAK,QAAQ,EAAE;gBACpC,OAAO,IAAI;cACf;cACA,OAAO,KAAK;YAChB,CAAC,CAAC;YACF,IAAI0G,WAAW,KAAK5J,SAAS,EAAE;cAC3B,IAAI+J,iBAAiB,GAAGxG,8BAA8B,CAACkD,QAAQ,CAACd,IAAI,EAAEO,SAAS,CAACnD,MAAM,CAACiG,WAAW,CAACtE,OAAO,CAAC,qBAAqB,CAAC,CAAC;cAClI7F,MAAM,CAAC8E,IAAI,CAACiG,WAAW,CAAC,CAACpE,OAAO,CAAC,UAAU3C,IAAI,EAAE;gBAC7C,IAAIL,KAAK,GAAGuH,iBAAiB,CAAClF,IAAI,CAAC,UAAUmF,cAAc,EAAE;kBAAE,OAAOA,cAAc,CAACnH,IAAI,KAAKA,IAAI;gBAAE,CAAC,CAAC;gBACtG;gBACA;gBACA;gBACA;gBACA,IAAI0C,SAAS,GAAG,CAAC,CAAC;gBAClB,IAAI5E,KAAK,GAAG2B,SAAS,CAACmE,QAAQ,EAAEjE,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC;gBACpD,IAAI,CAACW,KAAK,CAACC,OAAO,CAACzC,KAAK,CAAC,EAAE;kBACvBA,KAAK,GAAG,CAACA,KAAK,CAAC;gBACnB;gBACAA,KAAK,CAAC6E,OAAO,CAAC,UAAUR,GAAG,EAAE;kBACzB,IAAI6E,aAAa,CAAC3F,QAAQ,CAACrB,IAAI,CAAC,EAAE;oBAC9B,IAAIoH,MAAM,GAAG,CAAC,CAAC,EAAEtI,WAAW,CAAC2H,KAAK,EAAEtE,GAAG,CAAC;oBACxC,IAAIiF,MAAM,EAAE;sBACR1E,SAAS,CAAC2E,QAAQ,GAAG,MAAM,IAAID,MAAM,GAAGA,MAAM,CAACpH,IAAI,GAAG,SAAS;sBAC/D,IAAI,aAAa,IAAIoH,MAAM,EAAE;wBACzB1E,SAAS,CAACkD,WAAW,GAAGwB,MAAM,CAACxB,WAAW;sBAC9C;oBACJ;kBACJ;kBACApD,cAAc,CAACyB,GAAG,CAACK,QAAQ,CAACoC,MAAM,EAAE1G,IAAI,EAAEmC,GAAG,EAAEO,SAAS,CAAC;gBAC7D,CAAC,CAAC;cACN,CAAC,CAAC;YACN;UACJ,CAAC,MACI;YACDuB,GAAG,CAACK,QAAQ,CAACqC,QAAQ,GAAGf,WAAW;YACnC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;YACwB,IAAIO,WAAW,CAACjG,MAAM,CAACN,IAAI,KAAK,QAAQ,EAAE;cACtCqE,GAAG,CAACK,QAAQ,CAACgD,IAAI,GAAG9G,IAAI,CAACC,SAAS,CAACD,IAAI,CAACiG,KAAK,CAACM,WAAW,CAAC,CAAC;YAC/D,CAAC,MACI;cACD;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;cAC4B,IAAIQ,SAAS,GAAGvL,MAAM,CAAC8E,IAAI,CAACwF,mBAAmB,CAACrF,UAAU,CAAC,CAACK,MAAM,CAAC,UAAUN,GAAG,EAAE;gBAC9E,IAAIiG,QAAQ,GAAGX,mBAAmB,CAACrF,UAAU,CAACD,GAAG,CAAC;gBAClD,OAAOiG,QAAQ,CAAC5G,MAAM,KAAK,MAAM,IAAI0G,WAAW,CAAC/F,GAAG,CAAC,KAAK7D,SAAS;cACvE,CAAC,CAAC;cACF,IAAIoK,SAAS,CAAChL,MAAM,EAAE;gBAClB,IAAI;kBACAgL,SAAS,CAAC5E,OAAO,CAAC,UAAU6E,IAAI,EAAE;oBAC9B,IAAI;sBACAT,WAAW,CAACS,IAAI,CAAC,GAAGhH,IAAI,CAACiG,KAAK,CAACM,WAAW,CAACS,IAAI,CAAC,CAAC;oBACrD,CAAC,CACD,OAAOjJ,CAAC,EAAE;sBACN;oBAAA;kBAER,CAAC,CAAC;kBACF;kBACA;kBACA,IAAI,OAAOwI,WAAW,CAAC3E,QAAQ,KAAK,WAAW,EAAE;oBAC7C2E,WAAW,GAAGA,WAAW,CAAC3E,QAAQ;kBACtC;kBACA6B,GAAG,CAACK,QAAQ,CAACgD,IAAI,GAAG9G,IAAI,CAACC,SAAS,CAACsG,WAAW,CAAC;gBACnD,CAAC,CACD,OAAOxI,CAAC,EAAE;kBACN0F,GAAG,CAACK,QAAQ,CAACgD,IAAI,GAAG7G,SAAS,CAACmD,QAAQ,CAACd,IAAI,CAAC;gBAChD;cACJ,CAAC,MACI;gBACDmB,GAAG,CAACK,QAAQ,CAACgD,IAAI,GAAGzE,gBAAgB,CAACe,QAAQ,CAACd,IAAI,CAAC;cACvD;YACJ;UACJ;QACJ,CAAC,CACD,OAAOvE,CAAC,EAAE;UACN;UACA;UACA0F,GAAG,CAACK,QAAQ,CAACgD,IAAI,GAAG7G,SAAS,CAACmD,QAAQ,CAACd,IAAI,CAAC;QAChD;MACJ,CAAC,MACI;QACDmB,GAAG,CAACK,QAAQ,CAACqC,QAAQ,GAAGf,WAAW;QACnC3B,GAAG,CAACK,QAAQ,CAACgD,IAAI,GAAGzE,gBAAgB,CAACe,QAAQ,CAACd,IAAI,CAAC;MACvD;IACJ;EACJ;EACA;EACA;EACA;EACA,IAAI,CAACmB,GAAG,CAACK,QAAQ,CAACgD,IAAI,IAAKnB,WAAW,IAAIA,WAAW,CAACjG,MAAM,IAAIlE,MAAM,CAAC8E,IAAI,CAACqF,WAAW,CAACjG,MAAM,CAAC,CAAC3D,MAAO,KACnG,CAACoJ,cAAc,EAAE;IACjB1B,GAAG,CAACE,OAAO,CAACzF,IAAI,CAAC;MACbsB,IAAI,EAAE,cAAc;MACpBlC,KAAK,EAAE8H;IACX,CAAC,CAAC;EACN;EACA,IAAI6B,oBAAoB,GAAGpE,SAAS,CAACqE,WAAW,CAAC,CAAC;EAClD,IAAID,oBAAoB,IAAIA,oBAAoB,CAAClL,MAAM,EAAE;IACrD;IACAkL,oBAAoB,CAAC9E,OAAO,CAAC,UAAUgF,OAAO,EAAE;MAC5C3L,MAAM,CAAC8E,IAAI,CAAC6G,OAAO,CAAC,CAAChF,OAAO,CAAC,UAAUiF,QAAQ,EAAE;QAC7C,IAAIC,aAAa,GAAG,CAAC,CAAC,EAAEzI,oBAAoB,CAAC,SAAS,CAAC,EAAEsE,aAAa,EAAER,IAAI,EAAE0E,QAAQ,CAAC;QACvF,IAAI,CAACC,aAAa,EAAE;UAChB;QACJ;QACA;QACA;QACA,IAAIA,aAAa,CAAC/J,KAAK,CAACkC,IAAI,KAAK,eAAe,EAAE;UAC9C,IAAIiE,GAAG,CAAC4D,aAAa,CAACjI,IAAI,CAAC,CAACoC,IAAI,CAAC,UAAUnE,CAAC,EAAE;YAAE,OAAOA,CAAC,CAACmC,IAAI,KAAK6H,aAAa,CAAC/J,KAAK,CAACkC,IAAI;UAAE,CAAC,CAAC,EAAE;YAC5F;UACJ;QACJ;QACA;QACA,IAAIiE,GAAG,CAAC4D,aAAa,CAACjI,IAAI,CAAC,CAACoC,IAAI,CAAC,UAAUnE,CAAC,EAAE;UAAE,OAAOA,CAAC,CAACmC,IAAI,KAAK6H,aAAa,CAAC/J,KAAK,CAACkC,IAAI,IAAInC,CAAC,CAACC,KAAK,KAAK+J,aAAa,CAAC/J,KAAK,CAACA,KAAK;QAAE,CAAC,CAAC,EAAE;UACrI;QACJ;QACAmG,GAAG,CAAC4D,aAAa,CAACjI,IAAI,CAAC,CAAClB,IAAI,CAACmJ,aAAa,CAAC/J,KAAK,CAAC;MACrD,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;EACA,IAAI9B,MAAM,CAAC8E,IAAI,CAACmD,GAAG,CAACK,QAAQ,CAAC,CAAC/H,MAAM,KAAK,CAAC,EAAE;IACxC,OAAO0H,GAAG,CAACK,QAAQ;EACvB;EACA,OAAO;IACHwD,GAAG,EAAE;MACDC,OAAO,EAAE,CACL;QACIC,OAAO,EAAE/D;MACb,CAAC;IAET;EACJ,CAAC;AACL;AACApF,OAAO,CAAC,SAAS,CAAC,GAAGkE,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}