"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitSubtitleByPunctuation = exports.addPunctuationToParagraph = exports.resetScriptLinesContent = exports.normalizeWhitespace = exports.getEqualedLine = void 0;
exports.cleanString = cleanString;
exports.cleanSentences = cleanSentences;
const constant_1 = require("../config/constant");
const char_1 = require("./char");
const getEqualedLine = (targetLine, subLine, isChinese) => {
    if (isChinese) {
        if (subLine === targetLine) {
            return targetLine.trim();
        }
    }
    else {
        if (subLine.trim() === targetLine.trim()) {
            return targetLine.trim();
        }
    }
    const cleanedSubLine = (0, char_1.removeSpecialCharacters)(subLine);
    const cleanedTargetLine = (0, char_1.removeSpecialCharacters)(targetLine);
    if (cleanedSubLine === cleanedTargetLine) {
        return cleanedTargetLine;
    }
    return '';
};
exports.getEqualedLine = getEqualedLine;
const splitSubtitleByPunctuation = (s, maxWidth = 9999) => {
    const result = [];
    let txt = '';
    for (const char of s) {
        if (!constant_1.PUNCTUATIONS.includes(char) && txt.length < maxWidth) {
            txt += char;
        }
        else {
            result.push(txt.replace(/[\s\u3000]+/g, ' ').trim());
            txt = '';
        }
    }
    return result;
};
exports.splitSubtitleByPunctuation = splitSubtitleByPunctuation;
function cleanString(sentence) {
    const punctuationRegex = new RegExp(`^[\\s${constant_1.PUNCTUATIONS.join('')}]+`, 'g');
    return sentence.replace(punctuationRegex, '');
}
function cleanSentences(sentences) {
    return sentences.map(cleanString);
}
const resetScriptLinesContent = (scriptLines, scriptLinesIndex, subLine) => {
    const lineText = scriptLines[scriptLinesIndex];
    const cleanedSubLine = (0, char_1.removeSpecialCharacters)(subLine);
    const cleanedLine = (0, char_1.removeSpecialCharacters)(lineText);
    if (cleanedSubLine.length > cleanedLine.length) {
        const excessStr = cleanedSubLine.slice(cleanedLine.length);
        if (scriptLines.length > scriptLinesIndex + 1) {
            const nextLine = scriptLines[scriptLinesIndex + 1];
            if (nextLine.startsWith(excessStr)) {
                scriptLines[scriptLinesIndex + 1] = nextLine.slice(excessStr.length);
            }
        }
    }
};
exports.resetScriptLinesContent = resetScriptLinesContent;
const normalizeWhitespace = (text) => {
    return text.replace(/[\s\u3000]+/g, ' ').trim();
};
exports.normalizeWhitespace = normalizeWhitespace;
const addPunctuationToParagraph = (text) => {
    const chinesePunctuation = /[，。？！；]/;
    const lines = text.split('\n');
    for (let i = 0; i < lines.length; i++) {
        if (i < lines.length - 1 && lines[i + 1].trim() === '') {
            if (!chinesePunctuation.test(lines[i].slice(-1))) {
                lines[i] += '。';
            }
        }
        const parts = lines[i].split(/\s+/);
        for (let j = 0; j < parts.length - 1; j++) {
            if (parts[j] &&
                parts[j + 1] &&
                !chinesePunctuation.test(parts[j].slice(-1)) &&
                !chinesePunctuation.test(parts[j + 1][0])) {
                parts[j] += '。';
            }
        }
        lines[i] = parts.join(' ');
    }
    return lines.join('\n');
};
exports.addPunctuationToParagraph = addPunctuationToParagraph;
//# sourceMappingURL=line.js.map