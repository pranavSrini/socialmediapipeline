"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateVideo = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const root_1 = require("./config/root");
const constant_1 = require("./config/constant");
const config_1 = require("./config/config");
const terms_1 = require("./terms");
const video_1 = require("./video");
const sub_maker_1 = require("./sub-maker");
const subtitle_1 = require("./subtitle");
const material_1 = require("./material");
const voice_1 = require("./voice");
const line_1 = require("./utils/line");
const log_1 = require("./utils/log");
const ffmpeg_1 = require("./utils/ffmpeg");
const generateVideo = async (params, progress = constant_1.progressFun) => {
    const config = (0, config_1.createOutputConfig)((0, config_1.mergeConfig)(params));
    const voiceName = (0, voice_1.parseVoiceName)(config.voiceName);
    let { videoScript = '', videoTerms, lastTime = 10, output = '', cacheDir = '', removeCache = true, lineBreakForce = true, addPunctuation = false, isChinese = true, subtitleMaxWidth = 9999, } = config;
    root_1.Root.currentConfig = config;
    if (isChinese) {
        videoScript = (0, line_1.normalizeWhitespace)((0, line_1.addPunctuationToParagraph)(videoScript));
    }
    if (addPunctuation) {
        videoScript = await (0, terms_1.addPunctuationWithAI)(videoScript, config);
    }
    (0, ffmpeg_1.setDefaultFFPath)();
    progress(5);
    fs_extra_1.default.ensureDir(path_1.default.dirname(output));
    fs_extra_1.default.ensureDirSync(cacheDir);
    if ((0, lodash_1.isEmpty)(videoTerms)) {
        videoTerms = await (0, terms_1.generateTermsWithAI)(videoScript.trim(), config);
    }
    else {
        if (typeof videoTerms === 'string') {
            videoTerms = videoTerms.split(/[,ï¼Œ]/).map(term => term.trim());
        }
        else if ((0, lodash_1.isArray)(videoTerms)) {
            videoTerms = videoTerms.map(term => term.trim());
        }
        else {
            throw new Error('video_terms must be a string or an array of strings');
        }
    }
    log_1.Logger.log(`video_terms: ${videoTerms}`);
    progress(10);
    const scriptFile = path_1.default.join(cacheDir, 'script.json');
    const scriptData = {
        script: videoScript,
        searchTerms: videoTerms,
        params: config,
    };
    fs_extra_1.default.writeJSON(scriptFile, scriptData);
    progress(15);
    const audioFile = path_1.default.join(cacheDir, 'audio.mp3');
    const subMaker = await (0, voice_1.tts)(videoScript, voiceName, audioFile, config);
    if (!subMaker)
        return '';
    progress(30);
    const videoDuration = Math.ceil((0, voice_1.getAudioDuration)(subMaker) + lastTime);
    let subtitleFile = path_1.default.join(cacheDir, 'subtitle.srt');
    await (0, subtitle_1.generateSubtitle)({
        subMaker,
        videoScript,
        subtitleFile,
        subtitleMaxWidth,
        lineBreakForce,
        isChinese
    });
    if (!fs_extra_1.default.exists(subtitleFile)) {
        log_1.Logger.warn('subtitle file not found, fallback to whisper');
    }
    const subtitleLines = (0, sub_maker_1.fileToSubtitles)(subtitleFile);
    if (!subtitleLines) {
        log_1.Logger.warn(`subtitle file is invalid: ${subtitleFile}`);
        subtitleFile = '';
    }
    progress(40);
    const downloadedVideos = await (0, material_1.downloadVideos)(videoTerms, videoDuration, cacheDir, config, progress);
    if ((0, lodash_1.isEmpty)(downloadedVideos)) {
        log_1.Logger.error('Failed to download videos, maybe the network is not available!');
        return '';
    }
    else {
        if (params.insertClips && (0, lodash_1.isArray)(params.insertClips)) {
            for (const clip of params.insertClips) {
                try {
                    const { videoId, newPath } = await (0, material_1.copyClipToCache)(clip.path, cacheDir);
                    const insertPosition = clip.position || 0;
                    if (insertPosition >= downloadedVideos.length) {
                        downloadedVideos.push(newPath);
                    }
                    else {
                        downloadedVideos.splice(insertPosition, 0, newPath);
                    }
                }
                catch (error) {
                    console.error('Error processing insert clip:', error);
                }
            }
        }
    }
    progress(85);
    const finalVideo = await (0, video_1.combineFinalVideo)(videoDuration, audioFile, subtitleFile, downloadedVideos, config, progress);
    if (removeCache) {
        fs_extra_1.default.remove(cacheDir);
    }
    progress(100);
    return finalVideo;
};
exports.generateVideo = generateVideo;
//# sourceMappingURL=generator.js.map