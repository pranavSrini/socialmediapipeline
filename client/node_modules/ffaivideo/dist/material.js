"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyClipToCache = exports.downloadVideos = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const md5_1 = __importDefault(require("md5"));
const path_1 = __importDefault(require("path"));
const axios_1 = __importDefault(require("axios"));
const lodash_1 = require("lodash");
const constant_1 = require("./config/constant");
const video_aspect_1 = require("./config/video-aspect");
const utils_1 = require("./utils/utils");
const file_1 = require("./utils/file");
const utils_2 = require("./utils/utils");
const http_1 = require("./utils/http");
const json_1 = require("./utils/json");
const log_1 = require("./utils/log");
const utils_3 = require("./utils/utils");
const http_2 = require("./utils/http");
const searchVideos = async (searchTerm, minDuration, config) => {
    const { videoAspect = constant_1.VideoAspect.Portrait, perPage = 20, materialAspectRatio = true, } = config;
    const videoOrientation = (0, utils_1.getEnumKeyByValue)(constant_1.VideoAspect, videoAspect);
    const [videoWidth, videoHeight] = (0, video_aspect_1.toResolution)(videoAspect);
    const searchData = {
        query: searchTerm,
        per_page: perPage.toString(),
        ...(materialAspectRatio && {
            orientation: videoOrientation.toLocaleLowerCase(),
        }),
    };
    const queryUrl = `https://api.pexels.com/videos/search`;
    const data = await (0, http_1.httpGet)((0, http_1.buildApiUrl)(queryUrl, searchData), {}, config.pexels);
    if (!data)
        return [];
    const videoItems = [];
    if (!('videos' in data)) {
        log_1.Logger.error(`search videos failed: ${JSON.stringify(data)}`);
        return videoItems;
    }
    let videos = data['videos'];
    if (videos.length <= 1 && config.preProcessMaterialVideo) {
        videos = await config.preProcessMaterialVideo(queryUrl, searchData, config.pexels);
    }
    for (const video of videos) {
        const duration = video['duration'];
        if (duration < minDuration) {
            continue;
        }
        const videoFiles = video['video_files'];
        let minWidth = 99999;
        let minHeight = 99999;
        let selectedItem = null;
        for (const file of videoFiles) {
            const w = parseInt(file['width']);
            const h = parseInt(file['height']);
            if (materialAspectRatio) {
                if ((0, utils_2.less)(w, videoWidth) || (0, utils_2.less)(h, videoHeight))
                    continue;
            }
            else {
                if ((0, utils_2.less)(w, videoWidth) && (0, utils_2.less)(h, videoHeight))
                    continue;
            }
            if (w < minWidth || h < minHeight) {
                minWidth = w;
                minHeight = h;
                selectedItem = {
                    provider: 'pexels',
                    keyword: searchTerm,
                    url: file['link'],
                    duration: duration,
                };
            }
        }
        if (selectedItem) {
            videoItems.push(selectedItem);
        }
    }
    return videoItems;
};
const saveVideo = async (videoUrl, cacheDir = '', config) => {
    fs_extra_1.default.ensureDirSync(cacheDir);
    const urlNoQuery = videoUrl.split('?')[0];
    const videoId = `vid-${(0, md5_1.default)(urlNoQuery)}`;
    const videoPath = `${cacheDir}/${videoId}.mp4`;
    if (fs_extra_1.default.existsSync(videoPath) && fs_extra_1.default.statSync(videoPath).size > 0) {
        return videoPath;
    }
    const stream = await (0, http_1.httpGet)(videoUrl, { responseType: 'stream' }, config.pexels);
    if (!stream)
        return '';
    await (0, file_1.writeFileWithStream)(stream, videoPath);
    if (fs_extra_1.default.existsSync(videoPath) && fs_extra_1.default.statSync(videoPath).size > 0) {
        return videoPath;
    }
    return '';
};
const downloadVideos = async (searchTerms, videoDuration = 0.0, cacheDir, config, progress) => {
    const { videoClipDuration: maxClipDuration = 10 } = config;
    let materialVideos = [];
    for (const [index, searchTerm] of searchTerms.entries()) {
        let videoItems = [];
        if (config.getMaterial) {
            videoItems = await config.getMaterial({
                searchTerm,
                index,
                maxClipDuration,
                cacheDir,
            });
            if ((0, lodash_1.isEmpty)(videoItems)) {
                videoItems = await searchVideos(searchTerm, maxClipDuration, config);
            }
        }
        else {
            videoItems = await searchVideos(searchTerm, maxClipDuration, config);
        }
        if (videoItems.length > 0) {
            const [a, b, c] = (0, utils_3.getSampleItems)(videoItems, 3);
            materialVideos = (0, utils_3.insertTriplet)(materialVideos, a, b, c);
        }
    }
    if (config.postProcessMaterialVideos) {
        materialVideos = config.postProcessMaterialVideos(materialVideos);
    }
    const videoPaths = [];
    let totalDuration = 0.0;
    let index = 0;
    for (const item of materialVideos) {
        try {
            index++;
            let savedVideoPath;
            if ((0, http_2.isNetUrl)(item.url)) {
                savedVideoPath = await saveVideo(item.url, cacheDir, config);
            }
            else {
                savedVideoPath = await (0, file_1.copyLocalFile)(item.url, cacheDir);
            }
            progress(40 + Math.floor((index * 45) / materialVideos.length));
            if (savedVideoPath) {
                videoPaths.push(savedVideoPath);
                const seconds = Math.min(maxClipDuration, item.duration);
                totalDuration += seconds;
                if (totalDuration > videoDuration) {
                    break;
                }
            }
        }
        catch (e) {
            log_1.Logger.error(`failed to download video: ${(0, json_1.toJson)(item)} => ${e}`);
        }
    }
    log_1.Logger.log(`downloaded ${videoPaths.length} videos`);
    return videoPaths;
};
exports.downloadVideos = downloadVideos;
const copyClipToCache = async (clipPath, cacheDir) => {
    const videoId = `vid-${(0, utils_3.uuid)().substring(0, 8)}`;
    const newPath = path_1.default.join(cacheDir, videoId);
    const isUrl = (0, http_2.isNetUrl)(clipPath);
    if (isUrl) {
        try {
            const response = await (0, axios_1.default)({
                method: 'GET',
                url: clipPath,
                responseType: 'stream',
            });
            await fs_extra_1.default.ensureDir(cacheDir);
            const writer = fs_extra_1.default.createWriteStream(newPath);
            response.data.pipe(writer);
            await new Promise((resolve, reject) => {
                writer.on('finish', resolve);
                writer.on('error', reject);
            });
        }
        catch (error) {
            console.error('Error downloading file:', error);
            throw error;
        }
    }
    else {
        try {
            await fs_extra_1.default.copy(clipPath, newPath);
        }
        catch (error) {
            console.error('Error copying file:', error);
            throw error;
        }
    }
    return { videoId, newPath };
};
exports.copyClipToCache = copyClipToCache;
//# sourceMappingURL=material.js.map