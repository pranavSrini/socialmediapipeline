"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSubtitle = void 0;
const lodash_1 = require("lodash");
const date_1 = require("./utils/date");
const constant_1 = require("./config/constant");
const char_1 = require("./utils/char");
const line_1 = require("./utils/line");
const file_1 = require("./utils/file");
const generateSubtitle = async ({ subMaker, videoScript, subtitleFile, subtitleMaxWidth, lineBreakForce, isChinese, }) => {
    const formattedSubtitles = [];
    let scriptLines = (0, line_1.cleanSentences)((0, line_1.splitSubtitleByPunctuation)((0, char_1.normalizeWhitespace)(videoScript)));
    let startTime = -1.0;
    let endTime = -1.0;
    let scriptLinesIndex = 0;
    let subLine = '';
    let scriptLinesc;
    if (lineBreakForce && isChinese) {
        scriptLinesc = restructureScriptLines({
            subMaker,
            subtitleMaxWidth,
            isChinese,
            scriptLines,
        });
    }
    else {
        scriptLinesc = (0, lodash_1.clone)(scriptLines);
    }
    for (let i = 0; i < subMaker.offset.length; i++) {
        let [offset, sub] = [subMaker.offset[i], subMaker.subs[i]];
        const [starTime, enTime] = offset;
        if (startTime < 0)
            startTime = starTime;
        endTime = enTime;
        subLine += `${(0, char_1.safeDecodeURIComponent)(sub)}${isChinese ? '' : ' '}`;
        let lineText = '';
        if (scriptLinesc.length > scriptLinesIndex) {
            const targetLine = scriptLinesc[scriptLinesIndex];
            lineText = (0, line_1.getEqualedLine)(targetLine, subLine, isChinese);
        }
        if (lineText) {
            scriptLinesIndex++;
            const maxWidth = lineBreakForce ? subtitleMaxWidth + 4 : subtitleMaxWidth;
            lineText = (0, char_1.addLineBreaks)(lineText, maxWidth);
            const subtitle = (0, date_1.subtitleFormatter)(scriptLinesIndex, startTime, endTime, lineText);
            formattedSubtitles.push(subtitle);
            startTime = -1.0;
            endTime = -1.0;
            subLine = '';
        }
    }
    await (0, file_1.writeSubtitles)(subtitleFile, formattedSubtitles, scriptLinesc.length);
};
exports.generateSubtitle = generateSubtitle;
const restructureScriptLines = ({ subMaker, subtitleMaxWidth, isChinese, scriptLines, }) => {
    let scriptLinesc = [];
    let subLine = '';
    let oldSubLine = '';
    for (let i = 0; i < subMaker.offset.length; i++) {
        const sub = subMaker.subs[i];
        oldSubLine = subLine;
        subLine += `${sub}${isChinese ? '' : ' '}`;
        if (constant_1.TINY_PUNCTUATIONS.includes(sub)) {
            scriptLinesc.push(subLine);
            subLine = '';
            continue;
        }
        if (subLine.length > subtitleMaxWidth) {
            if (!isChinese) {
                scriptLinesc.push(oldSubLine.trim());
            }
            else {
                scriptLinesc.push(oldSubLine);
            }
            subLine = isChinese ? sub : `${sub} `;
            continue;
        }
    }
    if (subLine.length > 0) {
        scriptLinesc.push(subLine);
    }
    return scriptLinesc;
};
//# sourceMappingURL=subtitle.js.map